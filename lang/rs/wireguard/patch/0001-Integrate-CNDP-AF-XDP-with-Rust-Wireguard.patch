From 5089e9711e827262834b5c72d3120d8ed512c7a5 Mon Sep 17 00:00:00 2001
From: Manoj Gopalakrishnan <manoj.gopalakrishnan@intel.com>
Date: Mon, 19 Sep 2022 12:12:50 +0000
Subject: [PATCH] Integrate CNDP/AF-XDP with Rust Wireguard.

 - Add CNDP support in wireguard to send and receive UDP packets using AF-XDP.

 - Add openssl support (optional) for chacha20poly1305 encryption/decryption.

 - Optionally use Rust channel to implement Wireguard Tun interface. This will
   replace Linux Kernel Tun interface for wireguard data path. Control path still
   uses TUN interface to configure wireguard with ip address/private-keys/peer
   public key etc.

 - Add example application to send/recv packets using CNDP/Wireguard stack and
   using rust mpsc channel instead of using kernel Tun. This is tested using DPDK
   packet generator. Add sample DPDK PktGen configuration files.

 - Add wireguard CNDP ping sample application using Rust channel.

 - By default, Wireguard Rust creates worker threads equal to number of
   physical cores. This is degrading performance in systems with many cores
   due to threading overhead. Configure CPU core affinity for wireguard
   worker thread and tun reader thread to get consistent performance (throughput).

 - Pass ownership of encrypted buffer to UDP writer to avoid buffer copy.

 - Avoid dynamic allocation of vector for adding AEAD tag. In TX path,
   the message vector  size was extended dynamically (realloc) for
   encryption tag which resulted in extra calls to malloc for every packet.
   Reserve the size for encryption tag when allocating vector initially.

Signed-off-by: Manoj Gopalakrishnan <manoj.gopalakrishnan@intel.com>
---
 Cargo.toml                                    |  47 +-
 src/main_cndp_packet.rs                       | 403 ++++++++
 src/main_cndp_ping.rs                         | 774 +++++++++++++++
 src/platform/dummy/udp.rs                     |  10 +-
 src/platform/linux/cndp/README.md             |  67 ++
 src/platform/linux/cndp/cndp_error.rs         |  37 +
 src/platform/linux/cndp/cndp_pkt_fwd.jsonc    | 187 ++++
 src/platform/linux/cndp/cndprustwg.sh         |  95 ++
 src/platform/linux/cndp/endpoint.rs           |  43 +
 src/platform/linux/cndp/eth_packet_rw.rs      | 867 +++++++++++++++++
 src/platform/linux/cndp/fwd.jsonc             | 157 ++++
 src/platform/linux/cndp/mod.rs                |  10 +
 src/platform/linux/cndp/packet.rs             | 727 ++++++++++++++
 src/platform/linux/cndp/pktgen_cfg/pktgen.cfg |  55 ++
 src/platform/linux/cndp/pktgen_cfg/xdp.cfg    | 140 +++
 src/platform/linux/cndp/tun_channel.rs        | 245 +++++
 src/platform/linux/cndp/udp.rs                | 883 ++++++++++++++++++
 src/platform/linux/cndp/wg_cndp.toml          |  32 +
 src/platform/linux/mod.rs                     |   7 +
 src/platform/linux/tun.rs                     |   6 +-
 src/platform/linux/udp.rs                     |   8 +-
 src/platform/udp.rs                           |   4 +-
 src/wireguard/constants.rs                    |   3 +
 src/wireguard/handshake/macs.rs               |   6 +-
 src/wireguard/handshake/noise.rs              |   6 +-
 src/wireguard/router/device.rs                |  34 +-
 src/wireguard/router/peer.rs                  |   8 +-
 src/wireguard/router/queue.rs                 |  27 +
 src/wireguard/router/receive.rs               |  52 +-
 src/wireguard/router/send.rs                  |  80 +-
 src/wireguard/router/tests/bench.rs           |  10 +-
 src/wireguard/router/tests/tests.rs           |   8 +-
 src/wireguard/wireguard.rs                    |  86 +-
 src/wireguard/workers.rs                      |  22 +-
 34 files changed, 5063 insertions(+), 83 deletions(-)
 create mode 100644 src/main_cndp_packet.rs
 create mode 100644 src/main_cndp_ping.rs
 create mode 100644 src/platform/linux/cndp/README.md
 create mode 100644 src/platform/linux/cndp/cndp_error.rs
 create mode 100644 src/platform/linux/cndp/cndp_pkt_fwd.jsonc
 create mode 100755 src/platform/linux/cndp/cndprustwg.sh
 create mode 100644 src/platform/linux/cndp/endpoint.rs
 create mode 100644 src/platform/linux/cndp/eth_packet_rw.rs
 create mode 100644 src/platform/linux/cndp/fwd.jsonc
 create mode 100644 src/platform/linux/cndp/mod.rs
 create mode 100644 src/platform/linux/cndp/packet.rs
 create mode 100644 src/platform/linux/cndp/pktgen_cfg/pktgen.cfg
 create mode 100644 src/platform/linux/cndp/pktgen_cfg/xdp.cfg
 create mode 100644 src/platform/linux/cndp/tun_channel.rs
 create mode 100644 src/platform/linux/cndp/udp.rs
 create mode 100644 src/platform/linux/cndp/wg_cndp.toml

diff --git a/Cargo.toml b/Cargo.toml
index 640d8cb..7cb769b 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -5,12 +5,22 @@ license = "MIT"
 name = "wireguard-rs"
 version = "0.1.4"
 
+[[bin]]
+name = "cndp-ping"
+path = "src/main_cndp_ping.rs"
+required-features = ["cndp"]
+
+[[bin]]
+name = "cndp-packet"
+path = "src/main_cndp_packet.rs"
+required-features = ["cndp"]
+
 [dependencies]
-aead = "^0.3"
 arraydeque = "0.4.5"
 blake2 = "^0.9"
 byteorder = "1.3"
-chacha20poly1305 = "^0.7"
+cfg-if = "^1.0.0"
+chacha20poly1305 = "^0.8"
 clear_on_drop = "0.2.3"
 cpuprofiler = {version = "*", optional = true}
 crossbeam-channel = "^0.5"
@@ -29,6 +39,13 @@ rand_core = "^0.5"
 ring = "0.16"
 spin = "0.7"
 zerocopy = "0.3"
+pnet = {version = "^0.28", optional = true }
+core_affinity = {version= "0.5.10", optional = true }
+toml = {version = "0.5.8", optional = true }
+clap ={version = "2.33.3", optional = true }
+once_cell = {version = "^1.10", optional = true }
+openssl = {version = "^0.10", optional = true, features = ["vendored"]  }
+cndp-cne = {git = "https://github.com/CloudNativeDataPlane/cndp", branch = "main", optional = true }
 
 [dependencies.treebitmap]
 package = "ip_network_table-deps-treebitmap"
@@ -45,10 +62,34 @@ version = "^2.4"
 #features = ["nightly"]
 
 [features]
+default = ["cndp", "openssl_enc_dec"]
+
+#Uncomment below to profile wireguard application
+#default = ["cndp", "openssl_enc_dec", "profiler"]
+
+#Uncomment below two lines for running benchmark tests.
+#default = ["unstable", "profiler"]
+#unstable = []
+
 profiler = ["cpuprofiler"]
 start_up = []
+openssl_enc_dec = ["openssl"]
+cndp = ["pnet", "core_affinity", "toml", "clap", "once_cell", "cndp-cne"]
 
 [dev-dependencies]
-pnet = "^0.27"
+pnet = "^0.28"
 proptest = "^0.10"
 rand_chacha = "^0.2"
+
+[profile.dev]
+lto = true
+opt-level = 3
+
+[profile.release]
+opt-level = 3
+# Without enabling lto, packet processing with pnet is slow.
+# For example, without lto, pnet get/set mac address is ~50% slower.
+lto = true
+
+# Uncomment to enable debug symbols.
+debug = 2
diff --git a/src/main_cndp_packet.rs b/src/main_cndp_packet.rs
new file mode 100644
index 0000000..7273b92
--- /dev/null
+++ b/src/main_cndp_packet.rs
@@ -0,0 +1,403 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+
+#![cfg_attr(feature = "unstable", feature(test))]
+
+extern crate alloc;
+
+#[cfg(feature = "profiler")]
+extern crate cpuprofiler;
+
+#[cfg(feature = "profiler")]
+use cpuprofiler::PROFILER;
+
+mod configuration;
+mod platform;
+mod wireguard;
+
+mod util;
+
+use std::process::exit;
+use std::sync::{Arc, RwLock};
+use std::thread;
+use std::time;
+
+use clap::{App, Arg};
+
+use configuration::Configuration;
+
+use cne::instance::CneInstance;
+
+use platform::linux::cndp::cndp_error::CndpError;
+use platform::linux::cndp::endpoint::CndpEndpoint;
+use platform::linux::cndp::eth_packet_rw::*;
+use platform::linux::cndp::packet::CndpPacketUtil;
+use platform::linux::cndp::tun_channel;
+use platform::tun::Status;
+use platform::uapi::{BindUAPI, PlatformUAPI};
+use platform::*;
+
+use wireguard::WireGuard;
+
+#[cfg(feature = "profiler")]
+fn profiler_stop() {
+    println!("Stopping profiler");
+    PROFILER.lock().unwrap().stop().unwrap();
+}
+
+#[cfg(not(feature = "profiler"))]
+fn profiler_stop() {}
+
+#[cfg(feature = "profiler")]
+fn profiler_start(name: &str) {
+    use std::path::Path;
+
+    // find first available path to save profiler output
+    let mut n = 0;
+    loop {
+        let path = format!("./{}-{}.profile", name, n);
+        if !Path::new(path.as_str()).exists() {
+            println!("Starting profiler: {}", path);
+            PROFILER.lock().unwrap().start(path).unwrap();
+            break;
+        };
+        n += 1;
+    }
+}
+
+fn main() {
+    // Parse command line arguments.
+    let matches = App::new("CNDP Wireguard Ping Example")
+        .version("0.1.0")
+        .about("CNDP Wireguard Ping Example")
+        .arg(
+            Arg::with_name("foreground")
+                .short("f")
+                .long("foreground")
+                .takes_value(false)
+                .help("Run app in foreground"),
+        )
+        .arg(
+            Arg::with_name("disable_drop_privileges")
+                .short("p")
+                .long("disable-drop-privileges")
+                .takes_value(false)
+                .help("Drop privileges for daemon process. Set gid/uid to nobody"),
+        )
+        .arg(
+            Arg::with_name("device")
+                .short("d")
+                .long("device")
+                .takes_value(true)
+                .help("WireGuard interface name"),
+        )
+        .arg(
+            Arg::with_name("traffic_gen_mac")
+                .short("t")
+                .long("traffic-gen-mac")
+                .takes_value(true)
+                .help("Local NIC Interface name generating/terminating traffic"),
+        )
+        .arg(
+            Arg::with_name("send")
+                .short("s")
+                .long("send")
+                .takes_value(false)
+                .help("Send traffic to remote"),
+        )
+        .get_matches();
+
+    let mut foreground = false;
+    if matches.is_present("foreground") {
+        foreground = true;
+    }
+    let mut drop_privileges = true;
+    if matches.is_present("disable_drop_privileges") {
+        drop_privileges = false;
+    }
+    // Wireguard interface name.
+    let name = matches.value_of("device").expect("No device name supplied");
+    // Traffic gen interface.
+    let traffic_gen_mac = matches
+        .value_of("traffic_gen_mac")
+        .expect("traffic_gen_mac is not provided");
+    let traffic_gen_mac = String::from(traffic_gen_mac);
+    // Send traffic
+    let mut send = false;
+    if matches.is_present("send") {
+        send = true;
+    }
+
+    // Create UAPI socket.
+    let uapi = plt::UAPI::bind(name).unwrap_or_else(|e| {
+        eprintln!("Failed to create UAPI listener: {}", e);
+        exit(-2);
+    });
+
+    // Create TUN (Rust channel) device.
+    let (tun_app_reader, tun_app_writer, mut readers, writer, status) =
+        tun_channel::TunChannel::create(name).unwrap_or_else(|e| {
+            eprintln!("Failed to create TUN device: {}", e);
+            exit(-3);
+        });
+
+    // drop privileges
+    if drop_privileges {
+        match util::drop_privileges() {
+            Ok(_) => (),
+            Err(e) => {
+                eprintln!("Failed to drop privileges: {}", e);
+                exit(-4);
+            }
+        }
+    }
+
+    // daemonize to background
+    if !foreground {
+        match util::daemonize() {
+            Ok(_) => (),
+            Err(e) => {
+                eprintln!("Failed to daemonize: {}", e);
+                exit(-5);
+            }
+        }
+    }
+
+    // start logging
+    env_logger::builder()
+        .try_init()
+        .expect("Failed to initialize event logger");
+
+    log::info!("Starting {} WireGuard device.", name);
+
+    // start profiler (if enabled)
+    #[cfg(feature = "profiler")]
+    profiler_start(name);
+
+    // create WireGuard device
+    let wg: WireGuard<tun_channel::TunChannel, plt::UDP> = WireGuard::new(writer);
+
+    // add all Tun readers
+    while let Some(reader) = readers.pop() {
+        wg.add_tun_reader(reader);
+    }
+
+    // wrap in configuration interface
+    let cfg = configuration::WireGuardConfig::new(wg.clone());
+    let tun_up = Arc::new(RwLock::new(false));
+    let tun_up_clone = Arc::clone(&tun_up);
+    // start Tun event thread
+    {
+        let cfg = cfg.clone();
+        let mut status = status;
+        thread::spawn(move || loop {
+            match status.event() {
+                Err(e) => {
+                    log::info!("Tun device error {}", e);
+                    profiler_stop();
+                    exit(0);
+                }
+                Ok(tun::TunEvent::Up(mtu)) => {
+                    log::info!("Tun up (mtu = {})", mtu);
+                    let _ = cfg.up(mtu); // TODO: handle
+                    let mut tun_up = tun_up_clone.write().unwrap();
+                    *tun_up = true;
+                }
+                Ok(tun::TunEvent::Down) => {
+                    log::info!("Tun down");
+                    cfg.down();
+                    let mut tun_up = tun_up_clone.write().unwrap();
+                    *tun_up = false;
+                }
+            }
+        });
+    }
+
+    // start UAPI server
+    let cfg = cfg.clone();
+    thread::spawn(move || loop {
+        // accept and handle UAPI config connections
+        match uapi.connect() {
+            Ok(mut stream) => {
+                let cfg = cfg.clone();
+                thread::spawn(move || {
+                    configuration::uapi::handle(&mut stream, &cfg);
+                });
+            }
+            Err(err) => {
+                log::info!("UAPI connection error: {}", err);
+                profiler_stop();
+                exit(-1);
+            }
+        }
+    });
+
+    // Wait for wireguard setup to complete before starting app send/recv.
+    let tun_up_clone = Arc::clone(&tun_up);
+    loop {
+        {
+            let tun_up = tun_up_clone.read().unwrap();
+            // Check if TUN is up.
+            if *tun_up {
+                log::info!("Wireguard enabled. Start App send/recv thread");
+                break;
+            }
+        }
+        // Wait for 1 sec and then check again.
+        thread::sleep(time::Duration::from_secs(1));
+    }
+    let tun_up_clone = Arc::clone(&tun_up);
+    test_send_recv_packet_different_thread(
+        tun_app_reader,
+        tun_app_writer,
+        tun_up_clone,
+        send,
+        traffic_gen_mac,
+    );
+
+    // Block until all tun readers closed.
+    wg.wait();
+    profiler_stop();
+    log::info!("Application exiting.");
+}
+
+fn test_send_recv_packet_different_thread(
+    tun_app_reader: tun_channel::TunChannelAppReader,
+    tun_app_writer: tun_channel::TunChannelAppWriter,
+    tun_up: Arc<RwLock<bool>>,
+    send: bool,
+    traffic_gen_mac: String,
+) {
+    // Bind to traffic generator CNDP reader/writer.
+    let (mut reader, writer, owner) = match CndpPacketSyncChannel::bind() {
+        Ok(r) => r,
+        Err(e) => {
+            log::error!("Error Bind {}", e);
+            return;
+        }
+    };
+
+    // Tun up/down check thread.
+    let tun_up_clone = Arc::clone(&tun_up);
+    let tun_check_thread_handle = thread::spawn(move || {
+        loop {
+            if !check_if_tun_up(&tun_up_clone) {
+                break;
+            }
+            thread::sleep(time::Duration::from_secs(1));
+        }
+        // Drop owner. This will quit packet reader/writer threads.
+        std::mem::drop(owner);
+        // Quit CNDP.
+        let cne = CneInstance::get_instance();
+        // Cleanup CNE.
+        let ret = cne.cleanup();
+        if let Err(e) = ret {
+            log::error!("{}", e.to_string());
+        }
+        log::info!("Exit Tun check thread");
+    });
+
+    // Receive packets thread.
+    let tun_up_clone = Arc::clone(&tun_up);
+    let app_recv_thread_handle = thread::spawn(move || {
+        let mut app_pkts_recvd = 0;
+        // Dst mac of traffic generator interface.
+        let dst_mac = CndpPacketUtil::get_mac_from_string(&traffic_gen_mac);
+        let mut dst = CndpEndpoint::new(None, None, dst_mac);
+        let timeout = time::Duration::from_micros(20);
+        log::info!("Start receive packets thread");
+        loop {
+            if !check_if_tun_up(&tun_up_clone) {
+                break;
+            }
+            match tun_app_reader.read_timeout(timeout) {
+                Ok(packet) => {
+                    app_pkts_recvd += 1;
+                    log::debug!("Received app packet of length = {}", packet.len());
+                    // Write packet to traffic generator interface.
+                    match writer.write(packet, &mut dst) {
+                        Err(CndpError::Disconnected) => {
+                            log::info!("Packet writer disconnected");
+                            break;
+                        }
+                        Err(e) => {
+                            log::info!("Error writing packet {}", e);
+                            break;
+                        }
+                        Ok(_) => {}
+                    }
+                }
+                Err(tun_channel::TunChannelAppError::Timeout) => {}
+                Err(_) => {
+                    log::info!("Tun app read failed. Terminating app recv thread.");
+                    break;
+                }
+            }
+        }
+        log::info!("app_pkts_recvd = {}", app_pkts_recvd);
+    });
+
+    // Send packets thread.
+    if send {
+        let app_send_thread_handle = thread::spawn(move || {
+            log::info!("Start Send packets thread");
+            let mut app_pkts_sent = 0;
+            let mut app_pkts_skip = 0;
+            const MAX_PKT_SIZE: usize = 1500;
+            loop {
+                let mut packet: Vec<u8> = vec![0; MAX_PKT_SIZE];
+                // Read packet from traffic generator interface.
+                let (payload_len, _src) = match reader.read(&mut packet) {
+                    Err(CndpError::Disconnected) => {
+                        log::info!("Packet reader disconnected");
+                        break;
+                    }
+                    Err(e) => {
+                        log::error!("Error reading Packet {}", e);
+                        break;
+                    }
+                    Ok(v) => v,
+                };
+                packet.truncate(payload_len);
+                log::debug!(
+                    "Send app packet of length = {} to tun at time {} ",
+                    packet.len(),
+                    time::SystemTime::now()
+                        .duration_since(std::time::UNIX_EPOCH)
+                        .unwrap()
+                        .as_micros()
+                );
+                match tun_app_writer.write(packet) {
+                    Ok(_) => {
+                        app_pkts_sent += 1;
+                    }
+                    Err(tun_channel::TunChannelAppError::BufferFull) => {
+                        app_pkts_skip += 1;
+                    }
+                    Err(_) => {
+                        log::info!("Tun app write failed. Terminating app send thread.");
+                        break;
+                    }
+                }
+            }
+            log::info!(
+                "app_pkts_sent = {}, app_pkts_skip = {}",
+                app_pkts_sent,
+                app_pkts_skip
+            );
+        });
+        // Wait for packet send thread to quit.
+        app_send_thread_handle.join().unwrap();
+    }
+    // Wait for packet recv thread to quit.
+    app_recv_thread_handle.join().unwrap();
+    // Wait for Tun check thread to quit.
+    tun_check_thread_handle.join().unwrap();
+}
+
+fn check_if_tun_up(tun_up: &Arc<RwLock<bool>>) -> bool {
+    let tun_up = tun_up.read().unwrap();
+    *tun_up
+}
diff --git a/src/main_cndp_ping.rs b/src/main_cndp_ping.rs
new file mode 100644
index 0000000..c0d206b
--- /dev/null
+++ b/src/main_cndp_ping.rs
@@ -0,0 +1,774 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+
+#![cfg_attr(feature = "unstable", feature(test))]
+
+extern crate alloc;
+
+#[cfg(feature = "profiler")]
+extern crate cpuprofiler;
+
+#[cfg(feature = "profiler")]
+use cpuprofiler::PROFILER;
+
+mod configuration;
+mod platform;
+mod wireguard;
+
+mod util;
+
+use std::convert::TryInto;
+use std::mem;
+use std::net::IpAddr;
+use std::process::exit;
+use std::sync::{Arc, Mutex, RwLock};
+use std::thread;
+use std::time;
+
+use clap::{App, Arg};
+
+use configuration::Configuration;
+
+use cne::instance::CneInstance;
+
+use platform::linux::cndp::tun_channel;
+use platform::tun::Status;
+use platform::uapi::{BindUAPI, PlatformUAPI};
+use platform::*;
+
+use wireguard::WireGuard;
+
+use pnet::packet::icmp::echo_reply::{EchoReplyPacket, MutableEchoReplyPacket};
+use pnet::packet::icmp::echo_request::{EchoRequestPacket, MutableEchoRequestPacket};
+use pnet::packet::icmp::{checksum, IcmpCode, IcmpPacket, IcmpTypes};
+use pnet::packet::ip::IpNextHeaderProtocols;
+use pnet::packet::ipv4::{self, Ipv4Packet, MutableIpv4Packet};
+use pnet::packet::Packet;
+
+#[cfg(feature = "profiler")]
+fn profiler_stop() {
+    println!("Stopping profiler");
+    PROFILER.lock().unwrap().stop().unwrap();
+}
+
+#[cfg(not(feature = "profiler"))]
+fn profiler_stop() {}
+
+#[cfg(feature = "profiler")]
+fn profiler_start(name: &str) {
+    use std::path::Path;
+
+    // find first available path to save profiler output
+    let mut n = 0;
+    loop {
+        let path = format!("./{}-{}.profile", name, n);
+        if !Path::new(path.as_str()).exists() {
+            println!("Starting profiler: {}", path);
+            PROFILER.lock().unwrap().start(path).unwrap();
+            break;
+        };
+        n += 1;
+    }
+}
+
+fn main() {
+    // Parse command line arguments.
+    let matches = App::new("CNDP Wireguard Ping Example")
+        .version("0.1.0")
+        .about("CNDP Wireguard Ping Example")
+        .arg(
+            Arg::with_name("foreground")
+                .short("f")
+                .long("foreground")
+                .takes_value(false)
+                .help("Run app in foreground"),
+        )
+        .arg(
+            Arg::with_name("disable_drop_privileges")
+                .short("p")
+                .long("disable-drop-privileges")
+                .takes_value(false)
+                .help("Drop privileges for daemon process. Set gid/uid to nobody"),
+        )
+        .arg(
+            Arg::with_name("local_ip")
+                .short("l")
+                .long("local")
+                .takes_value(true)
+                .help("Local Ip address"),
+        )
+        .arg(
+            Arg::with_name("remote_ip")
+                .short("r")
+                .long("remote")
+                .takes_value(true)
+                .help("Remote Ip address"),
+        )
+        .arg(
+            Arg::with_name("ping_interval")
+                .short("i")
+                .long("interval")
+                .takes_value(true)
+                .help("Ping interval in ms"),
+        )
+        .arg(
+            Arg::with_name("device")
+                .short("d")
+                .long("device")
+                .takes_value(true)
+                .help("WireGuard interface name"),
+        )
+        .get_matches();
+
+    let mut foreground = false;
+    if matches.is_present("foreground") {
+        foreground = true;
+    }
+    let mut drop_privileges = true;
+    if matches.is_present("disable_drop_privileges") {
+        drop_privileges = false;
+    }
+    // Wireguard interface name.
+    let name = matches.value_of("device").expect("No device name supplied");
+    // Local ip.
+    let local_ip = matches
+        .value_of("local_ip")
+        .expect("Local ip addr is not provided");
+    let local_ip = String::from(local_ip);
+    // Remote ip.
+    let remote_ip = matches
+        .value_of("remote_ip")
+        .expect("Remote ip addr is not provided");
+    let remote_ip = String::from(remote_ip);
+    // Ping interval.
+    let ping_interval = matches
+        .value_of("ping_interval")
+        .unwrap_or("1000")
+        .parse::<u64>()
+        .expect("unable to parse ping interval");
+
+    // Create UAPI socket.
+    let uapi = plt::UAPI::bind(name).unwrap_or_else(|e| {
+        eprintln!("Failed to create UAPI listener: {}", e);
+        exit(-2);
+    });
+
+    // Create TUN (Rust channel) device.
+    let (tun_app_reader, tun_app_writer, mut readers, writer, status) =
+        tun_channel::TunChannel::create(name).unwrap_or_else(|e| {
+            eprintln!("Failed to create TUN device: {}", e);
+            exit(-3);
+        });
+
+    // drop privileges
+    if drop_privileges {
+        match util::drop_privileges() {
+            Ok(_) => (),
+            Err(e) => {
+                eprintln!("Failed to drop privileges: {}", e);
+                exit(-4);
+            }
+        }
+    }
+
+    // daemonize to background
+    if !foreground {
+        match util::daemonize() {
+            Ok(_) => (),
+            Err(e) => {
+                eprintln!("Failed to daemonize: {}", e);
+                exit(-5);
+            }
+        }
+    }
+
+    // start logging
+    env_logger::builder()
+        .try_init()
+        .expect("Failed to initialize event logger");
+
+    log::info!("Starting {} WireGuard device.", name);
+
+    // start profiler (if enabled)
+    #[cfg(feature = "profiler")]
+    profiler_start(name);
+
+    // create WireGuard device
+    let wg: WireGuard<tun_channel::TunChannel, plt::UDP> = WireGuard::new(writer);
+
+    // add all Tun readers
+    while let Some(reader) = readers.pop() {
+        wg.add_tun_reader(reader);
+    }
+
+    // wrap in configuration interface
+    let cfg = configuration::WireGuardConfig::new(wg.clone());
+    let tun_up = Arc::new(RwLock::new(false));
+    let tun_up_clone = Arc::clone(&tun_up);
+
+    // start Tun event thread
+    {
+        let cfg = cfg.clone();
+        let mut status = status;
+        thread::spawn(move || loop {
+            match status.event() {
+                Err(e) => {
+                    log::info!("Tun device error {}", e);
+                    profiler_stop();
+                    exit(0);
+                }
+                Ok(tun::TunEvent::Up(mtu)) => {
+                    log::info!("Tun up (mtu = {})", mtu);
+                    let _ = cfg.up(mtu); // TODO: handle
+                    let mut tun_up = tun_up_clone.write().unwrap();
+                    *tun_up = true;
+                }
+                Ok(tun::TunEvent::Down) => {
+                    log::info!("Tun down");
+                    cfg.down();
+                    let mut tun_up = tun_up_clone.write().unwrap();
+                    *tun_up = false;
+                }
+            }
+        });
+    }
+
+    // start UAPI server
+    thread::spawn(move || loop {
+        // accept and handle UAPI config connections
+        match uapi.connect() {
+            Ok(mut stream) => {
+                let cfg = cfg.clone();
+                thread::spawn(move || {
+                    configuration::uapi::handle(&mut stream, &cfg);
+                });
+            }
+            Err(err) => {
+                log::info!("UAPI connection error: {}", err);
+                profiler_stop();
+                exit(-1);
+            }
+        }
+    });
+
+    // Wait for wireguard setup to complete before starting app send/recv.
+    let tun_up_clone = Arc::clone(&tun_up);
+    loop {
+        {
+            let tun_up = tun_up_clone.read().unwrap();
+            // Check if TUN is up.
+            if *tun_up {
+                log::info!("Wireguard enabled. Start App send/recv thread");
+                break;
+            }
+        }
+        // Wait for 1 sec and then check again.
+        thread::sleep(time::Duration::from_secs(1));
+    }
+
+    let tun_up_clone = Arc::clone(&tun_up);
+    let test_same_thread = true;
+    if test_same_thread {
+        // Test ping app send/recv in same thread.
+        test_ping_send_recv_same_thread(
+            tun_app_reader,
+            tun_app_writer,
+            tun_up_clone,
+            local_ip,
+            remote_ip,
+            ping_interval,
+        );
+    } else {
+        // Test ping app send/recv in different thread.
+        test_ping_send_recv_different_thread(
+            tun_app_reader,
+            tun_app_writer,
+            tun_up_clone,
+            local_ip,
+            remote_ip,
+            ping_interval,
+        );
+    }
+
+    // Block until all tun readers closed.
+    wg.wait();
+    profiler_stop();
+    log::info!("Application exiting.");
+}
+
+fn test_ping_send_recv_same_thread(
+    tun_app_reader: tun_channel::TunChannelAppReader,
+    tun_app_writer: tun_channel::TunChannelAppWriter,
+    tun_up: Arc<RwLock<bool>>,
+    local_ip: String,
+    remote_ip: String,
+    ping_interval: u64,
+) {
+    // Tun up/down check thread.
+    let tun_up_clone = Arc::clone(&tun_up);
+    let tun_check_thread_handle = thread::spawn(move || {
+        loop {
+            if !check_if_tun_up(&tun_up_clone) {
+                break;
+            }
+            thread::sleep(time::Duration::from_secs(1));
+        }
+        // Quit CNDP.
+        let cne = CneInstance::get_instance();
+        // Cleanup CNE.
+        let ret = cne.cleanup();
+        if let Err(e) = ret {
+            log::error!("{}", e.to_string());
+        }
+        log::info!("Exit Tun check thread");
+    });
+
+    // Send/Recv packets thread.
+    let tun_up_clone = Arc::clone(&tun_up);
+    let app_send_recv_thread_handle = thread::spawn(move || {
+        // Ping interval.
+        let duration = time::Duration::from_millis(ping_interval);
+        let mut seq = 0;
+        let id = std::process::id() as u16;
+        let mut icmp_echo_request_pkts_sent = 0;
+        // Send initial few packets causing handshake.
+        let mut icmp_echo_reply_pkts_recvd = 0;
+        let mut total_rtt = 0.0;
+        let mut last_echo_req_sent_time = time::Instant::now();
+        let mut is_first_echo_req_packet = true;
+        loop {
+            if !check_if_tun_up(&tun_up_clone) {
+                break;
+            }
+            // Send Echo request packet after delay.
+            let delay = last_echo_req_sent_time.elapsed();
+            if delay > duration || is_first_echo_req_packet {
+                let src = local_ip.parse().unwrap();
+                let dst = remote_ip.parse().unwrap();
+                let packet = make_ipv4_icmp_echo_req_packet(src, dst, seq, id);
+                log::debug!("Send echo request packet of length = {}", packet.len());
+                match tun_app_writer.write(packet) {
+                    Ok(_) => {
+                        log::info!(
+                            "Sent ICMP echo request {} -> {} (seq={:?}, id={:?}) at time {}",
+                            src,
+                            dst,
+                            seq,
+                            id,
+                            time::SystemTime::now()
+                                .duration_since(time::UNIX_EPOCH)
+                                .unwrap()
+                                .as_micros()
+                        );
+                        last_echo_req_sent_time = time::Instant::now();
+                        icmp_echo_request_pkts_sent += 1;
+                        seq += 1;
+                        is_first_echo_req_packet = false;
+                    }
+                    Err(tun_channel::TunChannelAppError::BufferFull) => {}
+                    Err(_) => {
+                        log::info!("Tun App Write failed. Terminating app send/recv thread.");
+                        break;
+                    }
+                }
+            }
+            // Recv packets.
+            match tun_app_reader.read_timeout(duration) {
+                Ok(packet) => {
+                    log::debug!("Received app packet of length = {}", packet.len());
+                    let header = Ipv4Packet::new(&packet);
+                    handle_ipv4_icmp_packet(
+                        &tun_app_writer,
+                        &header,
+                        &mut icmp_echo_reply_pkts_recvd,
+                        &mut total_rtt,
+                    );
+                }
+                Err(tun_channel::TunChannelAppError::Timeout) => {
+                    log::debug!("Tun app read timeout.");
+                    continue;
+                }
+                Err(_) => {
+                    log::debug!("Tun app read failed. Terminating app send/recv thread.");
+                    break;
+                }
+            }
+        }
+        log::info!(
+            "icmp_echo_request_pkts_sent = {}",
+            icmp_echo_request_pkts_sent
+        );
+        log::info!(
+            "icmp_echo_reply_pkts_recvd = {}",
+            icmp_echo_reply_pkts_recvd
+        );
+    });
+    // Wait for thread to stop.
+    app_send_recv_thread_handle.join().unwrap();
+    // Wait for Tun check thread to quit.
+    tun_check_thread_handle.join().unwrap();
+}
+
+fn test_ping_send_recv_different_thread(
+    tun_app_reader: tun_channel::TunChannelAppReader,
+    tun_app_writer: tun_channel::TunChannelAppWriter,
+    tun_up: Arc<RwLock<bool>>,
+    local_ip: String,
+    remote_ip: String,
+    ping_interval: u64,
+) {
+    let total_packets = Arc::new(Mutex::new(0usize));
+    let icmp_echo_request_pkts_sent = total_packets.clone();
+    let tun_app_writer_recv_thread = tun_app_writer.clone();
+
+    // Tun up/down check thread.
+    let tun_up_clone = Arc::clone(&tun_up);
+    let tun_check_thread_handle = thread::spawn(move || {
+        loop {
+            if !check_if_tun_up(&tun_up_clone) {
+                break;
+            }
+            thread::sleep(time::Duration::from_secs(1));
+        }
+        // Quit CNDP.
+        let cne = CneInstance::get_instance();
+        // Cleanup CNE.
+        let ret = cne.cleanup();
+        if let Err(e) = ret {
+            log::error!("{}", e.to_string());
+        }
+        log::info!("Exit Tun check thread");
+    });
+
+    // Send packets thread.
+    let tun_up_clone = Arc::clone(&tun_up);
+    let app_send_thread_handle = thread::spawn(move || {
+        // Ping send interval.
+        let duration = time::Duration::from_millis(ping_interval);
+        let mut seq = 0;
+        let id = std::process::id() as u16;
+        loop {
+            if !check_if_tun_up(&tun_up_clone) {
+                break;
+            }
+            let src = local_ip.parse().unwrap();
+            let dst = remote_ip.parse().unwrap();
+            let packet = make_ipv4_icmp_echo_req_packet(src, dst, seq, id);
+            log::debug!("Send echo request packet of length = {}", packet.len());
+            match tun_app_writer.write(packet) {
+                Ok(_) => {
+                    log::info!(
+                        "Sent ICMP echo request {} -> {} (seq={:?}, id={:?}) at time {}",
+                        src,
+                        dst,
+                        seq,
+                        id,
+                        time::SystemTime::now()
+                            .duration_since(std::time::UNIX_EPOCH)
+                            .unwrap()
+                            .as_micros(),
+                    );
+                    let mut icmp_echo_request_pkts_sent =
+                        icmp_echo_request_pkts_sent.lock().unwrap();
+                    *icmp_echo_request_pkts_sent += 1;
+                    seq += 1;
+                }
+                Err(tun_channel::TunChannelAppError::BufferFull) => {}
+                Err(_) => {
+                    log::debug!("Tun app write failed. Terminating app send thread.");
+                    break;
+                }
+            }
+            thread::sleep(duration);
+        }
+        let icmp_echo_request_pkts_sent = icmp_echo_request_pkts_sent.lock().unwrap();
+        log::info!(
+            "icmp_echo_request_pkts_sent = {}",
+            *icmp_echo_request_pkts_sent
+        );
+    });
+
+    // Receive packets thread.
+    let tun_up_clone = Arc::clone(&tun_up);
+    let app_recv_thread_handle = thread::spawn(move || {
+        let mut icmp_echo_reply_pkts_recvd = 0;
+        let mut total_rtt = 0.0;
+        //let total_packets_sent = { *total_packets.lock().unwrap() };
+        let timeout = time::Duration::from_micros(20);
+        loop {
+            if !check_if_tun_up(&tun_up_clone) {
+                break;
+            }
+            match tun_app_reader.read_timeout(timeout) {
+                Ok(packet) => {
+                    log::debug!("Received app packet of length = {}", packet.len());
+                    let header = Ipv4Packet::new(&packet);
+                    handle_ipv4_icmp_packet(
+                        &tun_app_writer_recv_thread,
+                        &header,
+                        &mut icmp_echo_reply_pkts_recvd,
+                        &mut total_rtt,
+                    );
+                }
+                Err(tun_channel::TunChannelAppError::Timeout) => {
+                    continue;
+                }
+                Err(_) => {
+                    log::debug!("Tun app read failed. Terminating app recv thread.");
+                    break;
+                }
+            }
+        }
+        log::info!(
+            "icmp_echo_reply_pkts_recvd = {}",
+            icmp_echo_reply_pkts_recvd
+        );
+    });
+    // Wait for send/recv thread to quit.
+    app_send_thread_handle.join().unwrap();
+    app_recv_thread_handle.join().unwrap();
+    // Wait for Tun check thread to quit.
+    tun_check_thread_handle.join().unwrap();
+}
+
+fn check_if_tun_up(tun_up: &Arc<RwLock<bool>>) -> bool {
+    let tun_up = tun_up.read().unwrap();
+    *tun_up
+}
+
+const ICMP_PAYLOAD_SIZE: usize = 16;
+const IPV4_HEADER_LEN: usize = 20;
+
+enum IcmpPacketType<'a> {
+    EchoRep(EchoReplyPacket<'a>),
+    EchoReq(EchoRequestPacket<'a>),
+}
+
+fn make_ipv4_icmp_echo_req_packet(src: IpAddr, dst: IpAddr, seq: u16, id: u16) -> Vec<u8> {
+    // Create echo request packet.
+    let size = EchoRequestPacket::minimum_packet_size() + ICMP_PAYLOAD_SIZE;
+    let mut p: Vec<u8> = vec![0; size];
+    let mut echo_req = MutableEchoRequestPacket::new(&mut p).unwrap();
+    echo_req.set_sequence_number(seq);
+    echo_req.set_identifier(id);
+    echo_req.set_icmp_type(IcmpTypes::EchoRequest);
+    echo_req.set_icmp_code(IcmpCode::new(0));
+    // Set payload to current time.
+    let curr_time = time::SystemTime::now()
+        .duration_since(time::UNIX_EPOCH)
+        .unwrap()
+        .as_micros();
+    let arr = unsafe { mem::transmute::<u128, [u8; ICMP_PAYLOAD_SIZE]>(curr_time) };
+    echo_req.set_payload(&arr);
+    // Set checksum.
+    let checksum = checksum(&IcmpPacket::new(echo_req.packet()).unwrap());
+    echo_req.set_checksum(checksum);
+
+    // Create "IP packet".
+    let length = size + MutableIpv4Packet::minimum_packet_size();
+    let mut msg = vec![0; length];
+    match dst {
+        IpAddr::V4(dst) => {
+            let mut packet = MutableIpv4Packet::new(&mut msg[..]).unwrap();
+            packet.set_destination(dst);
+            packet.set_header_length((IPV4_HEADER_LEN / 4) as u8);
+            packet.set_total_length(length.try_into().expect("length IPv4 packet exceeded max"));
+            packet.set_source(if let IpAddr::V4(src) = src {
+                src
+            } else {
+                panic!("src.version != dst.version")
+            });
+            packet.set_version(4);
+            packet.set_ttl(64);
+            packet.set_next_level_protocol(IpNextHeaderProtocols::Icmp);
+            packet.set_payload(&p);
+            let checksum = ipv4::checksum(&packet.to_immutable());
+            packet.set_checksum(checksum);
+        }
+        IpAddr::V6(_) => {
+            log::debug!("Ipv6 Not Supported");
+        }
+    }
+    msg
+}
+
+fn make_ipv4_icmp_echo_reply_packet(
+    src: IpAddr,
+    dst: IpAddr,
+    seq: u16,
+    id: u16,
+    payload: &[u8],
+) -> Vec<u8> {
+    // Create echo reply packet.
+    let size = EchoReplyPacket::minimum_packet_size() + payload.len();
+    let mut p: Vec<u8> = vec![0; size];
+    let mut echo_reply = MutableEchoReplyPacket::new(&mut p).unwrap();
+    echo_reply.set_sequence_number(seq);
+    echo_reply.set_identifier(id);
+    echo_reply.set_icmp_type(IcmpTypes::EchoReply);
+    echo_reply.set_icmp_code(IcmpCode::new(0));
+    echo_reply.set_payload(payload);
+    let checksum = checksum(&IcmpPacket::new(echo_reply.packet()).unwrap());
+    echo_reply.set_checksum(checksum);
+
+    // Create "IP packet".
+    let length = size + MutableIpv4Packet::minimum_packet_size();
+    let mut msg = vec![0; length];
+    match dst {
+        IpAddr::V4(dst) => {
+            let mut packet = MutableIpv4Packet::new(&mut msg[..]).unwrap();
+            packet.set_destination(dst);
+            packet.set_header_length((IPV4_HEADER_LEN / 4) as u8);
+            packet.set_total_length(length.try_into().expect("length IPv4 packet exceeded max"));
+            packet.set_source(if let IpAddr::V4(src) = src {
+                src
+            } else {
+                panic!("ip src version != ip dst version")
+            });
+            packet.set_version(4);
+            packet.set_ttl(64);
+            packet.set_next_level_protocol(IpNextHeaderProtocols::Icmp);
+            packet.set_payload(&p);
+            let checksum = ipv4::checksum(&packet.to_immutable());
+            packet.set_checksum(checksum);
+        }
+        IpAddr::V6(_) => {
+            log::debug!("Ipv6 Not Supported");
+        }
+    }
+    msg
+}
+
+fn handle_ipv4_icmp_packet<'a>(
+    tun_app_writer: &tun_channel::TunChannelAppWriter,
+    header: &'a Option<Ipv4Packet>,
+    icmp_echo_reply_pkts_recvd: &mut usize,
+    total_rtt: &mut f64,
+) {
+    if let Some(header) = header {
+        let source = IpAddr::V4(header.get_source());
+        let destination = IpAddr::V4(header.get_destination());
+        let protocol = header.get_next_level_protocol();
+        if protocol == IpNextHeaderProtocols::Icmp {
+            let icmp_packet = handle_icmp_packet(source, destination, header.payload());
+            if let Some(icmp_packet) = icmp_packet {
+                match icmp_packet {
+                    IcmpPacketType::EchoRep(echo_reply_packet) => {
+                        let payload = echo_reply_packet.payload();
+                        if payload.len() < ICMP_PAYLOAD_SIZE {
+                            log::info!(
+                                "Recv ICMP echo reply   {} -> {} (seq={:?}, id={:?}, unknown ICMP payload)",
+                                source,
+                                destination,
+                                echo_reply_packet.get_sequence_number(),
+                                echo_reply_packet.get_identifier(),
+                            );
+                            return;
+                        }
+                        // Retrieve packet sent time from payload.
+                        let send_time = unsafe {
+                            let num = 0u128;
+                            let mut arr = mem::transmute::<u128, [u8; ICMP_PAYLOAD_SIZE]>(num);
+                            arr.copy_from_slice(payload);
+                            mem::transmute::<[u8; ICMP_PAYLOAD_SIZE], u128>(arr)
+                        };
+                        let curr_time = time::SystemTime::now()
+                            .duration_since(time::UNIX_EPOCH)
+                            .unwrap()
+                            .as_micros();
+                        let elapsed_micro_sec = curr_time - send_time;
+                        let elapsed_ms = elapsed_micro_sec as f64 / 1000 as f64;
+                        *icmp_echo_reply_pkts_recvd += 1;
+                        let mut avg_rtt = 0.0;
+                        // Ignore initial few packets for average rtt calculation as delay is high
+                        // for initial few packets since initial handshake with peer takes time.
+                        let initial_packets_ignore = 25;
+                        if *icmp_echo_reply_pkts_recvd > initial_packets_ignore {
+                            *total_rtt += elapsed_ms;
+                            avg_rtt = *total_rtt as f64
+                                / (*icmp_echo_reply_pkts_recvd - initial_packets_ignore) as f64;
+                        }
+                        log::info!(
+                            "Recv ICMP echo reply   {} -> {} (seq={:?}, id={:?}, elapsed_ms={} ms, avg rtt={:.3} ms)",
+                            source,
+                            destination,
+                            echo_reply_packet.get_sequence_number(),
+                            echo_reply_packet.get_identifier(),
+                            elapsed_ms,
+                            avg_rtt,
+                        );
+                        log::info!("Recv ICMP echo reply at time {}", curr_time);
+                    }
+                    IcmpPacketType::EchoReq(echo_request_packet) => {
+                        let seq = echo_request_packet.get_sequence_number();
+                        let id = echo_request_packet.get_identifier();
+                        let payload = echo_request_packet.payload();
+                        log::info!(
+                            "Recv ICMP echo request {} -> {} (seq={:?}, id={:?})",
+                            source,
+                            destination,
+                            seq,
+                            id
+                        );
+                        // Send Echo Reply to source.
+                        let packet =
+                            make_ipv4_icmp_echo_reply_packet(destination, source, seq, id, payload);
+                        log::debug!("Send echo reply packet of length = {}", packet.len());
+                        match tun_app_writer.write(packet) {
+                            Ok(_) => {
+                                log::info!(
+                                    "Sent ICMP echo reply   {} -> {} (seq={:?}, id={:?}) at time {}",
+                                    destination,
+                                    source,
+                                    seq,
+                                    id,
+                                    time::SystemTime::now()
+                                        .duration_since(time::UNIX_EPOCH)
+                                        .unwrap()
+                                        .as_micros()
+                                );
+                            }
+                            Err(tun_channel::TunChannelAppError::BufferFull) => {}
+                            Err(_) => {
+                                log::debug!("Write echo reply packet failed.");
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
+
+fn handle_icmp_packet<'a>(
+    source: IpAddr,
+    destination: IpAddr,
+    packet: &'a [u8],
+) -> Option<IcmpPacketType<'a>> {
+    let icmp_packet = IcmpPacket::new(packet);
+    if let Some(icmp_packet) = icmp_packet {
+        match icmp_packet.get_icmp_type() {
+            IcmpTypes::EchoReply => {
+                let echo_reply_packet = EchoReplyPacket::new(packet).unwrap();
+                return Some(IcmpPacketType::EchoRep(echo_reply_packet));
+            }
+            IcmpTypes::EchoRequest => {
+                let echo_request_packet = EchoRequestPacket::new(packet).unwrap();
+                return Some(IcmpPacketType::EchoReq(echo_request_packet));
+            }
+            _ => {
+                log::debug!(
+                    "ICMP packet {} -> {} (type={:?})",
+                    source,
+                    destination,
+                    icmp_packet.get_icmp_type()
+                );
+                return None;
+            }
+        }
+    } else {
+        log::debug!("Malformed ICMP Packet");
+    }
+    return None;
+}
diff --git a/src/platform/dummy/udp.rs b/src/platform/dummy/udp.rs
index 88630af..316e384 100644
--- a/src/platform/dummy/udp.rs
+++ b/src/platform/dummy/udp.rs
@@ -46,7 +46,7 @@ pub struct VoidBind {}
 impl Reader<UnitEndpoint> for VoidBind {
     type Error = BindError;
 
-    fn read(&self, _buf: &mut [u8]) -> Result<(usize, UnitEndpoint), Self::Error> {
+    fn read(&mut self, _buf: &mut [u8]) -> Result<(usize, UnitEndpoint), Self::Error> {
         Ok((0, UnitEndpoint {}))
     }
 }
@@ -54,7 +54,7 @@ impl Reader<UnitEndpoint> for VoidBind {
 impl Writer<UnitEndpoint> for VoidBind {
     type Error = BindError;
 
-    fn write(&self, _buf: &[u8], _dst: &mut UnitEndpoint) -> Result<(), Self::Error> {
+    fn write(&self, _buf:Vec<u8>, _dst: &mut UnitEndpoint) -> Result<(), Self::Error> {
         Ok(())
     }
 }
@@ -84,7 +84,7 @@ pub struct PairReader<E> {
 
 impl Reader<UnitEndpoint> for PairReader<UnitEndpoint> {
     type Error = BindError;
-    fn read(&self, buf: &mut [u8]) -> Result<(usize, UnitEndpoint), Self::Error> {
+    fn read(&mut self, buf: &mut [u8]) -> Result<(usize, UnitEndpoint), Self::Error> {
         let vec = self
             .recv
             .lock()
@@ -105,12 +105,12 @@ impl Reader<UnitEndpoint> for PairReader<UnitEndpoint> {
 
 impl Writer<UnitEndpoint> for PairWriter<UnitEndpoint> {
     type Error = BindError;
-    fn write(&self, buf: &[u8], _dst: &mut UnitEndpoint) -> Result<(), Self::Error> {
+    fn write(&self, buf: Vec<u8>, _dst: &mut UnitEndpoint) -> Result<(), Self::Error> {
         debug!(
             "dummy({}): write ({}, {})",
             self.id,
             buf.len(),
-            hex::encode(buf)
+            hex::encode(&buf)
         );
         let owned = buf.to_owned();
         match self.send.lock().unwrap().send(owned) {
diff --git a/src/platform/linux/cndp/README.md b/src/platform/linux/cndp/README.md
new file mode 100644
index 0000000..f390b63
--- /dev/null
+++ b/src/platform/linux/cndp/README.md
@@ -0,0 +1,67 @@
+# Wireguard using CNDP (Cloud Native Data Plane) .
+
+## Overview
+
+Wireguard uses CNDP/AF-XDP to send and receive packets from/to user space. Wireguard with CNDP will run on Linux platform.
+
+Cloud Native Data Plane (CNDP) provides a set of User-space libraries for accelerating packet processing for cloud applications.  It aims to accomplish better performance (N Times faster) than that of Linux standard network interfaces by taking advantage of Intel technologies and features (e.g. AVX 512, DSA, CLDEMOTE…). The first version of the library is built upon AF_XDP, an interface that delivers packets straight to User-space bypassing the Linux Kernel Networking stack.
+
+## Usage (Linux)
+
+### Building
+
+Wireguard with CNDP is most recently tested on Ubuntu 21.04, 5.11.0-18-generic kernel. It is expected to work on other ubuntu and kernel versions which is supported by CNDP.
+
+To build wireguard-rs with CNDP on Linux:
+
+1. Obtain nightly `cargo` and `rustc` through [rustup](https://rustup.rs/). Need cargo version >= 1.63.0
+2. Clone the repository: `git clone https://github.com/intel-innersource/networking.dataplane.cndp.thirdparty.wireguard-rs.git`.
+3. Use cndp branch - `git checkout cndp-release`
+4. Run `cargo build --release` from inside the `wireguard-rs` directory.
+
+### Wireguard CNDP helper script
+
+Helper script [cndprustwg.sh](./cndprustwg.sh)  is provided to start wireguard user space application using CNDP. Update the following variables in the script as per the required configuration and then run the script in both endpoints (local and remote).
+
+1. WG_ROOT - Wireguard CNDP root folder (absolute path)
+2. PRIVATE_KEY - Private key file (absolute path).
+3. WG_LOCAL_IP - Wireguard interface local IP.
+4. WG_LOCAL_LISTEN_PORT - Wireguard interface local IP.
+5. WG_PEER_IP - Wireguard interface peer IP.
+6. WG_PEER_LISTEN_PORT - Peer listen port.
+7. WG_PEER_ENDPOINT_IP - Peer endpoint IP.
+8. WG_PEER_PUBLIC_KEY - Peer public key (base64 encoded)
+
+### Configure ethtool filter
+
+Before running the script, configure an ethtool filter to steer packets to a specific queue. This should be done for both local and remote Wireguard endpoints.
+
+`sudo ethool -N <devname> flow-type udp4 src-ip <src ip> dst-ip <dst ip> action <qid>`
+
+Here src-ip and dst-ip corresponds to local and remote peer endpoint IP. We could create separate rules for sending and receiving packets. For example, below rules are for sending and receiving UDP packets.
+
+`sudo ethtool -N enp134s0f0 flow-type udp4 src-ip 48.0.0.155 dst-ip 48.0.0.154 action 23`
+
+`sudo ethtool -N enp134s0f0 flow-type udp4 src-ip 48.0.0.154 dst-ip 48.0.0.155 action 33`
+
+### Update CNDP JSON configuration file
+
+Edit the example JSON file [fwd.jsonc](./fwd.jsonc) or [cndp_pkt_fwd.jsonc](./cndp_pkt_fwd.jsonc) configuration file.  Make sure the "lports" section has the same netdev name and queue id for which the ethtool filter is configured. Make sure the "threads" section has the correct "lports" configured. JSON file contains the netdev configuration of the n/w interface used by wireguard to send/receive packets from/to from remote endpoint.
+
+### Update WG CNDP toml file
+
+Edit [wg_cndp.toml](./wg_cndp.toml) toml file. Set "jsonc" to absolute path of CNDP JSON configuration file. Other parameters are optional. See the toml file comments for description of these parameters.
+
+### Run the helper script
+
+The helper script is used to configure and stat wireguard interface. This script should be run on both endpoints (this could be two different systems).
+
+**Usage**: `cndprustwg.sh [debug|release] [cndp-packet|cndp-ping|wireguard-rs]`
+
+There are 3 executables use by the script. By default, script will run in *release* mode and uses *wireguard-rs* executable.
+
+1. wireguard-rs - This is the default executable which uses Linux Kernel TUN for data path to send and receive network packets.
+2. cndp-ping - Custom ping application developed on top of Wireguard and CNDP stack which sends and receives ICMP request/reply packets.
+3. cndp-packet - Custom application developed on top of Wireguard and CNDP stack which sends and receives network(tcp/udp) packets. This executable uses [DPDK pktgen application](https://pktgen-dpdk.readthedocs.io/en/latest/) to send and receive packets to/from a n/w interface. Sample pktgen configuration files are located in directory [pktgen_cfg](./pktgen_cfg). The mac address of the n/w interface should be configured in the variable "TRAFFIC_GEN_MAC" in the script [cndprustwg.sh](./cndprustwg.sh).  [cndp_pkt_fwd.jsonc](./cndp_pkt_fwd.jsonc) configuration file should be updated with the netdev corresponding to the n/w interface used by pktgen application.
+
+Running this script will create an interface `rsuwg0`, configure it based on the settings provided in the script and fork into the background. To remove the interface, use  `sudo ip link del rsuwg0`, or if your system does not support removing interfaces directly, you may instead remove the control socket via `rm -f /var/run/wireguard/rsuwg0.sock`, which will result in wireguard-rs shutting down.
diff --git a/src/platform/linux/cndp/cndp_error.rs b/src/platform/linux/cndp/cndp_error.rs
new file mode 100644
index 0000000..17292c2
--- /dev/null
+++ b/src/platform/linux/cndp/cndp_error.rs
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+
+use std::error::Error;
+use std::fmt;
+
+#[derive(Debug)]
+pub enum CndpError {
+    Disconnected,
+    BindJsonError,
+    CneInitializeError,
+    ReaderError,
+    WriterError,
+}
+
+impl Error for CndpError {
+    fn description(&self) -> &str {
+        "Generic Bind Error"
+    }
+
+    fn source(&self) -> Option<&(dyn Error + 'static)> {
+        None
+    }
+}
+
+impl fmt::Display for CndpError {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        match self {
+            CndpError::Disconnected => write!(f, "Cndp disconnected"),
+            CndpError::BindJsonError => write!(f, "Cndp bind json error"),
+            CndpError::CneInitializeError => write!(f, "Cndp initialize error"),
+            CndpError::ReaderError => write!(f, "Cndp reader error"),
+            CndpError::WriterError => write!(f, "Cndp writer error"),
+        }
+    }
+}
diff --git a/src/platform/linux/cndp/cndp_pkt_fwd.jsonc b/src/platform/linux/cndp/cndp_pkt_fwd.jsonc
new file mode 100644
index 0000000..b3f88f8
--- /dev/null
+++ b/src/platform/linux/cndp/cndp_pkt_fwd.jsonc
@@ -0,0 +1,187 @@
+{
+    // (R) - Required entry
+    // (O) - Optional entry
+    // All descriptions are optional and short form is 'desc'
+    // The order of the entries in this file are handled when it is parsed and the
+    // entries can be in any order.
+
+    // (R) Application information
+    //    name        - (O) the name of the application
+    //    description - (O) the description of the application
+    "application": {
+        "name": "pktfwd",
+        "description": "A simple packet forwarder"
+    },
+
+    // (O) Default values
+    //    bufcnt - (O) UMEM default buffer count in 1K increments
+    //    bufsz  - (O) UMEM buffer size in 1K increments
+    //    rxdesc - (O) Number of RX ring descriptors in 1K increments
+    //    txdesc - (O) Number of TX ring descriptors in 1K increments
+    //    cache  - (O) MBUF Pool cache size in number of entries
+    //    mtype  - (O) Memory type for mmap allocations
+    "defaults": {
+        "bufcnt": 16,
+        "bufsz": 2,
+        "rxdesc": 2,
+        "txdesc": 2,
+        "cache": 256,
+        "mtype": "2MB"
+    },
+
+    // List of all UMEM's to be created
+    // key/val - (R) The 'key' is the name of the umem for later reference.
+    //               The 'val' is the object describing the UMEM buffer.
+    //               Multiple umem regions can be defined.
+    // A UMEM can support multiple lports using the regions array. Each lports can use
+    // one of the regions.
+    //    bufcnt  - (R) The number of buffers in 1K increments in the UMEM space.
+    //    bufsz   - (R) The size in 1K increments of each buffer in the UMEM space.
+    //    mtype   - (O) If missing or empty string or missing means use 4KB or default system pages.
+    //    regions - (O) Array of sizes one per region in 1K increments, total must be <= bufcnt
+    //    rxdesc  - (O) Number of RX descriptors to be allocated in 1K increments,
+    //                  if not present or zero use defaults.rxdesc, normally zero.
+    //    txdesc  - (O) Number of TX descriptors to be allocated in 1K increments,
+    //                  if not present or zero use defaults.txdesc, normally zero.
+    //    description | desc - (O) Description of the umem space.
+    "umems": {
+        "umem0": {
+            "bufcnt": 64,
+            "bufsz": 2,
+            "mtype": "2MB",
+            "regions": [
+                16,
+                16,
+                16,
+                16
+            ],
+            "rxdesc": 0,
+            "txdesc": 0,
+            "description": "UMEM Description 0"
+        }
+    },
+
+
+    // List of all lports to be used in the application
+    // An lport is defined by a netdev/queue ID pair, which is a socket containing a Rx/Tx ring pair.
+    // Each queue ID is assigned to a single socket or a socket is the lport defined by netdev/qid.
+    // Note: A netdev can be shared between lports as the qid is unique per lport
+    //       If netdev is not defined or empty then it must be a virtual interface and not
+    //       associated with a netdev/queue ID.
+    // key/val - (R) The 'key' is the logical name e.g. 'eth0:0', 'eth1:0', ... to be used by the
+    //               application to reference an lport. The 'val' object contains information about
+    //               each lport.
+    //    netdev        - (R) The netdev device to be used, the part before the colon
+    //                     must reflect the netdev name
+    //    pmd           - (R) All PMDs have a name i.e. 'net_af_xdp', 'ring', ...
+    //    qid           - (R) Is the queue id to use for this lport, defined by ethtool command line
+    //    umem          - (R) The UMEM assigned to this lport
+    //    region        - (O) UMEM region index value, default region 0
+    //    busy_poll     - (O) Enable busy polling support, true or false, default false
+    //    busy_timeout  - (O) 1-65535 or 0 - use default value, values in milliseconds
+    //    busy_budget   - (O) 0xFFFF disabled, 0 use default, >0 budget value
+    //    inhibit_prog_load - (O) inhibit loading the BPF program if true, default false
+    //    force_wakeup  - (O) force TX wakeup calls for CVL NIC, default false
+    //    skb_mode      - (O) Enable XDP_FLAGS_SKB_MODE when creating af_xdp socket, forces copy mode, default false
+    //    description   - (O) the description, 'desc' can be used as well
+    "lports": {
+        "enp134s0:0": {
+            "pmd": "net_af_xdp",
+            "qid": 23,
+            "umem": "umem0",
+            "busy_poll": true,
+            "region": 0,
+            "description": "LAN 0 port"
+        },
+        "enp134s0:1": {
+            "pmd": "net_af_xdp",
+            "qid": 33,
+            "umem": "umem0",
+            "busy_poll": true,
+            "region": 1,
+            "description": "LAN 1 port"
+        },
+        "enp26s0f1:0": {
+            "pmd": "net_af_xdp",
+            "qid": 12,
+            "umem": "umem0",
+            "busy_poll": true,
+            "region": 2,
+            "description": "LAN 0 port"
+        },
+        "enp26s0f1:1": {
+            "pmd": "net_af_xdp",
+            "qid": 13,
+            "umem": "umem0",
+            "busy_poll": true,
+            "region": 3,
+            "description": "LAN 1 port"
+        }
+    },
+
+    // (O) Define the lcore groups for each thread to run
+    //     Can be integers or a string for a range of lcores
+    //     e.g. [10], [10-14,16], [10-12, 14-15, 17-18, 20]
+    // Names of a lcore group and its lcores assigned to the group.
+    // The initial group is for the main thread of the application.
+    // The default group is special and is used if a thread if not assigned to a group.
+    "lcore-groups": {
+        "initial": [22],
+        "group0": [25],
+        "group1": [35],
+        "group2": [36],
+        "group3": [37],
+        "default": ["22-37"]
+    },
+
+    // (O) Set of common options application defined.
+    //     The Key can be any string and value can be boolean, string, array or integer
+    //     An array must contain only a single value type, boolean, integer, string and
+    //     can't be a nested array.
+    //   no-metrics - (O) Disable metrics gathering and thread
+    //   no-restapi - (O) Disable RestAPI support
+    //   cli        - (O) Enable/Disable CLI supported
+    //   mode       - (O) Mode type [drop | rx-only], tx-only, [lb | loopback], fwd, acl-strict, acl-permissive
+    "options": {
+        "no-metrics": false,
+        "no-restapi": false,
+        "cli": true,
+        "mode": "drop"
+    },
+
+    // List of threads to start and information for that thread. Application can start
+    // it's own threads for any reason and are not required to be configured by this file.
+    //
+    //   Key/Val   - (R) A unique thread name.
+    //                   The format is <type-string>[:<identifier>] the ':' and identifier
+    //                   are optional if all thread names are unique
+    //      group  - (O) The lcore-group this thread belongs to. The
+    //      lports - (O) The list of lports assigned to this thread and can not shared lports.
+    //      description | desc - (O) The description
+    "threads": {
+        "main": {
+            "group": "initial",
+            "description": "CLI Thread"
+        },
+        "fwd:0": {
+            "group": "group0",
+            "lports": ["enp134s0:0"],
+            "description": "Thread 0"
+        },
+        "fwd:1": {
+            "group": "group1",
+            "lports": ["enp134s0:1"],
+            "description": "Thread 1"
+        },
+        "fwd:2": {
+            "group": "group2",
+            "lports": ["enp26s0f1:0"],
+            "description": "Thread 2"
+        },
+        "fwd:3": {
+            "group": "group3",
+            "lports": ["enp26s0f1:1"],
+            "description": "Thread 3"
+        }
+    }
+}
diff --git a/src/platform/linux/cndp/cndprustwg.sh b/src/platform/linux/cndp/cndprustwg.sh
new file mode 100755
index 0000000..ea8f231
--- /dev/null
+++ b/src/platform/linux/cndp/cndprustwg.sh
@@ -0,0 +1,95 @@
+#!/bin/bash
+# SPDX-License-Identifier: BSD-3-Clause
+# Copyright(c) 2019-2021 Intel Corporation.
+
+# Run this script as sudo
+# Usage: ./cndprustwg.sh [debug|release] [cndp-packet|cndp-ping|wireguard-rs].
+# Wireguard CNDP Root folder
+WG_ROOT="/home/manoj/wireguard/cndp/networking.dataplane.cndp.thirdparty.wireguard-rs"
+# Build type (debug/release). Use release by default.
+BUILD=${1:-release}
+# Build type (debug/release). Use release by default.
+EXE=${2:-wireguard-rs}
+# Set private key file.
+# Private/Public key should be generated once before running this script
+# using following commands.
+# 1) Private key -> "sudo wg genkey > rsuwgprivate"
+# 2) Public key  -> "wg pubkey < rsuwgprivate > rsuwgpublic"
+PRIVATE_KEY="/home/manoj/wireguard/rsuwgprivate"
+# Wireguard MTU size.
+WG_MTU=1420
+# Wirguard interface local ip.
+WG_LOCAL_IP=10.0.4.1
+# Wireguard local listen port.
+WG_LOCAL_LISTEN_PORT=5400
+# Wirguard interface remote peer ip.
+WG_PEER_IP=10.0.4.2
+# Wireguard remote peer listen port.
+WG_PEER_LISTEN_PORT=5500
+# Wireguard remote peer endpoint ip.
+WG_PEER_ENDPOINT_IP=48.0.0.155
+# Wireguard remote peer endpoint.
+WG_PEER_ENDPOINT=$WG_PEER_ENDPOINT_IP:$WG_PEER_LISTEN_PORT
+# Peer public key (base64 encoded)
+WG_PEER_PUBLIC_KEY="DV/f0jntATrrng/D7jVmqBz6IFlHWjPT/QsmhDut5Es="
+
+# Delete existing interface
+sudo ip link del rsuwg0
+# Wait for interface to go down.
+sleep 1
+# Copy wg_cndp.toml file to target directory containing the executable.
+cp $WG_ROOT/src/platform/linux/cndp/wg_cndp.toml $WG_ROOT/target/$BUILD/wg_cndp.toml
+# Start and configure wireguard
+if [ "$BUILD" == "debug" ]; then
+	RUST_LOG_VAL=debug
+else
+	RUST_LOG_VAL=info
+fi
+# Check the binary to execute
+if [ "$EXE" == "cndp-ping" ]; then
+	RUST_EXE=cndp-ping
+	ARGS="--disable-drop-privileges --device rsuwg0 --local $WG_LOCAL_IP --remote $WG_PEER_IP --interval 1000"
+elif [ "$EXE" == "cndp-packet" ]; then
+	RUST_EXE=cndp-packet
+	TRAFFIC_GEN_MAC=3c:fd:fe:a8:5f:bc
+	MODE=${3:-send}
+	if [ "$MODE" == "send" ]; then
+		ARGS="--disable-drop-privileges --device rsuwg0 --traffic-gen-mac $TRAFFIC_GEN_MAC --send"
+	else
+		ARGS="--disable-drop-privileges --device rsuwg0 --traffic-gen-mac $TRAFFIC_GEN_MAC"
+	fi
+else
+	RUST_EXE=wireguard-rs
+	ARGS="--disable-drop-privileges rsuwg0"
+fi
+
+RUN="sudo -E LD_LIBRARY_PATH=$LD_LIBRARY_PATH LD_PRELOAD=$LD_LIBRARY_PATH/libpmd_af_xdp.so RUST_LOG=$RUST_LOG_VAL `which cargo` run --bin $RUST_EXE"
+if [ "$BUILD" == "debug" ]; then
+	$RUN -- $ARGS
+else
+	$RUN --release -- $ARGS
+fi
+# Wait for interface to come up.
+sleep 1
+
+# Set wireguard interface ip addr.
+sudo ip addr add $WG_LOCAL_IP/24 dev rsuwg0
+# Set private key in wg interface.
+sudo wg set rsuwg0 private-key $PRIVATE_KEY
+# Set MTU.
+sudo ip link set mtu $WG_MTU dev rsuwg0
+# Set listening port.
+sudo wg set rsuwg0 listen-port $WG_LOCAL_LISTEN_PORT
+# Set remote peer public key, wireguard ip, endpoint and listen port.
+if [ "$EXE" == "cndp-packet" ]; then
+	WG_PEER_IP1=10.50.0.2 # Remote IP used by packet generator.
+	ALLOWED_IPS=$WG_PEER_IP/32,$WG_PEER_IP1/32
+else
+	ALLOWED_IPS=$WG_PEER_IP/32
+fi
+sudo wg set rsuwg0 peer $WG_PEER_PUBLIC_KEY allowed-ips $ALLOWED_IPS endpoint $WG_PEER_ENDPOINT
+# Enable wireguard interface.
+sudo ip link set rsuwg0 up
+# Wait for interface to come up.
+sleep 1
+stty sane
diff --git a/src/platform/linux/cndp/endpoint.rs b/src/platform/linux/cndp/endpoint.rs
new file mode 100644
index 0000000..d5fe10e
--- /dev/null
+++ b/src/platform/linux/cndp/endpoint.rs
@@ -0,0 +1,43 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+
+use pnet::datalink::MacAddr;
+use std::net::IpAddr;
+use std::net::SocketAddr;
+
+use super::super::super::Endpoint;
+
+#[derive(Debug, Clone, Copy)]
+pub struct CndpEndpoint {
+    pub ip: Option<IpAddr>,
+    pub port: Option<u16>,
+    pub mac: Option<MacAddr>,
+}
+
+impl Endpoint for CndpEndpoint {
+    fn from_address(sock_addr: SocketAddr) -> CndpEndpoint {
+        CndpEndpoint {
+            ip: Some(sock_addr.ip()),
+            port: Some(sock_addr.port()),
+            mac: None,
+        }
+    }
+
+    fn into_address(&self) -> SocketAddr {
+        SocketAddr::new(self.ip.unwrap(), self.port.unwrap())
+    }
+
+    fn clear_src(&mut self) {
+    }
+}
+
+impl CndpEndpoint {
+    pub fn new(ip: Option<IpAddr>, port: Option<u16>, mac: Option<MacAddr>) -> CndpEndpoint {
+        CndpEndpoint {
+            ip: ip,
+            port: port,
+            mac: mac,
+        }
+    }
+}
diff --git a/src/platform/linux/cndp/eth_packet_rw.rs b/src/platform/linux/cndp/eth_packet_rw.rs
new file mode 100644
index 0000000..a2e22d5
--- /dev/null
+++ b/src/platform/linux/cndp/eth_packet_rw.rs
@@ -0,0 +1,867 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+
+use hjul::{Runner, Timer};
+use pnet::datalink::MacAddr;
+use std::collections::HashSet;
+use std::error::Error;
+use std::fs;
+use std::net::IpAddr;
+use std::ops::Deref;
+use std::slice;
+use std::sync::mpsc::{sync_channel, Receiver, RecvTimeoutError, SyncSender};
+use std::sync::{Arc, RwLock};
+use std::thread;
+use std::time::Duration;
+use std::time::SystemTime;
+use toml::map::Map;
+use toml::Value;
+
+use super::super::super::endpoint::Endpoint;
+use super::endpoint::CndpEndpoint;
+
+use super::cndp_error::CndpError;
+use super::packet::*;
+
+use cne::instance::CneInstance;
+use cne::packet::Packet;
+use cne::packet::PacketInterface;
+use cne::port::Port;
+
+pub trait Reader<E: Endpoint>: Send + Sync {
+    type Error: Error;
+
+    fn read(&mut self, buf: &mut [u8]) -> Result<(usize, E), Self::Error>;
+}
+
+pub trait Writer<E: Endpoint>: Send + Sync + 'static {
+    type Error: Error;
+
+    fn write(&self, buf: Vec<u8>, dst: &mut E) -> Result<(), Self::Error>;
+}
+
+pub trait PacketReadWrite: Send + Sync + 'static {
+    type Error: Error;
+    type Endpoint: Endpoint;
+
+    /* Until Rust gets type equality constraints these have to be generic */
+    type Writer: Writer<Self::Endpoint>;
+    type Reader: Reader<Self::Endpoint>;
+}
+
+pub trait Owner: Send {
+    type Error: Error;
+}
+
+pub trait PlatformPacketReadWrite: PacketReadWrite {
+    type Owner: Owner;
+
+    /// Bind returning the reader/writer and
+    /// an associated instance of the owner type, which closes upon "drop"
+    #[allow(clippy::type_complexity)]
+    fn bind() -> Result<(Self::Reader, Self::Writer, Self::Owner), Self::Error>;
+}
+
+// CNDP Packet Json Data
+pub struct CndpPacketJsonData {
+    pub iface_name: Option<String>,
+    pub endpoint: Option<CndpEndpoint>,
+    pub lport_reader: Port,
+    pub lport_writer: Port,
+    pub reader_core_id: Option<usize>,
+    pub writer_core_id: Option<usize>,
+    pub writer_sender_channel_core_id: Option<usize>,
+}
+
+// CNDP Packet Bind
+pub struct CndpPacketReader {
+    pub iface_name: Option<String>,
+    endpoint: Option<CndpEndpoint>,
+    quit: Arc<RwLock<bool>>,
+    lport: Port,
+    rx_pkts: Vec<Packet>,
+    core_id: Option<usize>,
+    cne_uids: RwLock<HashSet<i32>>,
+    cur_pkt_index: i32,
+    last_num_pkts_read: u16,
+}
+
+pub struct CndpPacketBufferedWriterInner {
+    pub iface_name: Option<String>,
+    endpoint: Option<CndpEndpoint>,
+    quit: Arc<RwLock<bool>>,
+    lport: Port,
+    core_id: Option<usize>,
+    cne_uids: RwLock<HashSet<i32>>,
+    pkts: RwLock<Vec<PacketSendData>>,
+    runner: Runner,
+    timer: RwLock<Option<Timer>>,
+}
+
+pub struct CndpPacketBufferedWriter {
+    inner: Arc<CndpPacketBufferedWriterInner>,
+}
+
+pub struct PacketSendData {
+    pub buf: Vec<u8>,
+    pub src_endpoint: CndpEndpoint,
+    pub dst_endpoint: CndpEndpoint,
+}
+
+pub struct CndpPacketWriterSenderChannel {
+    iface_name: Option<String>,
+    endpoint: Option<CndpEndpoint>,
+    quit: Arc<RwLock<bool>>,
+    core_id: Option<usize>,
+    cne_uids: RwLock<HashSet<i32>>,
+    sender: SyncSender<PacketSendData>,
+}
+
+pub struct CndpPacketWriterReceiverChannel {
+    quit: Arc<RwLock<bool>>,
+    lport: Port,
+    core_id: Option<usize>,
+    receiver: Receiver<PacketSendData>,
+}
+
+struct CndpPacketCommon {}
+
+#[derive(Clone)]
+pub struct CndpPacketSyncChannel {}
+
+#[derive(Clone)]
+pub struct CndpPacketBuffered {}
+
+impl PacketReadWrite for CndpPacketSyncChannel {
+    type Error = CndpError;
+    type Endpoint = CndpEndpoint;
+    type Reader = CndpPacketReader;
+    type Writer = CndpPacketWriterSenderChannel;
+}
+
+impl PacketReadWrite for CndpPacketBuffered {
+    type Error = CndpError;
+    type Endpoint = CndpEndpoint;
+    type Reader = CndpPacketReader;
+    type Writer = CndpPacketBufferedWriter;
+}
+
+impl CndpPacketCommon {
+    const READ_SLEEP_TIME_IN_MICROS: u64 = 20;
+    const READ_BURST_PKTS: u16 = 128;
+    const WRITE_THRESHOLD_NUM_PKTS: usize = 32;
+    const WRITE_WAIT_DURATION_IN_MICROS: u64 = 10;
+    const WRITE_CALLBACK_TIMER_DURATION_IN_MICROS: u64 = 100;
+}
+
+pub struct CneRegister {
+    pub cne_uid: i32,
+}
+
+impl CneRegister {
+    pub fn new(s: &str, core_id: Option<usize>) -> CneRegister {
+        let cne = CneInstance::get_instance();
+        let cne_uid = cne.register_thread(s).unwrap_or(-1);
+        if cne_uid > 0 {
+            if let Some(core_id) = core_id {
+                core_affinity::set_for_current(core_affinity::CoreId { id: core_id });
+            }
+        }
+        CneRegister { cne_uid: cne_uid }
+    }
+}
+
+impl Reader<CndpEndpoint> for CndpPacketReader {
+    type Error = CndpError;
+    fn read(&mut self, buf: &mut [u8]) -> Result<(usize, CndpEndpoint), Self::Error> {
+        // If this function is called from a Wireguard Rust thread register it with CNDP.
+        let register = CneRegister::new("CndpPacketReader", self.core_id);
+        if register.cne_uid > 0 {
+            let mut cne_uids = self.cne_uids.write().unwrap();
+            (*cne_uids).insert(register.cne_uid);
+        }
+        // Loop till we get atleast 1 packet or thread quits.
+        loop {
+            if CndpPacketCommon::has_quit(&self.quit) {
+                log::debug!("Cndp Packet Reader quitted");
+                return Err(CndpError::Disconnected);
+            }
+            // Get lport for fwd thread.
+            let lport = self.lport.clone();
+            let (eth_payload_len, endpoint) = self.read_lport(buf, &lport);
+            if eth_payload_len > 0 {
+                return Ok((eth_payload_len, endpoint));
+            } else {
+                // If there are no packets then sleep for sometime.
+                // This will reduce CPU utilization instead of reading in tight loop
+                // and keeping CPU busy at 100%.
+                if self.last_num_pkts_read == 0 {
+                    thread::sleep(Duration::from_micros(
+                        CndpPacketCommon::READ_SLEEP_TIME_IN_MICROS,
+                    ));
+                }
+            }
+        }
+    }
+}
+
+impl CndpPacketReader {
+    fn read_lport(&mut self, buf: &mut [u8], lport: &Port) -> (usize, CndpEndpoint) {
+        if self.last_num_pkts_read == 0 {
+            // Get burst of RX packets.
+            let rx_pkts = &mut self.rx_pkts;
+            self.last_num_pkts_read =
+                match lport.rx_burst(&mut rx_pkts[..CndpPacketCommon::READ_BURST_PKTS as usize]) {
+                    Ok(pkts_read) => pkts_read,
+                    Err(e) => {
+                        log::error!("Error reading UDP packets : {}", e.to_string());
+                        0
+                    }
+                };
+            if self.last_num_pkts_read > 0 {
+                self.cur_pkt_index = 0;
+                log::debug!(
+                    "Read bulk {} UDP Packets at time {}",
+                    self.last_num_pkts_read,
+                    SystemTime::now()
+                        .duration_since(std::time::UNIX_EPOCH)
+                        .unwrap()
+                        .as_micros()
+                );
+            }
+        }
+
+        // Process RX packet.
+        if self.last_num_pkts_read > 0 {
+            // Get a single RX pktmbuf.
+            let rx_pkts = &mut self.rx_pkts;
+            let pkt = &rx_pkts[self.cur_pkt_index as usize];
+            self.cur_pkt_index = self.cur_pkt_index + 1;
+            // Parse pktmbuf to get eth payload, length and endpoint.
+            let (eth_payload_len, endpoint) = CndpPacketCommon::parse_packet(buf, &pkt);
+            // If all packets are processed free them.
+            if self.cur_pkt_index == self.last_num_pkts_read as i32 {
+                // Free RX buffers.
+                let ret =
+                    Packet::free_packet_buffer(&mut rx_pkts[..self.last_num_pkts_read as usize]);
+                if let Err(e) = ret {
+                    log::error!("{}", e.to_string());
+                    return (0, CndpEndpoint::new(None, None, None));
+                }
+                self.cur_pkt_index = -1;
+                self.last_num_pkts_read = 0;
+            }
+            return (eth_payload_len as usize, endpoint);
+        }
+        return (0, CndpEndpoint::new(None, None, None));
+    }
+}
+
+impl Drop for CndpPacketReader {
+    fn drop(&mut self) {
+        log::debug!("CndpPacketReader drop");
+        let cne_uids = self.cne_uids.write().unwrap();
+        CndpPacketCommon::unregister_cne_uids(&(*cne_uids));
+    }
+}
+
+impl CndpPacketCommon {
+    pub fn get_json_data() -> CndpPacketJsonData {
+        let mut cndp_toml_dir = std::env::current_exe().expect("Can't find path to executable");
+        cndp_toml_dir.pop();
+        cndp_toml_dir.push("wg_cndp.toml");
+        let toml_contents =
+            fs::read_to_string(cndp_toml_dir.to_str().unwrap()).expect("Unable to read toml file");
+        // Convert toml as Map<String, Value>
+        let toml_map = toml_contents
+            .parse::<Value>()
+            .ok()
+            .and_then(|r| match r {
+                Value::Table(table) => Some(table),
+                _ => None,
+            })
+            .unwrap_or(Map::new());
+        // Parse Json file and initialize AF_XDP socket.
+        let jsonc_file = match toml_map.get("jsonc") {
+            Some(v) => String::from(v.as_str().expect("jsonc should be string")),
+            None => panic!("jsonc is mandatory"),
+        };
+
+        // Get CNE instance.
+        let cne = CneInstance::get_instance();
+
+        // Configure CNE.
+        if let Err(e) = cne.configure(&jsonc_file) {
+            panic!("Error configuring CNE: {}", e.to_string());
+        }
+
+        // Get CNE port to read packets.
+        let lport = cne.get_port(2);
+
+        // Check if port is valid.
+        if let Err(ref e) = lport {
+            log::error!("{}", e.to_string());
+            // Cleanup and exit.
+            if let Err(e) = cne.cleanup() {
+                log::error!("{}", e.to_string());
+            }
+        }
+        let lport_reader = lport.unwrap();
+
+        let lport_reader_info = lport_reader.get_port_details().unwrap();
+
+        // Get interface details
+        let (iface_name, src_mac, src_ip) =
+            Self::get_interface_details(&lport_reader_info.netdev.unwrap());
+        let bind_endpoint = CndpEndpoint::new(src_ip, None, src_mac);
+        let reader_thread_coreid = match Self::read_config(&toml_map, "packet_reader_thread_coreid")
+        {
+            Some(v) => Some(v.as_integer().expect("core id should be integer") as usize),
+            None => None,
+        };
+
+        // Get CNE port to write packets.
+        let lport = cne.get_port(3);
+
+        // Check if port is valid.
+        if let Err(ref e) = lport {
+            log::error!("{}", e.to_string());
+            // Cleanup and exit.
+            if let Err(e) = cne.cleanup() {
+                log::error!("{}", e.to_string());
+            }
+        }
+        let lport_writer = lport.unwrap();
+        let writer_thread_coreid = match Self::read_config(&toml_map, "packet_writer_thread_coreid")
+        {
+            Some(v) => Some(v.as_integer().expect("core id should be integer") as usize),
+            None => None,
+        };
+
+        let writer_sender_channel_thread_coreid =
+            match Self::read_config(&toml_map, "packet_writer_sender_channel_thread_coreid") {
+                Some(v) => Some(v.as_integer().expect("core id should be integer") as usize),
+                None => None,
+            };
+        // Create CndpJsonBind return value.
+        let json_data = CndpPacketJsonData {
+            iface_name: iface_name,
+            endpoint: Some(bind_endpoint),
+            lport_reader: lport_reader,
+            lport_writer: lport_writer,
+            reader_core_id: reader_thread_coreid,
+            writer_core_id: writer_thread_coreid,
+            writer_sender_channel_core_id: writer_sender_channel_thread_coreid,
+        };
+        return json_data;
+    }
+
+    pub fn read_config(toml_map: &Map<String, Value>, key: &str) -> Option<Value> {
+        let val = match toml_map.get(key) {
+            Some(v) => Some(v.clone()),
+            None => None,
+        };
+        return val;
+    }
+
+    pub fn get_interface_details(
+        netdev: &str,
+    ) -> (Option<String>, Option<MacAddr>, Option<IpAddr>) {
+        log::debug!("netdev = {}", netdev);
+        let src_ip = CndpPacketUtil::get_ip_addr_from_ifname(netdev);
+        log::debug!("ipv4_addr = {:?}", src_ip);
+        let src_mac = CndpPacketUtil::get_mac_from_ifname(netdev);
+        log::debug!("src_mac = {:?}", src_mac);
+        return (Some(String::from(netdev)), src_mac, src_ip);
+    }
+
+    pub fn parse_packet(buf: &mut [u8], pkt: &Packet) -> (usize, CndpEndpoint) {
+        // Get pkt data.
+        let pkt_data = pkt.get_data();
+        if pkt_data.is_err() {
+            log::debug!("Cndp Reader pktmbuf data is null");
+            return (0, CndpEndpoint::new(None, None, None));
+        };
+        let pkt_data = pkt_data.unwrap();
+        // Create CNDP packet structure.
+        let mut cndp_eth_packet = CndpPacket::new(pkt_data).unwrap();
+        let (eth_payload, eth_payload_len) = cndp_eth_packet.get_eth_payload_ptr();
+        if eth_payload_len > 0 {
+            let eth_payload = eth_payload.unwrap();
+            if eth_payload.is_null() {
+                // Eth payload should not be null if eth_payload_len > 0
+                panic!("Eth payload is null when eth payload length > 0");
+            }
+            let p = unsafe { slice::from_raw_parts(eth_payload, eth_payload_len as usize) };
+            buf[..eth_payload_len as usize].copy_from_slice(&p[..]);
+        } else {
+            log::debug!("Cndp Reader Packet payload len = 0");
+        }
+        let endpoint = CndpEndpoint::new(
+            cndp_eth_packet.src_ip,
+            cndp_eth_packet.src_port,
+            cndp_eth_packet.src_mac,
+        );
+        log::debug!(
+            "Read 1 packet Ethernet Packet(size = {}) at time {}",
+            pkt_data.len(),
+            SystemTime::now()
+                .duration_since(std::time::UNIX_EPOCH)
+                .unwrap()
+                .as_micros()
+        );
+        return (eth_payload_len as usize, endpoint);
+    }
+
+    pub fn update_packet(
+        buf: &[u8],
+        pkt: &mut Packet,
+        src: &CndpEndpoint,
+        dst: &CndpEndpoint,
+    ) -> i32 {
+        // Get total length of packet.
+        let data_len = CndpPacketUtil::get_eth_udp_packet_len(buf.len()) as u16;
+        // Set pkt data len.
+        let ret = pkt.set_data_len(data_len);
+        if let Err(e) = ret {
+            log::error!("{}", e.to_string());
+            return -1;
+        }
+        // Get pkt data.
+        let pkt_data = pkt.get_data_mut();
+        if pkt_data.is_err() {
+            log::debug!("update_pktmbuf: pktmbuf data is null");
+            return -1;
+        };
+        let pkt_data = pkt_data.unwrap();
+        // Create CNDP packet structure.
+        let mut cndp_eth_packet = MutableCndpPacket::new(pkt_data).unwrap();
+        // Update CNDP packet.
+        cndp_eth_packet.update_eth_packet(src.mac.unwrap(), dst.mac.unwrap(), buf, true);
+        return 0;
+    }
+
+    pub fn send_pkts(pkts: &mut Vec<PacketSendData>, lport: &Port) -> i32 {
+        let mut tx_pkts = [Packet::default(); Packet::MAX_BURST];
+        let num_pkts_to_send = pkts.len();
+        let n_pkts = match lport.prepare_tx_packets(&mut tx_pkts[..num_pkts_to_send]) {
+            Ok(n_pkts) => n_pkts,
+            Err(_e) => 0,
+        };
+        if n_pkts < num_pkts_to_send as u16 {
+            log::debug!("Cannot allocate enough buffers to send all packets");
+            log::debug!("Requested = {}, Allocated = {}", num_pkts_to_send, n_pkts);
+        }
+        if n_pkts > 0 {
+            log::debug!("n_pkts = {}", n_pkts);
+            log::debug!(
+                "start process {} packet at time {}",
+                n_pkts,
+                SystemTime::now()
+                    .duration_since(std::time::UNIX_EPOCH)
+                    .unwrap()
+                    .as_micros()
+            );
+            for i in 0..n_pkts {
+                // Get data buf.
+                // Remove packet from front of the list and move the ownership out of the list.
+                let pkt = pkts.remove(0 as usize);
+                let buf = pkt.buf;
+                let src_endpoint = pkt.src_endpoint;
+                let dst_endpoint = pkt.dst_endpoint;
+                // Get a single TX packet.
+                let pkt = &mut tx_pkts[i as usize];
+                // Update pkt with data (payload + ip/udp/eth headers).
+                let ret = CndpPacketCommon::update_packet(&buf, pkt, &src_endpoint, &dst_endpoint);
+                if ret < 0 {
+                    log::error!("update_packet failed");
+                    return -1;
+                }
+            }
+            let n = match lport.tx_burst(&mut tx_pkts[..n_pkts as usize]) {
+                Ok(n) => n,
+                Err(e) => {
+                    log::error!("Error sending packets {} ", e.to_string());
+                    0
+                }
+            };
+            log::debug!(
+                "Sent {} UDP packets at time {}",
+                n,
+                SystemTime::now()
+                    .duration_since(std::time::UNIX_EPOCH)
+                    .unwrap()
+                    .as_micros()
+            );
+            // Free packets which are not sent.
+            if n < n_pkts {
+                let ret = Packet::free_packet_buffer(&mut tx_pkts[n as usize..n_pkts as usize]);
+                if let Err(e) = ret {
+                    log::error!("{}", e.to_string());
+                    return -1;
+                }
+            }
+        }
+        return 0;
+    }
+
+    pub fn unregister_cne_uids(cne_uids: &HashSet<i32>) {
+        for cne_uid in cne_uids {
+            let cne = CneInstance::get_instance();
+            if cne.unregister_thread(*cne_uid).is_err() {
+                log::error!("cne_unregister failed for cne_uid = {}", *cne_uid);
+            }
+        }
+    }
+
+    pub fn has_quit(quit: &Arc<RwLock<bool>>) -> bool {
+        let has_quit = quit.read().unwrap();
+        *has_quit
+    }
+}
+
+impl PlatformPacketReadWrite for CndpPacketSyncChannel {
+    type Owner = CndpPacketOwner;
+    fn bind() -> Result<(Self::Reader, Self::Writer, Self::Owner), Self::Error> {
+        log::info!("Wireguard called bind ");
+        // Get Cndp Packet Json Data.
+        let json_data = CndpPacketCommon::get_json_data();
+        // Create Arc RwLock.
+        let quit_arc_mutex = Arc::new(RwLock::new(false));
+        // Create Cndp Packet Reader.
+        let reader = CndpPacketReader {
+            iface_name: json_data.iface_name.clone(),
+            endpoint: json_data.endpoint,
+            quit: Arc::clone(&quit_arc_mutex),
+            lport: json_data.lport_reader,
+            rx_pkts: vec![
+                cne::packet::Packet::default();
+                CndpPacketCommon::READ_BURST_PKTS as usize
+            ],
+            core_id: json_data.reader_core_id,
+            cne_uids: RwLock::new(HashSet::new()),
+            cur_pkt_index: -1,
+            last_num_pkts_read: 0,
+        };
+        // Create Cndp Packet Writer channel.
+        // Packet writer send channel thread, sends packet to the channel.
+        // Packet writer receive channel thread, reads packet from channel,
+        // creates ethernet packet, accumulates the packets till a given
+        // threshold or till timeout occurs and then sends the burst of packet to peer node.
+        let (sender_w, receiver_w) = sync_channel::<PacketSendData>(1024);
+        let writer_recv = CndpPacketWriterReceiverChannel {
+            quit: Arc::clone(&quit_arc_mutex),
+            lport: json_data.lport_writer,
+            core_id: json_data.writer_core_id,
+            receiver: receiver_w,
+        };
+        let writer = CndpPacketWriterSenderChannel {
+            iface_name: json_data.iface_name.clone(),
+            endpoint: json_data.endpoint,
+            quit: Arc::clone(&quit_arc_mutex),
+            core_id: json_data.writer_sender_channel_core_id,
+            cne_uids: RwLock::new(HashSet::new()),
+            sender: sender_w,
+        };
+        let owner = CndpPacketOwner {
+            quit: Arc::clone(&quit_arc_mutex),
+        };
+        // Packet writer receive channel thread.
+        thread::spawn(move || {
+            writer_recv.write();
+        });
+        return Ok((reader, writer, owner));
+    }
+}
+
+impl Writer<CndpEndpoint> for CndpPacketWriterSenderChannel {
+    type Error = CndpError;
+    fn write(&self, buf: Vec<u8>, dst: &mut CndpEndpoint) -> Result<(), Self::Error> {
+        // If this function is called from a Wireguard Rust thread register it with CNDP.
+        let register = CneRegister::new("CndpPacketWriterSenderChannel", self.core_id);
+        if register.cne_uid > 0 {
+            let mut cne_uids = self.cne_uids.write().unwrap();
+            (*cne_uids).insert(register.cne_uid);
+        }
+        if CndpPacketCommon::has_quit(&self.quit) {
+            log::debug!("Cndp Packet Writer quitted");
+            return Err(CndpError::Disconnected);
+        }
+        if dst.mac.is_none() {
+            log::error!("CndpPacketWriter: dst mac is not provided");
+            return Err(CndpError::WriterError);
+        }
+        // Get lport for fwd thread.
+        let pkt_send_data = PacketSendData {
+            buf: buf,
+            src_endpoint: self.endpoint.unwrap(),
+            dst_endpoint: *dst,
+        };
+        match self.sender.send(pkt_send_data) {
+            Err(_) => {
+                log::debug!("CndpPacketWriterSenderChannel: Send Error");
+                return Err(CndpError::WriterError);
+            }
+            Ok(_) => {
+                log::debug!("CndpPacketWriterSenderChannel: Send data");
+                log::debug!(
+                    "CndpPacketWriterSenderChannel Send 1 packet at time {}",
+                    SystemTime::now()
+                        .duration_since(std::time::UNIX_EPOCH)
+                        .unwrap()
+                        .as_micros()
+                );
+            }
+        }
+        Ok(())
+    }
+}
+
+impl Drop for CndpPacketWriterSenderChannel {
+    fn drop(&mut self) {
+        log::debug!("CndpPacketWriterSenderChannel drop");
+        let cne_uids = self.cne_uids.write().unwrap();
+        CndpPacketCommon::unregister_cne_uids(&(*cne_uids));
+        log::debug!(
+            "CndpPacketWriterSenderChannel unregister {} cne_uids",
+            (*cne_uids).len()
+        );
+    }
+}
+
+impl CndpPacketWriterReceiverChannel {
+    fn write(&self) {
+        let register = CneRegister::new("CndpPacketWriterReceiverChannel", self.core_id);
+        let mut num_pkts_received = 0;
+        let mut pkts = Vec::new();
+        let wait_time = Duration::from_micros(CndpPacketCommon::WRITE_WAIT_DURATION_IN_MICROS);
+        let mut send_packets = false;
+        loop {
+            if CndpPacketCommon::has_quit(&self.quit) {
+                log::debug!("Cndp Writer quitted");
+                break;
+            }
+            // If number of packets received is greater than a threshold
+            // or timeout occurs send packets received (if any).
+            match self.receiver.recv_timeout(wait_time) {
+                Ok(data) => {
+                    log::debug!(
+                        "CndpPacketWriterReceiverChannel: Receive data, num_pkts_received= {}",
+                        num_pkts_received
+                    );
+                    num_pkts_received += 1;
+                    pkts.push(data);
+                    send_packets = num_pkts_received >= CndpPacketCommon::WRITE_THRESHOLD_NUM_PKTS;
+                }
+                Err(RecvTimeoutError::Timeout) => {
+                    // Check if there are packets to be send.
+                    if !pkts.is_empty() {
+                        log::debug!(
+                            "CndpPacketWriterReceiverChannel: Timeout. Send pending packets"
+                        );
+                        send_packets = true;
+                    }
+                }
+                Err(RecvTimeoutError::Disconnected) => {
+                    log::debug!("CndpPacketWriterReceiverChannel : Disconnected");
+                    break;
+                }
+            }
+            if send_packets {
+                let lport = &self.lport;
+                CndpPacketCommon::send_pkts(&mut pkts, lport);
+                // Reset.
+                pkts.clear();
+                num_pkts_received = 0;
+                send_packets = false;
+            }
+        }
+        // Unregister this thread from CNDP.
+        let cne = CneInstance::get_instance();
+        cne.unregister_thread(register.cne_uid).unwrap();
+    }
+}
+
+impl PlatformPacketReadWrite for CndpPacketBuffered {
+    type Owner = CndpPacketOwner;
+    fn bind() -> Result<(Self::Reader, Self::Writer, Self::Owner), Self::Error> {
+        log::info!("Wireguard called bind ");
+        // Get Cndp UDP Json Data.
+        let json_data = CndpPacketCommon::get_json_data();
+        // Create Arc RwLock.
+        let quit_arc_mutex = Arc::new(RwLock::new(false));
+        // Create Cndp UDP Reader.
+        let reader = CndpPacketReader {
+            iface_name: json_data.iface_name.clone(),
+            endpoint: json_data.endpoint,
+            quit: Arc::clone(&quit_arc_mutex),
+            lport: json_data.lport_reader,
+            rx_pkts: vec![
+                cne::packet::Packet::default();
+                CndpPacketCommon::READ_BURST_PKTS as usize
+            ],
+            core_id: json_data.reader_core_id,
+            cne_uids: RwLock::new(HashSet::new()),
+            cur_pkt_index: -1,
+            last_num_pkts_read: 0,
+        };
+
+        // Create Cndp UDP Buffered Writer.
+        let writer = CndpPacketBufferedWriter {
+            inner: Arc::new(CndpPacketBufferedWriterInner {
+                iface_name: json_data.iface_name.clone(),
+                endpoint: json_data.endpoint,
+                quit: Arc::clone(&quit_arc_mutex),
+                lport: json_data.lport_writer,
+                core_id: json_data.writer_core_id,
+                cne_uids: RwLock::new(HashSet::new()),
+                pkts: RwLock::new(Vec::new()),
+                runner: Runner::new(Duration::from_micros(10), 1000, 1024),
+                timer: RwLock::new(None),
+            }),
+        };
+
+        let owner = CndpPacketOwner {
+            quit: Arc::clone(&quit_arc_mutex),
+        };
+
+        return Ok((reader, writer.clone(), owner));
+    }
+}
+
+impl Deref for CndpPacketBufferedWriter {
+    type Target = CndpPacketBufferedWriterInner;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+
+impl Clone for CndpPacketBufferedWriter {
+    fn clone(&self) -> Self {
+        CndpPacketBufferedWriter {
+            inner: self.inner.clone(),
+        }
+    }
+}
+
+impl Writer<CndpEndpoint> for CndpPacketBufferedWriter {
+    type Error = CndpError;
+    fn write(&self, buf: Vec<u8>, dst: &mut CndpEndpoint) -> Result<(), Self::Error> {
+        // If this function is called from a Wireguard Rust thread register it with CNDP.
+        let register = CneRegister::new("CndpPacketBufferedWriter", self.core_id);
+        if register.cne_uid > 0 {
+            let mut cne_uids = self.cne_uids.write().unwrap();
+            (*cne_uids).insert(register.cne_uid);
+        }
+        if CndpPacketCommon::has_quit(&self.quit) {
+            log::debug!("Cndp Writer quitted");
+            return Err(CndpError::Disconnected);
+        }
+        // Get lport for fwd thread.
+        let lport = &self.lport;
+        let ret = self.write_lport(buf, dst, lport);
+        if ret < 0 {
+            log::error!("Cndp Writer failed");
+            return Err(CndpError::WriterError);
+        }
+        Ok(())
+    }
+}
+
+impl CndpPacketBufferedWriter {
+    fn write_lport(&self, buf: Vec<u8>, dst: &mut CndpEndpoint, lport: &Port) -> i32 {
+        if dst.mac.is_none() {
+            log::debug!("Dst mac is not set");
+            return -1;
+        }
+        let pkt_send_data = PacketSendData {
+            buf: buf,
+            src_endpoint: self.endpoint.unwrap(),
+            dst_endpoint: *dst,
+        };
+        // Buffer n/w packets in a vector.
+        let mut pkts = self.pkts.write().unwrap();
+        (*pkts).push(pkt_send_data);
+        if (*pkts).len() >= CndpPacketCommon::WRITE_THRESHOLD_NUM_PKTS {
+            // Stop timer if it's running and send n/w packets from this thread.
+            let timer = self.timer.read().unwrap();
+            if let Some(timer) = &*timer {
+                timer.stop();
+            }
+            CndpPacketCommon::send_pkts(&mut *pkts, lport);
+            (*pkts).clear();
+        } else {
+            let mut timer = self.timer.write().unwrap();
+            // Create timer if it doesn't exist. This timer is used to
+            // send n/w packets after a specified interval. All the packets buffered
+            // will be send when timer expires.
+            if timer.is_none() {
+                log::debug!("Create Timer and callback");
+                let writer = self.clone();
+                let runner = &self.runner;
+                let timer_new = runner.timer(move || {
+                    Self::timer_callback(&writer);
+                });
+                *timer = Some(timer_new);
+            }
+            // Start the timer, but only if the timer is not already pending.
+            let res = (*timer).as_ref().unwrap().start(Duration::from_micros(
+                CndpPacketCommon::WRITE_CALLBACK_TIMER_DURATION_IN_MICROS,
+            ));
+            if res {
+                log::debug!("Timer started");
+            } else {
+                log::debug!("Timer already running");
+            }
+        }
+        return 0;
+    }
+
+    fn timer_callback(writer: &CndpPacketBufferedWriter) {
+        let _register = CneRegister::new("CndpUdpTimerCallback", None);
+        if CndpPacketCommon::has_quit(&writer.quit) {
+            log::debug!("Cndp Writer quitted");
+            return;
+        }
+        let mut pkts = writer.pkts.write().unwrap();
+        if (*pkts).len() > 0 {
+            let lport = &writer.lport;
+            CndpPacketCommon::send_pkts(&mut *pkts, lport);
+            (*pkts).clear();
+        }
+    }
+}
+
+impl Drop for CndpPacketBufferedWriter {
+    fn drop(&mut self) {
+        log::debug!("CndpUdpBufferedWriter drop");
+        let cne_uids = self.cne_uids.write().unwrap();
+        CndpPacketCommon::unregister_cne_uids(&(*cne_uids));
+    }
+}
+
+pub struct CndpPacketOwner {
+    quit: Arc<RwLock<bool>>,
+}
+
+impl Owner for CndpPacketOwner {
+    type Error = CndpError;
+}
+
+impl Drop for CndpPacketOwner {
+    fn drop(&mut self) {
+        log::debug!("CndpPacketOwner drop");
+        // Quit CNE.
+        let mut quit = self.quit.write().unwrap();
+        *quit = true;
+
+        let cne = CneInstance::get_instance();
+        // Cleanup CNE.
+        log::info!("Cleanup CNE");
+        let ret = cne.cleanup();
+        if let Err(e) = ret {
+            log::error!("{}", e.to_string());
+        }
+    }
+}
diff --git a/src/platform/linux/cndp/fwd.jsonc b/src/platform/linux/cndp/fwd.jsonc
new file mode 100644
index 0000000..6f0edc8
--- /dev/null
+++ b/src/platform/linux/cndp/fwd.jsonc
@@ -0,0 +1,157 @@
+{
+    // (R) - Required entry
+    // (O) - Optional entry
+    // All descriptions are optional and short form is 'desc'
+    // The order of the entries in this file are handled when it is parsed and the
+    // entries can be in any order.
+
+    // (R) Application information
+    //    name        - (O) the name of the application
+    //    description - (O) the description of the application
+    "application": {
+        "name": "pktfwd",
+        "description": "A simple packet forwarder"
+    },
+
+    // (O) Default values
+    //    bufcnt - (O) UMEM default buffer count in 1K increments
+    //    bufsz  - (O) UMEM buffer size in 1K increments
+    //    rxdesc - (O) Number of RX ring descriptors in 1K increments
+    //    txdesc - (O) Number of TX ring descriptors in 1K increments
+    //    cache  - (O) MBUF Pool cache size in number of entries
+    //    mtype  - (O) Memory type for mmap allocations
+    "defaults": {
+        "bufcnt": 16,
+        "bufsz": 2,
+        "rxdesc": 2,
+        "txdesc": 2,
+        "cache": 128,
+        "mtype": "2MB"
+    },
+
+    // List of all UMEM's to be created
+    // key/val - (R) The 'key' is the name of the umem for later reference.
+    //               The 'val' is the object describing the UMEM buffer.
+    //               Multiple umem regions can be defined.
+    // A UMEM can support multiple lports using the regions array. Each lports can use
+    // one of the regions.
+    //    bufcnt  - (R) The number of buffers in 1K increments in the UMEM space.
+    //    bufsz   - (R) The size in 1K increments of each buffer in the UMEM space.
+    //    mtype   - (O) If missing or empty string or missing means use 4KB or default system pages.
+    //    regions - (O) Array of sizes one per region in 1K increments, total must be <= bufcnt
+    //    rxdesc  - (O) Number of RX descriptors to be allocated in 1K increments,
+    //                  if not present or zero use defaults.rxdesc, normally zero.
+    //    txdesc  - (O) Number of TX descriptors to be allocated in 1K increments,
+    //                  if not present or zero use defaults.txdesc, normally zero.
+    //    description | desc - (O) Description of the umem space.
+    "umems": {
+        "umem0": {
+            "bufcnt": 32,
+            "bufsz": 2,
+            "mtype": "2MB",
+            "regions": [
+                16,
+                16
+            ],
+            "rxdesc": 0,
+            "txdesc": 0,
+            "description": "UMEM Description 0"
+        }
+    },
+
+
+    // List of all lports to be used in the application
+    // An lport is defined by a netdev/queue ID pair, which is a socket containing a Rx/Tx ring pair.
+    // Each queue ID is assigned to a single socket or a socket is the lport defined by netdev/qid.
+    // Note: A netdev can be shared between lports as the qid is unique per lport
+    //       If netdev is not defined or empty then it must be a virtual interface and not
+    //       associated with a netdev/queue ID.
+    // key/val - (R) The 'key' is the logical name e.g. 'eth0:0', 'eth1:0', ... to be used by the
+    //               application to reference an lport. The 'val' object contains information about
+    //               each lport.
+    //    netdev        - (R) The netdev device to be used, the part before the colon
+    //                     must reflect the netdev name
+    //    pmd           - (R) All PMDs have a name i.e. 'net_af_xdp', 'ring', ...
+    //    qid           - (R) Is the queue id to use for this lport, defined by ethtool command line
+    //    umem          - (R) The UMEM assigned to this lport
+    //    region        - (O) UMEM region index value, default region 0
+    //    busy_poll     - (O) Enable busy polling support, true or false, default false
+    //    busy_timeout  - (O) 1-65535 or 0 - use default value, values in milliseconds
+    //    busy_budget   - (O) 0xFFFF disabled, 0 use default, >0 budget value
+    //    inhibit_prog_load - (O) inhibit loading the BPF program if true, default false
+    //    force_wakeup  - (O) force TX wakeup calls for CVL NIC, default false
+    //    skb_mode      - (O) Enable XDP_FLAGS_SKB_MODE when creating af_xdp socket, forces copy mode, default false
+    //    description   - (O) the description, 'desc' can be used as well
+    "lports": {
+        "enp134s0:0": {
+            "pmd": "net_af_xdp",
+            "qid": 23,
+            "umem": "umem0",
+            "busy_poll": true,
+            "region": 0,
+            "description": "LAN 0 port"
+        },
+        "enp134s0:1": {
+            "pmd": "net_af_xdp",
+            "qid": 33,
+            "umem": "umem0",
+            "busy_poll": true,
+            "region": 1,
+            "description": "LAN 1 port"
+        }
+    },
+
+    // (O) Define the lcore groups for each thread to run
+    //     Can be integers or a string for a range of lcores
+    //     e.g. [10], [10-14,16], [10-12, 14-15, 17-18, 20]
+    // Names of a lcore group and its lcores assigned to the group.
+    // The initial group is for the main thread of the application.
+    // The default group is special and is used if a thread if not assigned to a group.
+    "lcore-groups": {
+        "initial": [22],
+        "group0": [25],
+        "group1": [35],
+        "default": ["22-35"]
+    },
+
+    // (O) Set of common options application defined.
+    //     The Key can be any string and value can be boolean, string, array or integer
+    //     An array must contain only a single value type, boolean, integer, string and
+    //     can't be a nested array.
+    //   no-metrics - (O) Disable metrics gathering and thread
+    //   no-restapi - (O) Disable RestAPI support
+    //   cli        - (O) Enable/Disable CLI supported
+    //   mode       - (O) Mode type [drop | rx-only], tx-only, [lb | loopback], fwd, acl-strict, acl-permissive
+    "options": {
+        "no-metrics": false,
+        "no-restapi": false,
+        "cli": true,
+        "mode": "drop"
+    },
+
+    // List of threads to start and information for that thread. Application can start
+    // it's own threads for any reason and are not required to be configured by this file.
+    //
+    //   Key/Val   - (R) A unique thread name.
+    //                   The format is <type-string>[:<identifier>] the ':' and identifier
+    //                   are optional if all thread names are unique
+    //      group  - (O) The lcore-group this thread belongs to. The
+    //      lports - (O) The list of lports assigned to this thread and can not shared lports.
+    //      description | desc - (O) The description
+    "threads": {
+        "main": {
+            "group": "initial",
+            "description": "CLI Thread"
+        },
+        "fwd:0": {
+            "group": "group0",
+            "lports": ["enp134s0:0"],
+            "description": "Thread 0"
+        },
+        "fwd:1": {
+            "group": "group1",
+            "lports": ["enp134s0:1"],
+            "description": "Thread 1"
+        }
+    }
+}
diff --git a/src/platform/linux/cndp/mod.rs b/src/platform/linux/cndp/mod.rs
new file mode 100644
index 0000000..d36d650
--- /dev/null
+++ b/src/platform/linux/cndp/mod.rs
@@ -0,0 +1,10 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+
+pub mod cndp_error;
+pub mod endpoint;
+pub mod packet;
+pub mod udp;
+pub mod tun_channel;
+pub mod eth_packet_rw;
diff --git a/src/platform/linux/cndp/packet.rs b/src/platform/linux/cndp/packet.rs
new file mode 100644
index 0000000..fa01a5c
--- /dev/null
+++ b/src/platform/linux/cndp/packet.rs
@@ -0,0 +1,727 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+use pnet::datalink::{channel, Channel, MacAddr, NetworkInterface};
+use pnet::packet::arp::{ArpHardwareTypes, ArpOperations};
+use pnet::packet::arp::{ArpPacket, MutableArpPacket};
+use pnet::packet::ethernet::{EtherTypes, EthernetPacket, MutableEthernetPacket};
+use pnet::packet::ip::{IpNextHeaderProtocol, IpNextHeaderProtocols};
+use pnet::packet::ipv4::{self, Ipv4Packet, MutableIpv4Packet};
+use pnet::packet::ipv6::{Ipv6Packet, MutableIpv6Packet};
+use pnet::packet::tcp::{MutableTcpPacket, TcpPacket};
+use pnet::packet::udp::{self, MutableUdpPacket, UdpPacket};
+use pnet::packet::{MutablePacket, Packet};
+use std::fmt::Display;
+use std::fmt::Formatter;
+use std::fmt::Result;
+use std::net::{IpAddr, Ipv4Addr};
+use std::slice;
+
+pub struct CndpPacket<'p> {
+    eth_packet: EthernetPacket<'p>,
+    pub src_mac: Option<MacAddr>,
+    pub dst_mac: Option<MacAddr>,
+    pub src_ip: Option<IpAddr>,
+    pub dst_ip: Option<IpAddr>,
+    pub src_port: Option<u16>,
+    pub dst_port: Option<u16>,
+}
+
+pub struct MutableCndpPacket<'p> {
+    eth_packet: MutableEthernetPacket<'p>,
+    pub src_mac: Option<MacAddr>,
+    pub dst_mac: Option<MacAddr>,
+    pub src_ip: Option<IpAddr>,
+    pub dst_ip: Option<IpAddr>,
+    pub src_port: Option<u16>,
+    pub dst_port: Option<u16>,
+}
+
+pub struct CndpPacketUtil {}
+impl CndpPacketUtil {
+    const IPV4_HEADER_LEN: usize = 20;
+    const UDP_HEADER_LEN: usize = 8;
+
+    pub fn get_eth_udp_packet_len(udp_payload_len: usize) -> usize {
+        let total_len = EthernetPacket::minimum_packet_size()
+            + CndpPacketUtil::IPV4_HEADER_LEN
+            + CndpPacketUtil::UDP_HEADER_LEN
+            + udp_payload_len;
+        total_len
+    }
+
+    pub fn get_eth_packet_len(payload_len: usize) -> usize {
+        let total_len = EthernetPacket::minimum_packet_size() + payload_len;
+        total_len
+    }
+
+    pub fn get_network_interface(iface_name: &str) -> Option<NetworkInterface> {
+        let interfaces = pnet::datalink::interfaces();
+        let interface = interfaces
+            .into_iter()
+            .find(|iface| iface.name == iface_name);
+        interface
+    }
+
+    pub fn get_ipv4_interface_address(interface: &NetworkInterface) -> Option<Ipv4Addr> {
+        let source_ip = interface
+            .ips
+            .iter()
+            .find(|ip| ip.is_ipv4())
+            .map(|ip| match ip.ip() {
+                IpAddr::V4(ip) => ip,
+                _ => unreachable!(),
+            });
+        source_ip
+    }
+
+    pub fn get_ip_addr_from_ifname(iface_name: &str) -> Option<IpAddr> {
+        let addr = Self::get_network_interface(iface_name)
+            .map_or_else(
+                || None,
+                |interface| Self::get_ipv4_interface_address(&interface),
+            )
+            .map(|ipv4| IpAddr::V4(ipv4));
+        addr
+    }
+
+    pub fn get_mac_from_ifname(iface_name: &str) -> Option<MacAddr> {
+        let source_mac =
+            Self::get_network_interface(iface_name).map_or_else(|| None, |interface| interface.mac);
+        source_mac
+    }
+
+    pub fn get_mac_from_string(mac_addr_str: &str) -> Option<MacAddr> {
+        let mac = match mac_addr_str.parse::<MacAddr>() {
+            Ok(mac) => Some(mac),
+            Err(_) => None,
+        };
+        mac
+    }
+
+    pub fn get_mac_through_arp(
+        iface_name: &str,
+        target_ip: Ipv4Addr,
+    ) -> (Option<MacAddr>, Option<MacAddr>) {
+        let interface = Self::get_network_interface(iface_name).unwrap();
+        let source_mac = interface.mac.unwrap();
+        let source_ip = Self::get_ipv4_interface_address(&interface).unwrap();
+        let mut config = pnet::datalink::Config::default();
+        // Timeout if we don't get any response after 5 sec.
+        let timeout = std::time::Duration::from_secs(5);
+        config.read_timeout = Some(timeout);
+        config.write_timeout = Some(timeout);
+        let (mut sender, mut receiver) = match channel(&interface, config) {
+            Ok(Channel::Ethernet(tx, rx)) => (tx, rx),
+            Ok(_) => panic!("Unknown channel type"),
+            Err(e) => panic!("Error {}", e),
+        };
+        let mut ethernet_buffer = [0u8; 42];
+        let mut ethernet_packet = MutableEthernetPacket::new(&mut ethernet_buffer).unwrap();
+        ethernet_packet.set_destination(MacAddr::broadcast());
+        ethernet_packet.set_source(source_mac);
+        ethernet_packet.set_ethertype(EtherTypes::Arp);
+        let mut arp_buffer = [0u8; 28];
+        let mut arp_packet = MutableArpPacket::new(&mut arp_buffer).unwrap();
+        arp_packet.set_hardware_type(ArpHardwareTypes::Ethernet);
+        arp_packet.set_protocol_type(EtherTypes::Ipv4);
+        arp_packet.set_hw_addr_len(6);
+        arp_packet.set_proto_addr_len(4);
+        arp_packet.set_operation(ArpOperations::Request);
+        arp_packet.set_sender_hw_addr(source_mac);
+        arp_packet.set_sender_proto_addr(source_ip);
+        arp_packet.set_target_hw_addr(MacAddr::zero());
+        arp_packet.set_target_proto_addr(target_ip);
+        ethernet_packet.set_payload(arp_packet.packet_mut());
+        sender
+            .send_to(ethernet_packet.packet(), None)
+            .unwrap()
+            .unwrap();
+        log::debug!("Sent ARP request");
+        match receiver.next() {
+            Ok(buf) => {
+                let arp =
+                    ArpPacket::new(&buf[MutableEthernetPacket::minimum_packet_size()..]).unwrap();
+                log::debug!("Received ARP reply");
+                (Some(source_mac), Some(arp.get_sender_hw_addr()))
+            }
+            Err(_) => (Some(source_mac), None),
+        }
+    }
+}
+
+impl<'p> Display for CndpPacket<'p> {
+    fn fmt(&self, fmt: &mut Formatter) -> Result {
+        write!(
+            fmt,
+            "CndpPacket [
+                            src_mac: {:?}, dst_mac: {:?},
+                            src_ip: {:?}, dst_ip: {:?},
+                            src_port: {:?}, dst_port: {:?}
+                           ]",
+            self.src_mac, self.dst_mac, self.src_ip, self.dst_ip, self.src_port, self.dst_port
+        )
+    }
+}
+
+impl<'p> Display for MutableCndpPacket<'p> {
+    fn fmt(&self, fmt: &mut Formatter) -> Result {
+        write!(
+            fmt,
+            "MutableCndpPacket [
+                            src_mac: {:?}, dst_mac: {:?},
+                            src_ip: {:?}, dst_ip: {:?},
+                            src_port: {:?}, dst_port: {:?}
+                           ]",
+            self.src_mac, self.dst_mac, self.src_ip, self.dst_ip, self.src_port, self.dst_port
+        )
+    }
+}
+
+impl<'p> CndpPacket<'p> {
+    pub fn new<'a>(p: &'a [u8]) -> Option<CndpPacket<'a>> {
+        let ethernet_packet = EthernetPacket::new(p).unwrap();
+        Some(CndpPacket {
+            eth_packet: ethernet_packet,
+            src_mac: None,
+            dst_mac: None,
+            src_ip: None,
+            dst_ip: None,
+            src_port: None,
+            dst_port: None,
+        })
+    }
+
+    pub fn parse_eth_udp_tcp_packet(&mut self) -> i32 {
+        self.src_mac = Some(self.eth_packet.get_source());
+        self.dst_mac = Some(self.eth_packet.get_destination());
+        let ret = match self.eth_packet.get_ethertype() {
+            EtherTypes::Ipv4 => self.parse_ipv4_packet(),
+            EtherTypes::Ipv6 => self.parse_ipv6_packet(),
+            _ => {
+                log::debug!(
+                    "Unknown packet: {} > {}; ethertype: {:?} length: {}",
+                    self.eth_packet.get_source(),
+                    self.eth_packet.get_destination(),
+                    self.eth_packet.get_ethertype(),
+                    self.eth_packet.packet().len()
+                );
+                -1
+            }
+        };
+        ret
+    }
+
+    fn parse_ipv4_packet(&mut self) -> i32 {
+        let ip = Ipv4Packet::new(self.eth_packet.payload());
+        if let Some(ip) = ip {
+            self.src_ip = Some(IpAddr::V4(ip.get_source()));
+            self.dst_ip = Some(IpAddr::V4(ip.get_destination()));
+            let (src_port, dst_port, status) = self.parse_transport_packet(
+                self.src_ip.unwrap(),
+                self.dst_ip.unwrap(),
+                ip.get_next_level_protocol(),
+                ip.payload(),
+            );
+            self.src_port = src_port;
+            self.dst_port = dst_port;
+            status
+        } else {
+            log::debug!("Malformed IPv4 Packet");
+            -1
+        }
+    }
+
+    fn parse_ipv6_packet(&mut self) -> i32 {
+        let ip = Ipv6Packet::new(self.eth_packet.payload());
+        if let Some(ip) = ip {
+            self.src_ip = Some(IpAddr::V6(ip.get_source()));
+            self.dst_ip = Some(IpAddr::V6(ip.get_destination()));
+            let (src_port, dst_port, status) = self.parse_transport_packet(
+                self.src_ip.unwrap(),
+                self.dst_ip.unwrap(),
+                ip.get_next_header(),
+                ip.payload(),
+            );
+            self.src_port = src_port;
+            self.dst_port = dst_port;
+            status
+        } else {
+            log::debug!("Malformed IPv6 Packet");
+            -1
+        }
+    }
+
+    fn parse_transport_packet(
+        &self,
+        source: IpAddr,
+        destination: IpAddr,
+        protocol: IpNextHeaderProtocol,
+        packet: &[u8],
+    ) -> (Option<u16>, Option<u16>, i32) {
+        let ret = match protocol {
+            IpNextHeaderProtocols::Udp => self.parse_udp_packet(packet),
+            IpNextHeaderProtocols::Tcp => self.parse_tcp_packet(packet),
+            _ => {
+                log::debug!(
+                    "Unknown {} packet: {} > {}; protocol: {:?} length: {}",
+                    match source {
+                        IpAddr::V4(..) => "IPv4",
+                        _ => "IPv6",
+                    },
+                    source,
+                    destination,
+                    protocol,
+                    packet.len()
+                );
+                (None, None, -1)
+            }
+        };
+        ret
+    }
+
+    fn parse_udp_packet(&self, packet: &[u8]) -> (Option<u16>, Option<u16>, i32) {
+        let udp = UdpPacket::new(packet);
+        let ret = if let Some(udp) = udp {
+            (Some(udp.get_source()), Some(udp.get_destination()), 0)
+        } else {
+            log::debug!("Malformed UDP Packet");
+            (None, None, -1)
+        };
+        ret
+    }
+
+    fn parse_tcp_packet(&self, packet: &[u8]) -> (Option<u16>, Option<u16>, i32) {
+        let tcp = TcpPacket::new(packet);
+        let ret = if let Some(tcp) = tcp {
+            (Some(tcp.get_source()), Some(tcp.get_destination()), 0)
+        } else {
+            log::debug!("Malformed TCP Packet");
+            (None, None, -1)
+        };
+        ret
+    }
+
+    pub fn get_eth_payload(&self, buf: &mut [u8]) -> usize {
+        let payload = self.eth_packet.payload();
+        let payload_len = payload.len();
+        buf[..payload_len as usize].copy_from_slice(&payload[..]);
+        payload_len
+    }
+
+    pub fn get_udp_payload(&self, buf: &mut [u8]) -> usize {
+        let ip = Ipv4Packet::new(self.eth_packet.payload());
+        let mut payload_len = 0;
+        if let Some(ip) = ip {
+            let udp = UdpPacket::new(ip.payload());
+            if let Some(udp) = udp {
+                let payload = udp.payload();
+                payload_len = payload.len();
+                buf[..payload_len as usize].copy_from_slice(&payload[..]);
+            }
+        }
+        payload_len
+    }
+
+    pub fn get_udp_payload_ptr(&mut self) -> (Option<*const u8>, usize) {
+        let ip = Ipv4Packet::new(self.eth_packet.payload());
+        if let Some(ip) = ip {
+            let udp = UdpPacket::new(ip.payload());
+            if let Some(udp) = udp {
+                let payload = udp.payload();
+                return (Some(payload.as_ptr()), payload.len());
+            }
+        }
+        (None, 0)
+    }
+
+    pub fn get_eth_payload_ptr(&mut self) -> (Option<*const u8>, usize) {
+        let payload = self.eth_packet.payload();
+        return (Some(payload.as_ptr()), payload.len());
+    }
+}
+
+impl<'p> MutableCndpPacket<'p> {
+    pub fn new<'a>(p: &'a mut [u8]) -> Option<MutableCndpPacket<'a>> {
+        let ethernet_packet = MutableEthernetPacket::new(p).unwrap();
+        Some(MutableCndpPacket {
+            eth_packet: ethernet_packet,
+            src_mac: None,
+            dst_mac: None,
+            src_ip: None,
+            dst_ip: None,
+            src_port: None,
+            dst_port: None,
+        })
+    }
+
+    pub fn to_immutable(&self) -> CndpPacket {
+        CndpPacket {
+            eth_packet: self.eth_packet.to_immutable(),
+            src_mac: self.src_mac,
+            dst_mac: self.dst_mac,
+            src_ip: self.src_ip,
+            dst_ip: self.dst_ip,
+            src_port: self.src_port,
+            dst_port: self.dst_port,
+        }
+    }
+
+    pub fn swap_mac_addresses_eth(&mut self, pnet_swap: bool) {
+        // Swap src and dst mac address.
+        if pnet_swap {
+            let src = self.eth_packet.get_source();
+            let dst = self.eth_packet.get_destination();
+            self.eth_packet.set_source(dst);
+            self.eth_packet.set_destination(src);
+        } else {
+            let mac_addr_len = 6;
+            let mut p = self.eth_packet.packet_mut();
+            // Get src and dst mac address.
+            p = &mut p[0..mac_addr_len * 2];
+            let (left, right) = p.split_at_mut(mac_addr_len);
+            // Swap src and dst mac address.
+            left.swap_with_slice(&mut right[0..left.len()]);
+        }
+    }
+
+    pub fn swap_ip_addresses(&mut self, pnet_swap: bool) {
+        // Swap source and dst UDP port.
+        match self.eth_packet.get_ethertype() {
+            EtherTypes::Ipv4 => {
+                self.swap_ipv4_addresses(pnet_swap);
+            }
+            EtherTypes::Ipv6 => {
+                self.swap_ipv6_addresses(pnet_swap);
+            }
+            _ => log::debug!("Malformed IP Packet"),
+        }
+    }
+    pub fn swap_ipv4_addresses(&mut self, pnet_swap: bool) {
+        // Swap source and dst IP address.
+        let ip = MutableIpv4Packet::new(self.eth_packet.payload_mut());
+        if let Some(mut ip) = ip {
+            if pnet_swap {
+                let src = ip.get_source();
+                let dst = ip.get_destination();
+                ip.set_source(dst);
+                ip.set_destination(src);
+            } else {
+                // src ipv4: ip_packet[12-15], dst ipv4: ip_packet[16-19]
+                let ipv4_addr_len = 4;
+                let ipv4_offset = 12;
+                // Get src and dst ipv4 address.
+                let p = &mut ip.packet_mut()[ipv4_offset..(ipv4_offset + ipv4_addr_len * 2)];
+                let (left, right) = p.split_at_mut(ipv4_addr_len);
+                // Swap src and dst ipv4 address.
+                left.swap_with_slice(&mut right[0..left.len()]);
+            }
+        }
+    }
+
+    pub fn swap_ipv6_addresses(&mut self, pnet_swap: bool) {
+        // Swap source and dst IP address.
+        let ip = MutableIpv6Packet::new(self.eth_packet.payload_mut());
+        if let Some(mut ip) = ip {
+            if pnet_swap {
+                let src = ip.get_source();
+                let dst = ip.get_destination();
+                ip.set_source(dst);
+                ip.set_destination(src);
+            } else {
+                // src ipv6: ip_packet[8-23], dst ipv6: ip_packet[24-39]
+                let ipv6_addr_len = 16;
+                let ipv6_offset = 8;
+                // Get src and dst ipv6 address.
+                let p = &mut ip.packet_mut()[ipv6_offset..(ipv6_offset + ipv6_addr_len * 2)];
+                let (left, right) = p.split_at_mut(ipv6_offset);
+                // Swap src and dst ipv6 address.
+                left.swap_with_slice(&mut right[0..left.len()]);
+            }
+        }
+    }
+
+    pub fn swap_ports(&mut self, pnet_swap: bool) {
+        // Swap source and dst UDP port.
+        match self.eth_packet.get_ethertype() {
+            EtherTypes::Ipv4 => {
+                let ip = MutableIpv4Packet::new(self.eth_packet.payload_mut());
+                if let Some(mut ip) = ip {
+                    let protocol = ip.get_next_level_protocol();
+                    swap_transport_ports(protocol, ip.payload_mut(), pnet_swap);
+                }
+            }
+            EtherTypes::Ipv6 => {
+                let ip = MutableIpv6Packet::new(self.eth_packet.payload_mut());
+                if let Some(mut ip) = ip {
+                    let protocol = ip.get_next_header();
+                    swap_transport_ports(protocol, ip.payload_mut(), pnet_swap);
+                }
+            }
+            _ => log::debug!("Malformed IP Packet"),
+        }
+
+        fn swap_transport_ports(
+            protocol: IpNextHeaderProtocol,
+            payload: &mut [u8],
+            pnet_swap: bool,
+        ) {
+            match protocol {
+                IpNextHeaderProtocols::Udp => {
+                    let udp = MutableUdpPacket::new(payload);
+                    swap_udp_ports(udp, pnet_swap);
+                }
+                IpNextHeaderProtocols::Tcp => {
+                    let tcp = MutableTcpPacket::new(payload);
+                    swap_tcp_ports(tcp, pnet_swap);
+                }
+                _ => {
+                    log::debug!("Unknown protocol: {}", protocol);
+                }
+            }
+        }
+
+        fn swap_udp_ports(udp: Option<MutableUdpPacket>, pnet_swap: bool) {
+            if let Some(mut udp) = udp {
+                if pnet_swap {
+                    let tmp = udp.get_source();
+                    let dst = udp.get_destination();
+                    udp.set_source(dst);
+                    udp.set_destination(tmp);
+                } else {
+                    // src port: packet[0-1], dst port: packet[2-3]
+                    let port_len = 2;
+                    // Get src and dst port.
+                    let p = &mut udp.packet_mut()[0..port_len * 2];
+                    let (left, right) = p.split_at_mut(port_len);
+                    // Swap src and dst port.
+                    left.swap_with_slice(&mut right[0..left.len()]);
+                }
+            }
+        }
+
+        fn swap_tcp_ports(tcp: Option<MutableTcpPacket>, pnet_swap: bool) {
+            if let Some(mut tcp) = tcp {
+                if pnet_swap {
+                    let tmp = tcp.get_source();
+                    let dst = tcp.get_destination();
+                    tcp.set_source(dst);
+                    tcp.set_destination(tmp);
+                } else {
+                    // src port: packet[0-1], dst port: packet[2-3]
+                    let port_len = 2;
+                    // Get src and dst port.
+                    let p = &mut tcp.packet_mut()[0..port_len * 2];
+                    let (left, right) = p.split_at_mut(port_len);
+                    // Swap src and dst port.
+                    left.swap_with_slice(&mut right[0..left.len()]);
+                }
+            }
+        }
+    }
+
+    pub fn set_udp_payload(&mut self, payload: &[u8]) {
+        let ip = MutableIpv4Packet::new(self.eth_packet.payload_mut());
+        if let Some(mut ip) = ip {
+            let udp = MutableUdpPacket::new(ip.payload_mut());
+            if let Some(mut udp) = udp {
+                udp.set_payload(payload);
+            }
+        }
+    }
+
+    pub fn get_udp_payload_mut_ptr(&mut self) -> (Option<*mut u8>, usize) {
+        let ip = MutableIpv4Packet::new(self.eth_packet.payload_mut());
+        if let Some(mut ip) = ip {
+            let udp = MutableUdpPacket::new(ip.payload_mut());
+            if let Some(mut udp) = udp {
+                let payload = udp.payload_mut();
+                return (Some(payload.as_mut_ptr()), payload.len());
+            }
+        }
+        (None, 0)
+    }
+
+    pub fn get_eth_payload_mut_ptr(&mut self) -> (Option<*mut u8>, usize) {
+        let payload = self.eth_packet.payload_mut();
+        return (Some(payload.as_mut_ptr()), payload.len());
+    }
+
+    pub fn update_eth_udp_packet(
+        &mut self,
+        src_mac: MacAddr,
+        dst_mac: MacAddr,
+        src_ip: IpAddr,
+        dst_ip: IpAddr,
+        src_port: u16,
+        dst_port: u16,
+        transport_payload: &[u8],
+    ) {
+        self.eth_packet.set_source(src_mac);
+        self.eth_packet.set_destination(dst_mac);
+        match src_ip {
+            IpAddr::V4(_) => {
+                self.eth_packet.set_ethertype(EtherTypes::Ipv4);
+                Self::update_udp_packet(
+                    self.eth_packet.payload_mut(),
+                    src_ip,
+                    dst_ip,
+                    src_port,
+                    dst_port,
+                    transport_payload,
+                );
+            }
+            IpAddr::V6(_) => {
+                panic!("Ipv6 Unsupported")
+            }
+        }
+    }
+
+    pub fn update_eth_packet(
+        &mut self,
+        src_mac: MacAddr,
+        dst_mac: MacAddr,
+        payload: &[u8],
+        is_ipv4: bool,
+    ) {
+        self.eth_packet.set_source(src_mac);
+        self.eth_packet.set_destination(dst_mac);
+        match is_ipv4 {
+            true => {
+                self.eth_packet.set_ethertype(EtherTypes::Ipv4);
+            }
+            false => {
+                self.eth_packet.set_ethertype(EtherTypes::Ipv6);
+            }
+        }
+        self.eth_packet.set_payload(payload);
+    }
+
+    pub fn update_udp_packet(
+        packet: &mut [u8],
+        src_ip: IpAddr,
+        dst_ip: IpAddr,
+        src_port: u16,
+        dst_port: u16,
+        transport_payload: &[u8],
+    ) -> u16 {
+        let mut ip_header =
+            Self::update_ipv4_header(packet, src_ip, dst_ip, transport_payload.len());
+        let source = ip_header.get_source();
+        let destination = ip_header.get_destination();
+        let mut udp_header = Self::update_udp_header(
+            ip_header.payload_mut(),
+            src_port,
+            dst_port,
+            transport_payload.len(),
+        );
+        udp_header.set_payload(transport_payload);
+        let checksum = udp::ipv4_checksum(&udp_header.to_immutable(), &source, &destination);
+        udp_header.set_checksum(checksum);
+        ip_header.get_total_length()
+    }
+
+    fn update_ipv4_header(
+        packet: &mut [u8],
+        src_ip: IpAddr,
+        dst_ip: IpAddr,
+        udp_payload_len: usize,
+    ) -> MutableIpv4Packet {
+        let mut ip_header = MutableIpv4Packet::new(packet).unwrap();
+        let total_len = (CndpPacketUtil::IPV4_HEADER_LEN
+            + CndpPacketUtil::UDP_HEADER_LEN
+            + udp_payload_len) as u16;
+        ip_header.set_version(4);
+        ip_header.set_header_length((CndpPacketUtil::IPV4_HEADER_LEN / 4) as u8);
+        ip_header.set_total_length(total_len);
+        ip_header.set_ttl(100);
+        ip_header.set_next_level_protocol(IpNextHeaderProtocols::Udp);
+        if let IpAddr::V4(src_ip) = src_ip {
+            ip_header.set_source(src_ip);
+        }
+        if let IpAddr::V4(dst_ip) = dst_ip {
+            ip_header.set_destination(dst_ip);
+        }
+        let checksum = ipv4::checksum(&ip_header.to_immutable());
+        ip_header.set_checksum(checksum);
+        ip_header
+    }
+
+    fn update_udp_header(
+        packet: &mut [u8],
+        src_port: u16,
+        dst_port: u16,
+        udp_payload_len: usize,
+    ) -> MutableUdpPacket {
+        let mut udp_header = MutableUdpPacket::new(packet).unwrap();
+        udp_header.set_source(src_port);
+        udp_header.set_destination(dst_port);
+        udp_header.set_length((CndpPacketUtil::UDP_HEADER_LEN + udp_payload_len) as u16);
+        udp_header
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    #[test]
+    fn test_cndp_eth_packet() {
+        // Create UDP payload.
+        let udp_payload_size = 50;
+        let udp_payload = vec![0xAA; udp_payload_size];
+        // Fill some data for mac address, Ip address and port.
+        let src_mac = MacAddr(0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff);
+        let dst_mac = MacAddr(0x11, 0x22, 0x33, 0x44, 0x55, 0x66);
+        let src_ip = IpAddr::V4(Ipv4Addr::new(48, 0, 0, 154));
+        let dst_ip = IpAddr::V4(Ipv4Addr::new(48, 0, 0, 155));
+        let src_port = 5400;
+        let dst_port = 5500;
+        // Get total length of ethernet packet based on udp payload.
+        let data_len = CndpPacketUtil::get_eth_udp_packet_len(udp_payload_size as usize);
+        // Create Ethernet/IP/UDP Packet.
+        let mut buf: Vec<u8> = vec![0; data_len];
+        let mut cndp_eth_packet = MutableCndpPacket::new(&mut buf).unwrap();
+        // Update CNDP UDP packet.
+        cndp_eth_packet.update_eth_udp_packet(
+            src_mac,
+            dst_mac,
+            src_ip,
+            dst_ip,
+            src_port,
+            dst_port,
+            &udp_payload[..],
+        );
+        // Parse the ethernet packet and verify the data.
+        let ret = cndp_eth_packet.to_immutable().parse_eth_udp_tcp_packet();
+        // Check if parsing succeeds.
+        assert_eq!(ret, 0);
+        // Check src, dst mac.
+        assert_eq!(cndp_eth_packet.src_mac, Some(src_mac));
+        assert_eq!(cndp_eth_packet.dst_mac, Some(dst_mac));
+        // Check src, dst ip.
+        assert_eq!(cndp_eth_packet.src_ip, Some(src_ip));
+        assert_eq!(cndp_eth_packet.dst_ip, Some(dst_ip));
+        // Check src, dst port.
+        assert_eq!(cndp_eth_packet.src_port, Some(src_port));
+        assert_eq!(cndp_eth_packet.dst_port, Some(dst_port));
+        // Create UDP payload read buffer.
+        let max_payload_size = 1400;
+        let mut udp_payload_parsed: Vec<u8> = vec![0; max_payload_size];
+        // Get UDP payload.
+        let payload_len = cndp_eth_packet
+            .to_immutable()
+            .get_udp_payload(&mut udp_payload_parsed[..]);
+        // Check parsed payload size is same as original payload size.
+        assert_eq!(payload_len as usize, udp_payload_size as usize);
+        // Compare contents of parsed payload with original payload.
+        udp_payload_parsed.truncate(payload_len as usize);
+        let match_buf_count = udp_payload
+            .iter()
+            .zip(udp_payload_parsed.iter())
+            .filter(|&(a, b)| a == b)
+            .count();
+        let res =
+            match_buf_count == udp_payload.len() && match_buf_count == udp_payload_parsed.len();
+        assert_eq!(res, true);
+    }
+}
diff --git a/src/platform/linux/cndp/pktgen_cfg/pktgen.cfg b/src/platform/linux/cndp/pktgen_cfg/pktgen.cfg
new file mode 100644
index 0000000..060e898
--- /dev/null
+++ b/src/platform/linux/cndp/pktgen_cfg/pktgen.cfg
@@ -0,0 +1,55 @@
+description = 'A Pktgen default simple configuration'
+
+# Setup configuration
+setup = {
+    'exec': (
+	'sudo', '-E'
+        ),
+
+    'devices': (
+	    '1c:00.0'
+	    ),
+    # UIO module type, igb_uio, vfio-pci or uio_pci_generic
+    'uio': 'vfio-pci'
+    }
+
+# Run command and options
+run = {
+    'exec': ('sudo', '-E'),
+
+    # Application name and use app_path to help locate the app
+    'app_name': 'pktgen',
+
+    # using (sdk) or (target) for specific variables
+    # add (app_name) of the application
+    # Each path is tested for the application
+    'app_path': (
+		'./usr/local/bin/%(app_name)s',
+		'/usr/local/bin/%(app_name)s'
+        ),
+
+	'cores': '2,3-4',
+	'nrank': '4',
+	'proc': 'auto',
+	'log': '7',
+	'prefix': 'pg',
+
+	'blocklist': (
+		),
+	'allowlist': (
+		'1c:00.0'
+		),
+
+	'opts': (
+		'-v',
+		'-T',
+		'-P',
+		'-j',
+		),
+	'map': (
+		'[3:4].0'
+		),
+
+	'theme': 'themes/black-yellow.theme',
+	#'shared': '/usr/local/lib/x86_64-linux-gnu/dpdk/pmds-21.1'
+	}
diff --git a/src/platform/linux/cndp/pktgen_cfg/xdp.cfg b/src/platform/linux/cndp/pktgen_cfg/xdp.cfg
new file mode 100644
index 0000000..f91cfc9
--- /dev/null
+++ b/src/platform/linux/cndp/pktgen_cfg/xdp.cfg
@@ -0,0 +1,140 @@
+#
+# Pktgen 21.03.1 (DPDK 21.05.0-rc1)
+# Copyright(c) <2010-2021>, Intel Corporation. All rights reserved., Powered by DPDK
+
+# Command line arguments: (DPDK args are defaults)
+# ./usr/local/bin/pktgen -c 7c -n 3 -m 512 --proc-type primary -- -v -T -P -j -m [3:4].0 -m [5:6].1 -f themes/black-yellow.theme
+
+#######################################################################
+# Pktgen Configuration script information:
+#   GUI socket is Not Enabled
+#   Flags 00000804
+#   Number of ports: 2
+#   Number ports per page: 4
+#   Number descriptors: RX 256 TX: 512
+#   Promiscuous mode is Enabled
+
+
+# Global configuration:
+geometry 158x49
+disable mac_from_arp
+
+######################### Port  0 ##################################
+#
+# Port:  0, Burst: 32, Rate:100%, Flags:00000000, TX Count:Forever
+#           Sequence count:0, Prime:1 VLAN ID:0001, Link: <UP-25000-FD>
+#
+# Set up the primary port information:
+set 0 count 0
+set 0 size 1384
+set 0 rate 100
+set 0 burst 32
+set 0 sport 3400
+set 0 dport 3500
+set 0 prime 1
+set 0 type ipv4
+set 0 proto udp
+set 0 dst ip 10.50.0.2
+set 0 src ip 10.50.0.1/24
+set 0 dst mac 3c:fd:fe:a8:5f:bd
+set 0 src mac 3c:fd:fe:a8:5f:bc
+set 0 vlan 1
+
+set 0 pattern abc
+
+set 0 jitter 50
+disable 0 mpls
+range 0 mpls entry 0x0
+disable 0 qinq
+set 0 qinqids 0 0
+disable 0 gre
+disable 0 gre_eth
+disable 0 vxlan
+set 0 vxlan 0x0 0 0
+#
+# Port flag values:
+disable 0 icmp
+disable 0 pcap
+disable 0 range
+disable 0 latency
+disable 0 process
+disable 0 capture
+disable 0 rx_tap
+disable 0 tx_tap
+disable 0 vlan
+disable 0 rate
+
+#
+# Range packet information:
+range 0 src mac start 3c:fd:fe:a8:5f:bc
+range 0 src mac min 00:00:00:00:00:00
+range 0 src mac max 00:00:00:00:00:00
+range 0 src mac inc 00:00:00:00:00:00
+
+range 0 dst mac start 3c:fd:fe:a8:5f:bd
+range 0 dst mac min 00:00:00:00:00:00
+range 0 dst mac max 00:00:00:00:00:00
+range 0 dst mac inc 00:00:00:00:00:00
+
+range 0 src ip start 10.50.0.1
+range 0 src ip min 10.50.0.1
+range 0 src ip max 10.50.0.254
+range 0 src ip inc 0.0.0.0
+
+range 0 dst ip start 10.50.0.2
+range 0 dst ip min 10.50.0.2
+range 0 dst ip max 10.50.0.254
+range 0 dst ip inc 0.0.0.1
+
+range 0 proto udp
+
+range 0 src port start 3400
+range 0 src port min 0
+range 0 src port max 65535
+range 0 src port inc 1
+
+range 0 dst port start 3500
+range 0 dst port min 0
+range 0 dst port max 65535
+range 0 dst port inc 1
+
+range 0 ttl start 64
+range 0 ttl min 0
+range 0 ttl max 255
+range 0 ttl inc 0
+
+range 0 vlan start 1
+range 0 vlan min 1
+range 0 vlan max 4095
+range 0 vlan inc 0
+
+range 0 cos start 0
+range 0 cos min 0
+range 0 cos max 7
+range 0 cos inc 0
+
+range 0 tos start 0
+range 0 tos min 0
+range 0 tos max 255
+range 0 tos inc 0
+range 0 gre key 0
+
+range 0 size start 64
+range 0 size min 64
+range 0 size max 9618
+range 0 size inc 0
+
+#
+# Set up the rate data for the port.
+rate 0 fps 60
+rate 0 lines 720
+rate 0 pixels 1280
+rate 0 color bits 20
+rate 0 payload size 800
+
+rate 0 overhead 62
+#
+# Set up the sequence data for the port.
+set 0 seq_cnt 0
+
+################################ Done #################################
diff --git a/src/platform/linux/cndp/tun_channel.rs b/src/platform/linux/cndp/tun_channel.rs
new file mode 100644
index 0000000..37bc404
--- /dev/null
+++ b/src/platform/linux/cndp/tun_channel.rs
@@ -0,0 +1,245 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+use super::super::super::tun::*; // platform tun
+use super::super::tun::*; // linux tun
+use std::cmp::min;
+use std::fmt;
+use std::os::raw::c_short;
+use std::os::unix::io::RawFd;
+use std::sync::mpsc::{sync_channel, Receiver, RecvTimeoutError, SyncSender, TrySendError};
+use std::time::Duration;
+
+use hex;
+use log::debug;
+use rand::rngs::OsRng;
+use rand::Rng;
+
+const TUNSETIFF: u64 = 0x4004_54ca;
+const CLONE_DEVICE_PATH: &[u8] = b"/dev/net/tun\0";
+
+#[repr(C)]
+struct Ifreq {
+    name: [u8; libc::IFNAMSIZ],
+    flags: c_short,
+    _pad: [u8; 64],
+}
+
+#[derive(Debug)]
+pub enum TunChannelAppError {
+    Disconnected,
+    BufferFull,
+    Timeout,
+}
+
+pub struct TunChannel {}
+
+// Used to send/receive packets to the mock WireGuard interface.
+pub struct TunChannelAppReader {
+    id: u32,
+    rx: Receiver<Vec<u8>>,
+}
+
+#[derive(Clone)]
+pub struct TunChannelAppWriter {
+    id: u32,
+    tx: SyncSender<Vec<u8>>,
+}
+
+pub struct TunChannelReader {
+    id: u32,
+    rx: Receiver<Vec<u8>>,
+}
+
+pub struct TunChannelWriter {
+    id: u32,
+    tx: SyncSender<Vec<u8>>,
+}
+
+impl fmt::Display for TunChannelAppReader {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        write!(f, "TunChannelAppReader({})", self.id)
+    }
+}
+
+impl fmt::Display for TunChannelAppWriter {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        write!(f, "TunChannelAppWriter({})", self.id)
+    }
+}
+
+impl fmt::Display for TunChannelReader {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        write!(f, "TunChannelReader({})", self.id)
+    }
+}
+
+impl fmt::Display for TunChannelWriter {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        write!(f, "TunChannelWriter({})", self.id)
+    }
+}
+
+impl TunChannelAppReader {
+    pub fn read(&self) -> Result<Vec<u8>, TunChannelAppError> {
+        let timeout = Duration::from_secs(1);
+        loop {
+            // This function will block till we get a message or channel/tun is disconnected.
+            match self.rx.recv_timeout(timeout) {
+                Ok(msg) => {
+                    return Ok(msg);
+                }
+                Err(RecvTimeoutError::Timeout) => {
+                    // Continue reading the channel for messages.
+                    continue;
+                }
+                Err(RecvTimeoutError::Disconnected) => {
+                    return Err(TunChannelAppError::Disconnected);
+                }
+            }
+        }
+    }
+
+    pub fn read_timeout(&self, timeout: Duration) -> Result<Vec<u8>, TunChannelAppError> {
+        loop {
+            // Wait till we get a message or timeout occurs or channel gets disconnected.
+            match self.rx.recv_timeout(timeout) {
+                Ok(msg) => {
+                    return Ok(msg);
+                }
+                Err(RecvTimeoutError::Timeout) => {
+                    return Err(TunChannelAppError::Timeout);
+                }
+                Err(RecvTimeoutError::Disconnected) => {
+                    return Err(TunChannelAppError::Disconnected);
+                }
+            }
+        }
+    }
+}
+
+impl TunChannelAppWriter {
+    pub fn write(&self, msg: Vec<u8>) -> Result<(), TunChannelAppError> {
+        match self.tx.try_send(msg) {
+            Ok(_) => Ok(()),
+            Err(TrySendError::Full(_)) => {
+                return Err(TunChannelAppError::BufferFull);
+            }
+            Err(TrySendError::Disconnected(_)) => {
+                return Err(TunChannelAppError::Disconnected);
+            }
+        }
+    }
+}
+
+impl Reader for TunChannelReader {
+    type Error = LinuxTunError;
+
+    fn read(&self, buf: &mut [u8], offset: usize) -> Result<usize, Self::Error> {
+        loop {
+            match self.rx.recv() {
+                Ok(msg) => {
+                    let n = min(buf.len() - offset, msg.len());
+                    buf[offset..offset + n].copy_from_slice(&msg[..n]);
+                    debug!(
+                        "TunChannelReader::TUN({}): read ({}, {})",
+                        self.id,
+                        n,
+                        hex::encode(&buf[offset..offset + n])
+                    );
+                    return Ok(n);
+                }
+                Err(_) => {
+                    return Err(LinuxTunError::Closed);
+                }
+            }
+        }
+    }
+}
+
+impl Writer for TunChannelWriter {
+    type Error = LinuxTunError;
+
+    fn write(&self, src: &[u8]) -> Result<(), Self::Error> {
+        debug!(
+            "TunChannelWriter::TUN({}) : write ({}, {})",
+            self.id,
+            src.len(),
+            hex::encode(src)
+        );
+        let m = src.to_owned();
+        match self.tx.send(m) {
+            Ok(_) => Ok(()),
+            Err(_) => Err(LinuxTunError::Closed),
+        }
+    }
+}
+
+impl Tun for TunChannel {
+    type Writer = TunChannelWriter;
+    type Reader = TunChannelReader;
+    type Error = LinuxTunError;
+}
+
+impl TunChannel {
+    pub fn create(
+        name: &str,
+    ) -> Result<
+        (
+            TunChannelAppReader,
+            TunChannelAppWriter,
+            Vec<TunChannelReader>,
+            TunChannelWriter,
+            LinuxTunStatus,
+        ),
+        LinuxTunError,
+    > {
+        // construct request struct
+        let mut req = Ifreq {
+            name: [0u8; libc::IFNAMSIZ],
+            flags: (libc::IFF_TUN | libc::IFF_NO_PI) as c_short,
+            _pad: [0u8; 64],
+        };
+
+        // sanity check length of device name
+        let bs = name.as_bytes();
+        if bs.len() > libc::IFNAMSIZ - 1 {
+            return Err(LinuxTunError::InvalidTunDeviceName);
+        }
+        req.name[..bs.len()].copy_from_slice(bs);
+
+        // open clone device
+        let fd: RawFd = match unsafe { libc::open(CLONE_DEVICE_PATH.as_ptr() as _, libc::O_RDWR) } {
+            -1 => return Err(LinuxTunError::FailedToOpenCloneDevice),
+            fd => fd,
+        };
+        assert!(fd >= 0);
+
+        // create TUN device
+        if unsafe { libc::ioctl(fd, TUNSETIFF as _, &req) } < 0 {
+            unsafe { libc::close(fd) };
+            return Err(LinuxTunError::SetIFFIoctlFailed);
+        }
+
+        let status = LinuxTunStatus::new(req.name)?;
+        // Create two TUN channel pairs - for sending/receiving
+        // App write (tx1) -> WireGuard read (rx1).
+        // WireGuard write (tx2) -> App read (rx2).
+        let (tx1, rx1) = sync_channel(1024);
+        let (tx2, rx2) = sync_channel(1024);
+        let id: u32 = OsRng.gen();
+        let tun_app_reader = TunChannelAppReader { id, rx: rx2 };
+        let tun_app_writer = TunChannelAppWriter { id, tx: tx1 };
+        let reader = TunChannelReader { id, rx: rx1 };
+        let writer = TunChannelWriter { id, tx: tx2 };
+        Ok((tun_app_reader, tun_app_writer, vec![reader], writer, status))
+    }
+}
+
+impl PlatformTun for TunChannel {
+    type Status = LinuxTunStatus;
+
+    fn create(_name: &str) -> Result<(Vec<Self::Reader>, Self::Writer, Self::Status), Self::Error> {
+        Err(LinuxTunError::Closed)
+    }
+}
diff --git a/src/platform/linux/cndp/udp.rs b/src/platform/linux/cndp/udp.rs
new file mode 100644
index 0000000..42440e1
--- /dev/null
+++ b/src/platform/linux/cndp/udp.rs
@@ -0,0 +1,883 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+
+use pnet::datalink::MacAddr;
+use std::collections::HashMap;
+use std::collections::HashSet;
+use std::fs;
+use std::net::IpAddr;
+use std::ops::Deref;
+use std::slice;
+use std::sync::mpsc::{sync_channel, Receiver, RecvTimeoutError, SyncSender};
+use std::sync::{Arc, RwLock};
+use std::thread;
+use std::time::Duration;
+use std::time::SystemTime;
+use toml::map::Map;
+use toml::Value;
+
+use super::super::super::udp::*;
+use super::endpoint::CndpEndpoint;
+
+use super::cndp_error::CndpError;
+use super::packet::*;
+
+use cne::instance::CneInstance;
+use cne::packet::Packet;
+use cne::packet::PacketInterface;
+use cne::port::Port;
+
+// CNDP UDP Json Data
+pub struct CndpUdpJsonData {
+    pub iface_name: Option<String>,
+    pub endpoint: Option<CndpEndpoint>,
+    pub lport_reader: Port,
+    pub lport_writer: Port,
+    pub reader_core_id: Option<usize>,
+    pub writer_core_id: Option<usize>,
+}
+
+// CNDP UDP Bind
+pub struct CndpUdpReader {
+    pub iface_name: Option<String>,
+    endpoint: Option<CndpEndpoint>,
+    quit: Arc<RwLock<bool>>,
+    lport: Port,
+    rx_pkts: Vec<Packet>,
+    core_id: Option<usize>,
+    cne_uids: RwLock<HashSet<i32>>,
+    cur_pkt_index: i32,
+    last_num_pkts_read: u16,
+}
+
+pub struct CndpUdpWriter {
+    pub iface_name: Option<String>,
+    endpoint: Option<CndpEndpoint>,
+    dst_mac_map: RwLock<HashMap<IpAddr, MacAddr>>,
+    quit: Arc<RwLock<bool>>,
+    lport: Port,
+    core_id: Option<usize>,
+    cne_uids: RwLock<HashSet<i32>>,
+}
+
+
+pub struct PacketSendData {
+    pub buf: Vec<u8>,
+    pub src_endpoint: CndpEndpoint,
+    pub dst_endpoint: CndpEndpoint,
+}
+
+pub struct CndpUdpWriterSenderChannel {
+    iface_name: Option<String>,
+    endpoint: Option<CndpEndpoint>,
+    dst_mac_map: RwLock<HashMap<IpAddr, MacAddr>>,
+    quit: Arc<RwLock<bool>>,
+    core_id: Option<usize>,
+    cne_uids: RwLock<HashSet<i32>>,
+    sender: SyncSender<PacketSendData>,
+}
+
+pub struct CndpUdpWriterReceiverChannel {
+    quit: Arc<RwLock<bool>>,
+    lport: Port,
+    core_id: Option<usize>,
+    receiver: Receiver<PacketSendData>,
+}
+
+struct CndpUdpCommon {}
+
+#[derive(Clone)]
+pub struct CndpUdpSimple {}
+
+#[derive(Clone)]
+pub struct CndpUdpSyncChannel {}
+
+impl UDP for CndpUdpSimple {
+    type Error = CndpError;
+    type Endpoint = CndpEndpoint;
+    type Reader = CndpUdpReader;
+    type Writer = CndpUdpWriter;
+}
+
+impl UDP for CndpUdpSyncChannel {
+    type Error = CndpError;
+    type Endpoint = CndpEndpoint;
+    type Reader = CndpUdpReader;
+    type Writer = CndpUdpWriterSenderChannel;
+}
+
+impl CndpUdpCommon {
+    const READ_SLEEP_TIME_IN_MICROS: u64 = 20;
+    const READ_BURST_PKTS: u16 = 128;
+    const WRITE_THRESHOLD_NUM_PKTS: usize = 32;
+    const WRITE_WAIT_DURATION_IN_MICROS: u64 = 10;
+    const WRITE_CALLBACK_TIMER_DURATION_IN_MICROS: u64 = 100;
+}
+
+pub struct CneRegister {
+    pub cne_uid: i32,
+}
+
+impl CneRegister {
+    pub fn new(s: &str, core_id: Option<usize>) -> CneRegister {
+        let cne = CneInstance::get_instance();
+        let cne_uid = cne.register_thread(s).unwrap_or(-1);
+        if cne_uid > 0 {
+            if let Some(core_id) = core_id {
+                core_affinity::set_for_current(core_affinity::CoreId { id: core_id });
+            }
+        }
+        CneRegister { cne_uid: cne_uid }
+    }
+}
+
+impl Reader<CndpEndpoint> for CndpUdpReader {
+    type Error = CndpError;
+    fn read(&mut self, buf: &mut [u8]) -> Result<(usize, CndpEndpoint), Self::Error> {
+        // If this function is called from a Wireguard Rust thread register it with CNDP
+        let register = CneRegister::new("CndpUdpReader", self.core_id);
+        if register.cne_uid > 0 {
+            let mut cne_uids = self.cne_uids.write().unwrap();
+            (*cne_uids).insert(register.cne_uid);
+        }
+        // Loop till we get atleast 1 packet or thread quits.
+        loop {
+            if CndpUdpCommon::has_quit(&self.quit) {
+                log::debug!("Cndp Reader quitted");
+                return Err(CndpError::Disconnected);
+            }
+            // Get lport for fwd thread.
+            let lport = self.lport.clone();
+            let (udp_payload_len, endpoint) = self.read_lport(buf, &lport);
+            if udp_payload_len > 0 {
+                return Ok((udp_payload_len, endpoint));
+            } else {
+                // If there are no UDP packets then sleep for sometime.
+                // This will reduce CPU utilization instead of reading in tight loop
+                // and keeping CPU busy at 100%.
+                if self.last_num_pkts_read == 0 {
+                    thread::sleep(Duration::from_micros(
+                        CndpUdpCommon::READ_SLEEP_TIME_IN_MICROS,
+                    ));
+                }
+            }
+        }
+    }
+}
+
+impl CndpUdpReader {
+    fn read_lport(&mut self, buf: &mut [u8], lport: &Port) -> (usize, CndpEndpoint) {
+        if self.last_num_pkts_read == 0 {
+            // Get burst of RX packets.
+            //let mut rx_pkts = self.rx_pkts.lock().unwrap();
+            let rx_pkts = &mut self.rx_pkts;
+            self.last_num_pkts_read =
+                match lport.rx_burst(&mut rx_pkts[..CndpUdpCommon::READ_BURST_PKTS as usize]) {
+                    Ok(pkts_read) => pkts_read,
+                    Err(e) => {
+                        log::error!("Error reading UDP packets : {}", e.to_string());
+                        0
+                    }
+                };
+            if self.last_num_pkts_read > 0 {
+                self.cur_pkt_index = 0;
+                log::debug!(
+                    "Read bulk {} UDP Packets at time {}",
+                    self.last_num_pkts_read,
+                    SystemTime::now()
+                        .duration_since(std::time::UNIX_EPOCH)
+                        .unwrap()
+                        .as_micros()
+                );
+            }
+        }
+
+        // Process RX packet.
+        if self.last_num_pkts_read > 0 {
+            // Get a single RX pktmbuf.
+            let rx_pkts = &mut self.rx_pkts;
+            let pkt = &rx_pkts[self.cur_pkt_index as usize];
+            self.cur_pkt_index = self.cur_pkt_index + 1;
+            // Parse pktmbuf to get UDP payload, length and endpoint.
+            let (udp_payload_len, endpoint) = CndpUdpCommon::parse_packet(buf, pkt);
+            // If all packets are processed free them.
+            log::debug!(
+                "cur_pkt_index = {},  last_num_pkts_read = {}",
+                self.cur_pkt_index,
+                self.last_num_pkts_read
+            );
+            if self.cur_pkt_index == self.last_num_pkts_read as i32 {
+                // Free RX buffers.
+                let ret =
+                    Packet::free_packet_buffer(&mut rx_pkts[..self.last_num_pkts_read as usize]);
+                if let Err(e) = ret {
+                    log::error!("{}", e.to_string());
+                    return (0, CndpEndpoint::new(None, None, None));
+                }
+                self.cur_pkt_index = -1;
+                self.last_num_pkts_read = 0;
+            }
+            return (udp_payload_len as usize, endpoint);
+        }
+        return (0, CndpEndpoint::new(None, None, None));
+    }
+}
+
+impl Drop for CndpUdpReader {
+    fn drop(&mut self) {
+        log::debug!("CndpUdpReader drop");
+        let cne_uids = self.cne_uids.write().unwrap();
+        CndpUdpCommon::unregister_cne_uids(&(*cne_uids));
+    }
+}
+
+impl Writer<CndpEndpoint> for CndpUdpWriter {
+    type Error = CndpError;
+    fn write(&self, buf: Vec<u8>, dst: &mut CndpEndpoint) -> Result<(), Self::Error> {
+        // If this function is called from a Wireguard Rust thread register it with CNDP.
+        let register = CneRegister::new("CndpUdpWriter", None);
+        if register.cne_uid > 0 {
+            let mut cne_uids = self.cne_uids.write().unwrap();
+            (*cne_uids).insert(register.cne_uid);
+        }
+        if CndpUdpCommon::has_quit(&self.quit) {
+            log::debug!("Cndp Writer quitted");
+            return Err(CndpError::Disconnected);
+        }
+        // Get lport for fwd thread.
+        let lport = &self.lport;
+        let ret = self.write_lport(buf, dst, lport);
+        if ret < 0 {
+            log::error!("Cndp Writer failed");
+            return Err(CndpError::WriterError);
+        }
+        Ok(())
+    }
+}
+
+impl CndpUdpWriter {
+    fn write_lport(&self, buf: Vec<u8>, dst: &mut CndpEndpoint, lport: &Port) -> i32 {
+        if dst.ip.is_none() {
+            log::debug!("CndpUdpWriter: Dst ip address is not set: dst = {:?}", dst);
+            return -1;
+        }
+        if dst.port.is_none() {
+            log::debug!("CndpUdpWriter: Dst port is not set");
+            return -1;
+        }
+        if dst.mac.is_none() {
+            let mut cur_dst_mac_map = self.dst_mac_map.write().unwrap();
+            let dst_ip = dst.ip.unwrap();
+            // If dst_mac for this dst_ip is not in map get it via ARP.
+            if !(*cur_dst_mac_map).contains_key(&dst_ip) {
+                let dst_ipv4 = match dst_ip {
+                    IpAddr::V4(ip) => ip,
+                    _ => unreachable!(),
+                };
+                let iface_name = self.iface_name.as_ref();
+                log::debug!(
+                    "iface_name: {}, dst_ipv4 = {}",
+                    iface_name.unwrap().to_owned(),
+                    dst_ipv4
+                );
+                let (_, dst_mac) =
+                    CndpPacketUtil::get_mac_through_arp(&iface_name.unwrap(), dst_ipv4);
+                if let Some(dst_mac) = dst_mac {
+                    log::debug!("dst mac from ARP = {}", dst_mac);
+                    // Store dst_mac in map.
+                    (*cur_dst_mac_map).insert(dst_ip, dst_mac);
+                    log::debug!("stored dst mac in map");
+                } else {
+                    log::debug!("CndpUdpWriter: Dst mac couldn't be determined");
+                    return -1;
+                }
+            }
+            let dst_mac = (*cur_dst_mac_map).get(&dst_ip).expect("Dst mac not found");
+            dst.mac = Some(*dst_mac);
+        }
+        let mut tx_pkts = [Packet::default(); Packet::MAX_BURST];
+        let num_pkts_to_send = 1;
+        let n_pkts = match lport.prepare_tx_packets(&mut tx_pkts[..num_pkts_to_send]) {
+            Ok(n_pkts) => n_pkts,
+            Err(_e) => 0,
+        };
+        // Send TX packets.
+        if n_pkts > 0 {
+            // Get a single TX pktmbuf.
+            let pkt = &mut tx_pkts[0];
+            // Update pkt with UDP data (payload + ip/udp/eth headers).
+            let ret = CndpUdpCommon::update_packet(&buf, pkt, &self.endpoint.unwrap(), dst);
+            if ret < 0 {
+                log::error!("update_pkt failed");
+                return -1;
+            }
+
+            let _n = match lport.tx_burst(&mut tx_pkts[..num_pkts_to_send]) {
+                Ok(n) => n,
+                Err(e) => {
+                    log::error!("Error sending packets {} ", e.to_string());
+                    0
+                }
+            };
+        }
+        return 0;
+    }
+}
+
+impl Drop for CndpUdpWriter {
+    fn drop(&mut self) {
+        log::debug!("CndpUdpWriter drop");
+        let cne_uids = self.cne_uids.write().unwrap();
+        CndpUdpCommon::unregister_cne_uids(&(*cne_uids));
+    }
+}
+
+impl CndpUdpCommon {
+    pub fn get_json_data(port: u16) -> CndpUdpJsonData {
+        // Parse toml.
+        // Get wg_cndp.toml file path.
+        // Assumption is that toml file is copied in same directory as executable. This has to be
+        // either done manually or via some script.
+        let mut cndp_toml_dir = std::env::current_exe().expect("Can't find path to executable");
+        cndp_toml_dir.pop();
+        cndp_toml_dir.push("wg_cndp.toml");
+        let toml_contents =
+            fs::read_to_string(cndp_toml_dir.to_str().unwrap()).expect("Unable to read toml file");
+        // Convert toml as Map<String, Value>
+        let toml_map = toml_contents
+            .parse::<Value>()
+            .ok()
+            .and_then(|r| match r {
+                Value::Table(table) => Some(table),
+                _ => None,
+            })
+            .unwrap_or(Map::new());
+
+        // Jsonc file.
+        let jsonc_file = match toml_map.get("jsonc") {
+            Some(v) => String::from(v.as_str().expect("jsonc should be string")),
+            None => panic!("jsonc is mandatory"),
+        };
+
+        // Get CNE instance.
+        let cne = CneInstance::get_instance();
+
+        // Configure CNE.
+        if let Err(e) = cne.configure(&jsonc_file) {
+            panic!("Error configuring CNE: {}", e.to_string());
+        }
+
+        // Get CNE port from index 0 to read packets.
+        let lport = cne.get_port(0);
+
+        // Check if port is valid.
+        if let Err(ref e) = lport {
+            log::error!("{}", e.to_string());
+            // Cleanup and exit.
+            if let Err(e) = cne.cleanup() {
+                log::error!("{}", e.to_string());
+            }
+        }
+        let lport_reader = lport.unwrap();
+
+        let lport_reader_info = lport_reader.get_port_details().unwrap();
+
+        // Get interface details
+        let (iface_name, src_mac, src_ip) =
+            Self::get_interface_details(&lport_reader_info.netdev.unwrap());
+        let bind_endpoint = CndpEndpoint::new(src_ip, Some(port), src_mac);
+        let reader_thread_coreid = match Self::read_config(&toml_map, "reader_thread_coreid") {
+            Some(v) => Some(v.as_integer().expect("core id should be integer") as usize),
+            None => None,
+        };
+
+        // Get CNE port from index 1 to write packets.
+        let lport = cne.get_port(1);
+
+        // Check if port is valid.
+        if let Err(ref e) = lport {
+            log::error!("{}", e.to_string());
+            // Cleanup and exit.
+            if let Err(e) = cne.cleanup() {
+                log::error!("{}", e.to_string());
+            }
+        }
+        let lport_writer = lport.unwrap();
+        let writer_thread_coreid = match Self::read_config(&toml_map, "writer_thread_coreid") {
+            Some(v) => Some(v.as_integer().expect("core id should be integer") as usize),
+            None => None,
+        };
+        // Create CndpJsonBind return value.
+        let json_data = CndpUdpJsonData {
+            iface_name: iface_name,
+            endpoint: Some(bind_endpoint),
+            lport_reader: lport_reader,
+            lport_writer: lport_writer,
+            reader_core_id: reader_thread_coreid,
+            writer_core_id: writer_thread_coreid,
+        };
+        return json_data;
+    }
+
+    pub fn read_config(toml_map: &Map<String, Value>, key: &str) -> Option<Value> {
+        let val = match toml_map.get(key) {
+            Some(v) => Some(v.clone()),
+            None => None,
+        };
+        return val;
+    }
+
+    pub fn get_interface_details(
+        netdev: &str,
+    ) -> (Option<String>, Option<MacAddr>, Option<IpAddr>) {
+        log::debug!("netdev = {}", netdev);
+        let src_ip = CndpPacketUtil::get_ip_addr_from_ifname(netdev);
+        log::debug!("ipv4_addr = {:?}", src_ip);
+        let src_mac = CndpPacketUtil::get_mac_from_ifname(netdev);
+        log::debug!("src_mac = {:?}", src_mac);
+        return (Some(String::from(netdev)), src_mac, src_ip);
+    }
+
+    pub fn parse_packet(buf: &mut [u8], pkt: &Packet) -> (usize, CndpEndpoint) {
+        // Get pkt data.
+        let pkt_data = pkt.get_data();
+        if pkt_data.is_err() {
+            log::debug!("Cndp Reader pktmbuf data is null");
+            return (0, CndpEndpoint::new(None, None, None));
+        };
+        let pkt_data = pkt_data.unwrap();
+        // Create CNDP packet structure.
+        let mut cndp_eth_packet = CndpPacket::new(pkt_data).unwrap();
+        let ret = cndp_eth_packet.parse_eth_udp_tcp_packet();
+        if ret < 0 {
+            log::debug!("Malformed cndp_ethernet_packet");
+            return (0, CndpEndpoint::new(None, None, None));
+        }
+        log::debug!("Read cndp_ethernet_packet = {}", cndp_eth_packet);
+        if cndp_eth_packet.src_ip.is_none() || cndp_eth_packet.dst_ip.is_none() {
+            log::debug!("Src ip or Dst ip is not set");
+            return (0, CndpEndpoint::new(None, None, None));
+        }
+        if cndp_eth_packet.src_port.is_none() || cndp_eth_packet.dst_port.is_none() {
+            log::debug!("Src port or Dst port is not set");
+            return (0, CndpEndpoint::new(None, None, None));
+        }
+        let (udp_payload, udp_payload_len) = cndp_eth_packet.get_udp_payload_ptr();
+        if udp_payload_len > 0 {
+            let udp_payload = udp_payload.unwrap();
+            if udp_payload.is_null() {
+                // UDP payload should not be null if udp_payload_len > 0
+                panic!("UDP payload is null when UDP payload length > 0");
+            }
+            if udp_payload_len < buf.len() {
+                let p = unsafe { slice::from_raw_parts(udp_payload, udp_payload_len as usize) };
+                buf[..udp_payload_len as usize].copy_from_slice(&p[..]);
+            } else {
+                log::error!(
+                    "UDP Payload length {} is more than buffer length {}",
+                    udp_payload_len,
+                    buf.len()
+                );
+                return (0, CndpEndpoint::new(None, None, None));
+            }
+        } else {
+            log::debug!("Cndp Reader UDP payload len = 0");
+        }
+        let endpoint = CndpEndpoint::new(
+            cndp_eth_packet.src_ip,
+            cndp_eth_packet.src_port,
+            cndp_eth_packet.src_mac,
+        );
+        log::debug!(
+            "Read 1 UDP Payload(size = {}), Ethernet Packet(size = {}) at time {}",
+            udp_payload_len,
+            pkt_data.len(),
+            SystemTime::now()
+                .duration_since(std::time::UNIX_EPOCH)
+                .unwrap()
+                .as_micros()
+        );
+        return (udp_payload_len as usize, endpoint);
+    }
+
+    pub fn update_packet(
+        buf: &[u8],
+        pkt: &mut Packet,
+        src: &CndpEndpoint,
+        dst: &CndpEndpoint,
+    ) -> i32 {
+        // Get total length of packet.
+        let data_len = CndpPacketUtil::get_eth_udp_packet_len(buf.len()) as u16;
+        // Set pkt data len.
+        let ret = pkt.set_data_len(data_len);
+        if let Err(e) = ret {
+            log::error!("{}", e.to_string());
+            return -1;
+        }
+        // Get pkt data.
+        let pkt_data = pkt.get_data_mut();
+        if pkt_data.is_err() {
+            log::debug!("update_pktmbuf: pktmbuf data is null");
+            return -1;
+        };
+        let pkt_data = pkt_data.unwrap();
+        // Create CNDP packet structure.
+        let mut cndp_eth_packet = MutableCndpPacket::new(pkt_data).unwrap();
+        // Update CNDP packet.
+        cndp_eth_packet.update_eth_udp_packet(
+            src.mac.unwrap(),
+            dst.mac.unwrap(),
+            src.ip.unwrap(),
+            dst.ip.unwrap(),
+            src.port.unwrap(),
+            dst.port.unwrap(),
+            buf,
+        );
+        return 0;
+    }
+
+    fn send_pkts(pkts: &mut Vec<PacketSendData>, lport: &Port) -> i32 {
+        let mut tx_pkts = [Packet::default(); Packet::MAX_BURST];
+        let num_pkts_to_send = pkts.len();
+        let n_pkts = match lport.prepare_tx_packets(&mut tx_pkts[..num_pkts_to_send]) {
+            Ok(n_pkts) => n_pkts,
+            Err(_e) => 0,
+        };
+        if n_pkts < num_pkts_to_send as u16 {
+            log::debug!("Cannot allocate enough buffers to send all packets");
+            log::debug!("Requested = {}, Allocated = {}", num_pkts_to_send, n_pkts);
+        }
+        if n_pkts > 0 {
+            log::debug!(
+                "Send {} UDP packets at time {}",
+                n_pkts,
+                SystemTime::now()
+                    .duration_since(std::time::UNIX_EPOCH)
+                    .unwrap()
+                    .as_micros()
+            );
+            for i in 0..n_pkts {
+                // Get data buf.
+                // Remove packet from front of the list and move the ownership out of the list.
+                let pkt = pkts.remove(0 as usize);
+                let buf = pkt.buf;
+                let src_endpoint = pkt.src_endpoint;
+                let dst_endpoint = pkt.dst_endpoint;
+                // Get a single TX packet.
+                let pkt = &mut tx_pkts[i as usize];
+                // Update pkt with UDP data (payload + ip/udp/eth headers).
+                let ret = CndpUdpCommon::update_packet(&buf, pkt, &src_endpoint, &dst_endpoint);
+                if ret < 0 {
+                    log::error!("update_packet failed");
+                    return -1;
+                }
+            }
+            let n = match lport.tx_burst(&mut tx_pkts[..n_pkts as usize]) {
+                Ok(n) => n,
+                Err(e) => {
+                    log::error!("Error sending packets {} ", e.to_string());
+                    0
+                }
+            };
+            log::debug!(
+                "Sent {} UDP packets at time {}",
+                n,
+                SystemTime::now()
+                    .duration_since(std::time::UNIX_EPOCH)
+                    .unwrap()
+                    .as_micros()
+            );
+            // Free packets which are not sent.
+            if n < n_pkts {
+                let ret = Packet::free_packet_buffer(&mut tx_pkts[n as usize..n_pkts as usize]);
+                if let Err(e) = ret {
+                    log::error!("{}", e.to_string());
+                    return -1;
+                }
+            }
+        }
+        return 0;
+    }
+
+    pub fn unregister_cne_uids(cne_uids: &HashSet<i32>) {
+        for cne_uid in cne_uids {
+            let cne = CneInstance::get_instance();
+            if cne.unregister_thread(*cne_uid).is_err() {
+                log::error!("cne_unregister failed for cne_uid = {}", *cne_uid);
+            }
+        }
+    }
+
+    pub fn has_quit(quit: &Arc<RwLock<bool>>) -> bool {
+        let has_quit = quit.read().unwrap();
+        *has_quit
+    }
+}
+
+impl PlatformUDP for CndpUdpSimple {
+    type Owner = CndpOwner;
+    fn bind(port: u16) -> Result<(Vec<Self::Reader>, Self::Writer, Self::Owner), Self::Error> {
+        log::info!("Wireguard called bind at port {}", port);
+        // Get Cndp UDP Json Data.
+        let json_data = CndpUdpCommon::get_json_data(port);
+        // Create Arc RwLock.
+        let quit_arc_mutex = Arc::new(RwLock::new(false));
+        // Create Cndp UDP Reader.
+        let reader = CndpUdpReader {
+            iface_name: json_data.iface_name.clone(),
+            endpoint: json_data.endpoint,
+            quit: Arc::clone(&quit_arc_mutex),
+            lport: json_data.lport_reader,
+            rx_pkts: vec![cne::packet::Packet::default(); CndpUdpCommon::READ_BURST_PKTS as usize],
+            core_id: json_data.reader_core_id,
+            cne_uids: RwLock::new(HashSet::new()),
+            cur_pkt_index: -1,
+            last_num_pkts_read: 0,
+        };
+        let readers: Vec<Self::Reader> = vec![reader];
+
+        // Create Cndp UDP Writer.
+        let writer = CndpUdpWriter {
+            iface_name: json_data.iface_name.clone(),
+            endpoint: json_data.endpoint,
+            dst_mac_map: RwLock::new(HashMap::new()),
+            quit: Arc::clone(&quit_arc_mutex),
+            lport: json_data.lport_writer,
+            core_id: json_data.writer_core_id,
+            cne_uids: RwLock::new(HashSet::new()),
+        };
+
+        let owner = CndpOwner {
+            quit: Arc::clone(&quit_arc_mutex),
+        };
+
+        return Ok((readers, writer, owner));
+    }
+}
+
+impl PlatformUDP for CndpUdpSyncChannel {
+    type Owner = CndpOwner;
+    fn bind(port: u16) -> Result<(Vec<Self::Reader>, Self::Writer, Self::Owner), Self::Error> {
+        log::info!("Wireguard called bind at port {}", port);
+        // Get Cndp UDP Json Data.
+        let json_data = CndpUdpCommon::get_json_data(port);
+        // Create Arc RwLock.
+        let quit_arc_mutex = Arc::new(RwLock::new(false));
+        // Create Cndp UDP Reader.
+        let reader = CndpUdpReader {
+            iface_name: json_data.iface_name.clone(),
+            endpoint: json_data.endpoint,
+            quit: Arc::clone(&quit_arc_mutex),
+            lport: json_data.lport_reader,
+            rx_pkts: vec![cne::packet::Packet::default(); CndpUdpCommon::READ_BURST_PKTS as usize],
+            core_id: json_data.reader_core_id,
+            cne_uids: RwLock::new(HashSet::new()),
+            cur_pkt_index: -1,
+            last_num_pkts_read: 0,
+        };
+        let readers: Vec<Self::Reader> = vec![reader];
+
+        // Create Cndp UDP Writer channel.
+        // UDP writer send channel thread, sends UDP packet to the channel.
+        // UDP writer receive channel thread, reads UDP packet from channel,
+        // creates ethernet packet, accumulates the packets till a given
+        // threshold or till timeout occurs and then sends the burst of packet to peer node.
+        let (sender_w, receiver_w) = sync_channel::<PacketSendData>(1024);
+        // Create Arc RwLock.
+        //let fwd_port_thd_writer_arc_mutex = Arc::new(RwLock::new(json_data.fwd_port_thd_writer));
+        let writer_recv = CndpUdpWriterReceiverChannel {
+            quit: Arc::clone(&quit_arc_mutex),
+            lport: json_data.lport_writer,
+            core_id: json_data.writer_core_id,
+            receiver: receiver_w,
+        };
+        let writer = CndpUdpWriterSenderChannel {
+            iface_name: json_data.iface_name.clone(),
+            endpoint: json_data.endpoint,
+            dst_mac_map: RwLock::new(HashMap::new()),
+            quit: Arc::clone(&quit_arc_mutex),
+            core_id: json_data.writer_core_id,
+            cne_uids: RwLock::new(HashSet::new()),
+            sender: sender_w,
+        };
+        let owner = CndpOwner {
+            quit: Arc::clone(&quit_arc_mutex),
+        };
+        // UDP writer receive channel thread.
+        thread::spawn(move || {
+            writer_recv.write();
+        });
+
+        return Ok((readers, writer, owner));
+    }
+}
+
+impl Writer<CndpEndpoint> for CndpUdpWriterSenderChannel {
+    type Error = CndpError;
+    fn write(&self, buf: Vec<u8>, dst: &mut CndpEndpoint) -> Result<(), Self::Error> {
+        // If this function is called from a Wireguard Rust thread register it with CNDP.
+        let register = CneRegister::new("CndpUdpWriterSenderChannel", None);
+        if register.cne_uid > 0 {
+            let mut cne_uids = self.cne_uids.write().unwrap();
+            (*cne_uids).insert(register.cne_uid);
+        }
+        if CndpUdpCommon::has_quit(&self.quit) {
+            log::debug!("Cndp Writer quitted");
+            return Err(CndpError::Disconnected);
+        }
+        if dst.ip.is_none() {
+            log::debug!("Dst ip address is not set: dst = {:?}", dst);
+            return Err(CndpError::WriterError);
+        }
+        if dst.port.is_none() {
+            log::debug!("Dst port is not set");
+            return Err(CndpError::WriterError);
+        }
+        if dst.mac.is_none() {
+            let mut cur_dst_mac_map = self.dst_mac_map.write().unwrap();
+            let dst_ip = dst.ip.unwrap();
+            // If dst_mac for this dst_ip is not in map get it via ARP.
+            if !(*cur_dst_mac_map).contains_key(&dst_ip) {
+                let dst_ipv4 = match dst_ip {
+                    IpAddr::V4(ip) => ip,
+                    _ => unreachable!(),
+                };
+                let iface_name = self.iface_name.as_ref();
+                let (_, dst_mac) =
+                    CndpPacketUtil::get_mac_through_arp(&iface_name.unwrap(), dst_ipv4);
+                if let Some(dst_mac) = dst_mac {
+                    log::debug!("dst mac from ARP = {}", dst_mac);
+                    // Store dst_mac in map.
+                    (*cur_dst_mac_map).insert(dst_ip, dst_mac);
+                } else {
+                    log::debug!("Dst mac couldn't be determined");
+                    return Err(CndpError::WriterError);
+                }
+            }
+            let dst_mac = (*cur_dst_mac_map).get(&dst_ip).expect("Dst mac no found");
+            dst.mac = Some(*dst_mac);
+        }
+        // Get lport for fwd thread.
+        let pkt_send_data = PacketSendData {
+            buf: buf,
+            src_endpoint: self.endpoint.unwrap(),
+            dst_endpoint: *dst,
+        };
+        match self.sender.send(pkt_send_data) {
+            Err(_) => {
+                log::debug!("CndpUdpWriterSenderChannel: Send Error");
+                return Err(CndpError::WriterError);
+            }
+            Ok(_) => {
+                log::debug!("CndpUdpWriterSenderChannel: Send UDP data");
+                log::debug!(
+                    "CndpUdpWriterSenderChannel Send UDP 1 packet at time {}",
+                    SystemTime::now()
+                        .duration_since(std::time::UNIX_EPOCH)
+                        .unwrap()
+                        .as_micros()
+                );
+            }
+        }
+        Ok(())
+    }
+}
+
+impl<'a> Drop for CndpUdpWriterSenderChannel {
+    fn drop(&mut self) {
+        log::debug!("CndpUdpWriterSenderChannel drop");
+        let cne_uids = self.cne_uids.write().unwrap();
+        CndpUdpCommon::unregister_cne_uids(&(*cne_uids));
+        log::debug!(
+            "CndpUdpWriterSenderChannel unregister {} cne_uids",
+            (*cne_uids).len()
+        );
+    }
+}
+
+impl CndpUdpWriterReceiverChannel {
+    fn write(&self) {
+        let register = CneRegister::new("CndpUdpWriterReceiverChannel", self.core_id);
+        let mut num_pkts_received = 0;
+        let mut pkts = Vec::new();
+        let wait_time = Duration::from_micros(CndpUdpCommon::WRITE_WAIT_DURATION_IN_MICROS);
+        let mut send_packets = false;
+        loop {
+            if CndpUdpCommon::has_quit(&self.quit) {
+                log::debug!("Cndp Writer quitted");
+                break;
+            }
+            // If number of packets received is greater than a threshold
+            // or timeout occurs send packets received (if any).
+            match self.receiver.recv_timeout(wait_time) {
+                Ok(data) => {
+                    log::debug!(
+                        "CndpUdpWriterReceiverChannel: Receive UDP data, num_pkts_received= {}",
+                        num_pkts_received
+                    );
+                    num_pkts_received += 1;
+                    pkts.push(data);
+                    send_packets = num_pkts_received >= CndpUdpCommon::WRITE_THRESHOLD_NUM_PKTS;
+                }
+                Err(RecvTimeoutError::Timeout) => {
+                    // Check if there are packets to be send.
+                    if !pkts.is_empty() {
+                        log::debug!("CndpUdpWriterReceiverChannel: Timeout. Send pending packets");
+                        send_packets = true;
+                    }
+                }
+                Err(RecvTimeoutError::Disconnected) => {
+                    log::debug!("CndpUdpWriterReceiverChannel : Disconnected");
+                    break;
+                }
+            }
+            if send_packets {
+                let lport = self.lport.clone();
+                CndpUdpCommon::send_pkts(&mut pkts, &lport);
+                // Reset.
+                pkts.clear();
+                num_pkts_received = 0;
+                send_packets = false;
+            }
+        }
+        // Unregister this thread from CNDP.
+        let cne = CneInstance::get_instance();
+        cne.unregister_thread(register.cne_uid).unwrap();
+    }
+}
+
+
+pub struct CndpOwner {
+    quit: Arc<RwLock<bool>>,
+}
+
+impl Owner for CndpOwner {
+    type Error = CndpError;
+
+    fn set_fwmark(&mut self, _value: Option<u32>) -> Result<(), Self::Error> {
+        Ok(())
+    }
+
+    fn get_port(&self) -> u16 {
+        0
+    }
+}
+
+impl Drop for CndpOwner {
+    fn drop(&mut self) {
+        log::debug!("CndpOwner drop");
+
+        // Quit CNE.
+        let mut quit = self.quit.write().unwrap();
+        *quit = true;
+
+        let cne = CneInstance::get_instance();
+        // Cleanup CNE.
+        log::info!("Cleanup CNE");
+        let ret = cne.cleanup();
+        if let Err(e) = ret {
+            log::error!("{}", e.to_string());
+        }
+    }
+}
diff --git a/src/platform/linux/cndp/wg_cndp.toml b/src/platform/linux/cndp/wg_cndp.toml
new file mode 100644
index 0000000..4c42b12
--- /dev/null
+++ b/src/platform/linux/cndp/wg_cndp.toml
@@ -0,0 +1,32 @@
+# SPDX-License-Identifier: BSD-3-Clause
+# Copyright(c) 2019-2021 Intel Corporation.
+
+# jsonc absolute file path to configure CNDP.
+#jsonc = "/home/manoj/wireguard/cndp/networking.dataplane.cndp.thirdparty.wireguard-rs/src/platform/linux/cndp/fwd.jsonc"
+jsonc = "/home/manoj/wireguard/cndp/networking.dataplane.cndp.thirdparty.wireguard-rs/src/platform/linux/cndp/cndp_pkt_fwd.jsonc"
+
+# UDP reader thread core id affinity. If it's not present then core affinity won't be set.
+reader_thread_coreid = 25
+
+# UDP writer thread core id affinity. If it's not present then core affinity won't be set.
+writer_thread_coreid = 35
+
+# Wireguard TUN reader core id affinity. If it's not present then core affinity won't be set.
+tun_reader_thread_coreid = 22
+
+# Number of workers (To do encrypt/decrypt)
+wg_num_workers = 4
+
+# Wireguard worker threads core id affinity base. Each worker thread will be assigned a core affinity
+# starting from base and will be incremented by 1. For example, if there are 4 worker threads and base
+# core id is 26, then core affinity for worker threads will be set on core ids 26,27,28 and 29.
+# If it's not present then core affinity won't be set.
+wg_worker_thread_base_coreid = 26
+
+# Packet reader thread core id affinity. If it's not present then core affinity won't be set.
+# This setting is required only for custom wireguard+cndp app.
+packet_reader_thread_coreid = 36
+# Packet writer thread core id affinity. If it's not present then core affinity won't be set.
+# This setting is required only for custom wirguard+cndp app.
+packet_writer_thread_coreid = 37
+packet_writer_sender_channel_thread_coreid = 38
diff --git a/src/platform/linux/mod.rs b/src/platform/linux/mod.rs
index d28391e..26e9b5f 100644
--- a/src/platform/linux/mod.rs
+++ b/src/platform/linux/mod.rs
@@ -4,4 +4,11 @@ mod udp;
 
 pub use tun::LinuxTun as Tun;
 pub use uapi::LinuxUAPI as UAPI;
+#[cfg(all(target_os = "linux", not(feature = "cndp")))]
 pub use udp::LinuxUDP as UDP;
+
+#[cfg(all(target_os = "linux", feature = "cndp"))]
+pub mod cndp;
+#[cfg(all(target_os = "linux", feature = "cndp"))]
+pub use cndp::udp::CndpUdpSimple as UDP;
+//pub use cndp::udp::CndpUdpSyncChannel as UDP;
diff --git a/src/platform/linux/tun.rs b/src/platform/linux/tun.rs
index 82fada1..062a4ae 100644
--- a/src/platform/linux/tun.rs
+++ b/src/platform/linux/tun.rs
@@ -114,7 +114,7 @@ impl Writer for LinuxTunWriter {
     }
 }
 
-fn get_ifindex(name: &[u8; libc::IFNAMSIZ]) -> i32 {
+pub fn get_ifindex(name: &[u8; libc::IFNAMSIZ]) -> i32 {
     debug_assert_eq!(
         name[libc::IFNAMSIZ - 1],
         0,
@@ -129,7 +129,7 @@ fn get_ifindex(name: &[u8; libc::IFNAMSIZ]) -> i32 {
     idx as i32
 }
 
-fn get_mtu(name: &[u8; libc::IFNAMSIZ]) -> Result<usize, LinuxTunError> {
+pub fn get_mtu(name: &[u8; libc::IFNAMSIZ]) -> Result<usize, LinuxTunError> {
     #[repr(C)]
     struct arg {
         name: [u8; libc::IFNAMSIZ],
@@ -267,7 +267,7 @@ impl LinuxTunStatus {
     const RTNLGRP_IPV4_IFADDR: libc::c_uint = 5;
     const RTNLGRP_IPV6_IFADDR: libc::c_uint = 9;
 
-    fn new(name: [u8; libc::IFNAMSIZ]) -> Result<LinuxTunStatus, LinuxTunError> {
+    pub fn new(name: [u8; libc::IFNAMSIZ]) -> Result<LinuxTunStatus, LinuxTunError> {
         // create netlink socket
         let fd = unsafe { libc::socket(libc::AF_NETLINK, libc::SOCK_RAW, libc::NETLINK_ROUTE) };
         if fd < 0 {
diff --git a/src/platform/linux/udp.rs b/src/platform/linux/udp.rs
index b62d5bf..f953e2f 100644
--- a/src/platform/linux/udp.rs
+++ b/src/platform/linux/udp.rs
@@ -308,7 +308,7 @@ impl LinuxUDPReader {
 impl Reader<LinuxEndpoint> for LinuxUDPReader {
     type Error = io::Error;
 
-    fn read(&self, buf: &mut [u8]) -> Result<(usize, LinuxEndpoint), Self::Error> {
+    fn read(&mut self, buf: &mut [u8]) -> Result<(usize, LinuxEndpoint), Self::Error> {
         match self {
             Self::V4(fd) => Self::read4(fd.0, buf),
             Self::V6(fd) => Self::read6(fd.0, buf),
@@ -451,10 +451,10 @@ impl LinuxUDPWriter {
 impl Writer<LinuxEndpoint> for LinuxUDPWriter {
     type Error = io::Error;
 
-    fn write(&self, buf: &[u8], dst: &mut LinuxEndpoint) -> Result<(), Self::Error> {
+    fn write(&self, buf: Vec<u8>, dst: &mut LinuxEndpoint) -> Result<(), Self::Error> {
         match dst {
-            LinuxEndpoint::V4(ref mut end) => Self::write4(self.sock4.0, buf, end),
-            LinuxEndpoint::V6(ref mut end) => Self::write6(self.sock6.0, buf, end),
+            LinuxEndpoint::V4(ref mut end) => Self::write4(self.sock4.0, &buf, end),
+            LinuxEndpoint::V6(ref mut end) => Self::write6(self.sock6.0, &buf, end),
         }
     }
 }
diff --git a/src/platform/udp.rs b/src/platform/udp.rs
index 0b9c823..d8e5c24 100644
--- a/src/platform/udp.rs
+++ b/src/platform/udp.rs
@@ -4,13 +4,13 @@ use std::error::Error;
 pub trait Reader<E: Endpoint>: Send + Sync {
     type Error: Error;
 
-    fn read(&self, buf: &mut [u8]) -> Result<(usize, E), Self::Error>;
+    fn read(&mut self, buf: &mut [u8]) -> Result<(usize, E), Self::Error>;
 }
 
 pub trait Writer<E: Endpoint>: Send + Sync + 'static {
     type Error: Error;
 
-    fn write(&self, buf: &[u8], dst: &mut E) -> Result<(), Self::Error>;
+    fn write(&self, buf: Vec<u8>, dst: &mut E) -> Result<(), Self::Error>;
 }
 
 pub trait UDP: Send + Sync + 'static {
diff --git a/src/wireguard/constants.rs b/src/wireguard/constants.rs
index 4d89d46..e261f88 100644
--- a/src/wireguard/constants.rs
+++ b/src/wireguard/constants.rs
@@ -55,3 +55,6 @@ pub const TIMERS_CAPACITY: usize = 16;
  * Note, this duration need not fit inside the timer wheel.
  */
 pub const TIME_HORIZON: Duration = Duration::from_secs(TIMER_MAX_DURATION.as_secs() * 2);
+
+// Num of worker threads.
+pub const NUM_WORKERS: usize = 4;
diff --git a/src/wireguard/handshake/macs.rs b/src/wireguard/handshake/macs.rs
index f4f5586..f2004dd 100644
--- a/src/wireguard/handshake/macs.rs
+++ b/src/wireguard/handshake/macs.rs
@@ -9,7 +9,7 @@ use x25519_dalek::PublicKey;
 
 // AEAD
 
-use aead::{Aead, NewAead, Payload};
+use chacha20poly1305::aead::{Aead, NewAead, Payload};
 use chacha20poly1305::XChaCha20Poly1305;
 
 // MAC
@@ -56,7 +56,7 @@ macro_rules! MAC {
 
 macro_rules! XSEAL {
     ($key:expr, $nonce:expr, $ad:expr, $pt:expr, $ct:expr) => {{
-        let ct = XChaCha20Poly1305::new(GenericArray::from_slice($key))
+        let ct = XChaCha20Poly1305::new(chacha20poly1305::Key::from_slice($key))
             .encrypt(
                 GenericArray::from_slice($nonce),
                 Payload { msg: $pt, aad: $ad },
@@ -70,7 +70,7 @@ macro_rules! XSEAL {
 macro_rules! XOPEN {
     ($key:expr, $nonce:expr, $ad:expr, $pt:expr, $ct:expr) => {{
         debug_assert_eq!($ct.len(), $pt.len() + SIZE_TAG);
-        XChaCha20Poly1305::new(GenericArray::from_slice($key))
+        XChaCha20Poly1305::new(chacha20poly1305::Key::from_slice($key))
             .decrypt(
                 GenericArray::from_slice($nonce),
                 Payload { msg: $ct, aad: $ad },
diff --git a/src/wireguard/handshake/noise.rs b/src/wireguard/handshake/noise.rs
index 92c8c5f..cb14ad1 100644
--- a/src/wireguard/handshake/noise.rs
+++ b/src/wireguard/handshake/noise.rs
@@ -8,7 +8,7 @@ use blake2::Blake2s;
 use hmac::Hmac;
 
 // AEAD
-use aead::{Aead, NewAead, Payload};
+use chacha20poly1305::aead::{Aead, NewAead, Payload};
 use chacha20poly1305::ChaCha20Poly1305;
 
 use rand_core::{CryptoRng, RngCore};
@@ -112,7 +112,7 @@ macro_rules! KDF3 {
 
 macro_rules! SEAL {
     ($key:expr, $ad:expr, $pt:expr, $ct:expr) => {
-        ChaCha20Poly1305::new(GenericArray::from_slice($key))
+        ChaCha20Poly1305::new(chacha20poly1305::Key::from_slice($key))
             .encrypt(&ZERO_NONCE.into(), Payload { msg: $pt, aad: $ad })
             .map(|ct| $ct.copy_from_slice(&ct))
             .unwrap()
@@ -121,7 +121,7 @@ macro_rules! SEAL {
 
 macro_rules! OPEN {
     ($key:expr, $ad:expr, $pt:expr, $ct:expr) => {
-        ChaCha20Poly1305::new(GenericArray::from_slice($key))
+        ChaCha20Poly1305::new(chacha20poly1305::Key::from_slice($key))
             .decrypt(&ZERO_NONCE.into(), Payload { msg: $ct, aad: $ad })
             .map_err(|_| HandshakeError::DecryptionFailure)
             .map(|pt| $pt.copy_from_slice(&pt))
diff --git a/src/wireguard/router/device.rs b/src/wireguard/router/device.rs
index eeae621..7aba22a 100644
--- a/src/wireguard/router/device.rs
+++ b/src/wireguard/router/device.rs
@@ -14,6 +14,7 @@ use super::messages::{TransportHeader, TYPE_TRANSPORT};
 use super::peer::{new_peer, Peer, PeerHandle};
 use super::types::{Callbacks, RouterError};
 use super::SIZE_MESSAGE_PREFIX;
+use super::CAPACITY_MESSAGE_POSTFIX;
 
 use super::receive::ReceiveJob;
 use super::route::RoutingTable;
@@ -103,7 +104,11 @@ impl<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> Drop
 }
 
 impl<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> DeviceHandle<E, C, T, B> {
-    pub fn new(num_workers: usize, tun: T) -> DeviceHandle<E, C, T, B> {
+    pub fn new(
+        num_workers: usize,
+        tun: T,
+        worker_thread_base_coreid: Option<usize>,
+    ) -> DeviceHandle<E, C, T, B> {
         let (work, mut consumers) = ParallelQueue::new(num_workers, PARALLEL_QUEUE_SIZE);
         let device = Device {
             inner: Arc::new(DeviceInner {
@@ -117,8 +122,22 @@ impl<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> DeviceHandle<
 
         // start worker threads
         let mut threads = Vec::with_capacity(num_workers);
+        let mut core_id: usize = 0;
         while let Some(rx) = consumers.pop() {
-            threads.push(thread::spawn(move || worker(rx)));
+            threads.push(thread::spawn(move || {
+                cfg_if::cfg_if! {
+                    if #[cfg(all(target_os = "linux", feature = "cndp"))] {
+                        // Set core affinity for worker threads starting with worker_thread_base_coreid.
+                        if let Some(worker_thread_base_coreid) = worker_thread_base_coreid {
+                            core_affinity::set_for_current(core_affinity::CoreId {
+                                id: core_id + worker_thread_base_coreid,
+                            });
+                        }
+                    }
+                }
+                worker(rx);
+            }));
+            core_id += 1;
         }
         debug_assert!(num_workers > 0, "zero worker threads");
         debug_assert_eq!(
@@ -134,7 +153,7 @@ impl<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> DeviceHandle<
         }
     }
 
-    pub fn send_raw(&self, msg: &[u8], dst: &mut E) -> Result<(), B::Error> {
+    pub fn send_raw(&self, msg: Vec<u8>, dst: &mut E) -> Result<(), B::Error> {
         let bind = self.state.outbound.read();
         if bind.0 {
             if let Some(bind) = bind.1.as_ref() {
@@ -179,16 +198,15 @@ impl<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> DeviceHandle<
     ///
     /// - msg: IP packet to crypt-key route
     pub fn send(&self, msg: Vec<u8>) -> Result<(), RouterError> {
-        debug_assert!(msg.len() > SIZE_MESSAGE_PREFIX);
+        debug_assert!(msg.len() > (SIZE_MESSAGE_PREFIX + CAPACITY_MESSAGE_POSTFIX));
         log::trace!(
             "send, packet = {}",
-            hex::encode(&msg[SIZE_MESSAGE_PREFIX..])
+            hex::encode(&msg[SIZE_MESSAGE_PREFIX..(msg.len()-CAPACITY_MESSAGE_POSTFIX)])
         );
 
-        // ignore header prefix (for in-place transport message construction)
-        let packet = &msg[SIZE_MESSAGE_PREFIX..];
+        // ignore header prefix and postfix (for in-place transport message construction)
+        let packet = &msg[SIZE_MESSAGE_PREFIX..(msg.len()-CAPACITY_MESSAGE_POSTFIX)];
 
-        // lookup peer based on IP packet destination address
         let peer = self
             .state
             .table
diff --git a/src/wireguard/router/peer.rs b/src/wireguard/router/peer.rs
index 0803b13..5306f31 100644
--- a/src/wireguard/router/peer.rs
+++ b/src/wireguard/router/peer.rs
@@ -8,6 +8,7 @@ use super::device::EncryptionState;
 
 use super::constants::*;
 use super::types::{Callbacks, RouterError};
+use super::CAPACITY_MESSAGE_POSTFIX;
 use super::SIZE_MESSAGE_PREFIX;
 
 use super::queue::Queue;
@@ -222,7 +223,7 @@ impl<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> PeerInner<E,
     /// # Returns
     ///
     /// Unit if packet was sent, or an error indicating why sending failed
-    pub fn send_raw(&self, msg: &[u8]) -> Result<(), RouterError> {
+    pub fn send_raw(&self, msg: Vec<u8>) -> Result<(), RouterError> {
         // send to endpoint (if known)
         match self.endpoint.lock().as_mut() {
             Some(endpoint) => {
@@ -499,7 +500,10 @@ impl<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> PeerHandle<E,
 
     pub fn send_keepalive(&self) {
         log::trace!("peer.send_keepalive");
-        self.peer.send(vec![0u8; SIZE_MESSAGE_PREFIX], false)
+        self.peer.send(
+            vec![0u8; SIZE_MESSAGE_PREFIX + CAPACITY_MESSAGE_POSTFIX],
+            false,
+        )
     }
 
     /// Map a subnet to the peer
diff --git a/src/wireguard/router/queue.rs b/src/wireguard/router/queue.rs
index b266a57..6120575 100644
--- a/src/wireguard/router/queue.rs
+++ b/src/wireguard/router/queue.rs
@@ -41,6 +41,7 @@ impl<J: SequentialJob> Queue<J> {
         self.queue.lock().push_back(job).is_ok()
     }
 
+    #[cfg(all(target_os = "linux", not(feature = "cndp")))]
     pub fn consume(&self) {
         // check if we are the first contender
         let pos = self.contenders.fetch_add(1, Ordering::SeqCst);
@@ -89,6 +90,32 @@ impl<J: SequentialJob> Queue<J> {
             contenders = self.contenders.fetch_sub(contenders, Ordering::SeqCst) - contenders;
         }
     }
+
+    #[cfg(all(target_os = "linux", feature = "cndp"))]
+    pub fn consume(&self) {
+        // handle every ready element
+        loop {
+            let mut queue = self.queue.lock();
+
+            // check if front job is ready
+            match queue.front() {
+                None => break,
+                Some(job) => {
+                    if !job.is_ready() {
+                        break;
+                    }
+                }
+            };
+
+            // take the job out of the queue
+            let job = queue.pop_front().unwrap();
+            debug_assert!(job.is_ready());
+            mem::drop(queue);
+
+            // process element
+            job.sequential_work();
+        }
+    }
 }
 
 #[cfg(test)]
diff --git a/src/wireguard/router/receive.rs b/src/wireguard/router/receive.rs
index 15eb8fb..2ce1adb 100644
--- a/src/wireguard/router/receive.rs
+++ b/src/wireguard/router/receive.rs
@@ -13,6 +13,9 @@ use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, CHACHA20_POLY1305};
 use spin::Mutex;
 use zerocopy::{AsBytes, LayoutVerified};
 
+#[cfg(all(target_os = "linux", feature = "openssl"))]
+use openssl::symm::{decrypt_aead, Cipher};
+
 struct Inner<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> {
     ready: AtomicBool,                       // job status
     buffer: Mutex<(Option<E>, Vec<u8>)>,     // endpoint & ciphertext buffer
@@ -91,16 +94,45 @@ impl<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> ParallelJob
                 let mut nonce = [0u8; 12];
                 debug_assert_eq!(nonce.len(), CHACHA20_POLY1305.nonce_len());
                 nonce[4..].copy_from_slice(header.f_counter.as_bytes());
-                let nonce = Nonce::assume_unique_for_key(nonce);
-                // do the weird ring AEAD dance
-                let key = LessSafeKey::new(
-                    UnboundKey::new(&CHACHA20_POLY1305, &job.state.keypair.recv.key[..]).unwrap(),
-                );
-
-                // attempt to open (and authenticate) the body
-                match key.open_in_place(nonce, Aad::empty(), packet) {
-                    Ok(_) => (),
-                    Err(_) => return false,
+                cfg_if::cfg_if! {
+                    // Use openssl library based decryption which has better peformance.
+                    if #[cfg(all(target_os = "linux", feature = "openssl"))] {
+                        let cipher = Cipher::chacha20_poly1305();
+                        const AAD: [u8; 0] = [];
+                        let tag_offset = packet.len() - SIZE_TAG;
+                        let res = decrypt_aead(
+                            cipher,
+                            &job.state.keypair.recv.key[..],
+                            Some(&nonce),
+                            &AAD,
+                            &packet[..tag_offset],
+                            &packet[tag_offset..],
+                        );
+                        match res {
+                            Ok(plaintext) => {
+                                // Copy plain text back to packet.
+                                // This copy can be avoided after API supports in-place decryption.
+                                packet[..tag_offset].copy_from_slice(&plaintext);
+                            }
+                            Err(_) => {
+                                log::error!("Decryption failed");
+                                return false;
+                            }
+                        }
+                    } else {
+                        let nonce = Nonce::assume_unique_for_key(nonce);
+                        // do the weird ring AEAD dance
+                        let key = LessSafeKey::new(
+                            UnboundKey::new(&CHACHA20_POLY1305, &job.state.keypair.recv.key[..])
+                                .unwrap(),
+                        );
+
+                        // attempt to open (and authenticate) the body
+                        match key.open_in_place(nonce, Aad::empty(), packet) {
+                            Ok(_) => (),
+                            Err(_) => return false,
+                        }
+                    }
                 }
 
                 // check that counter not after reject
diff --git a/src/wireguard/router/send.rs b/src/wireguard/router/send.rs
index 7e14209..88440a9 100644
--- a/src/wireguard/router/send.rs
+++ b/src/wireguard/router/send.rs
@@ -14,9 +14,12 @@ use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, CHACHA20_POLY1305};
 use spin::Mutex;
 use zerocopy::{AsBytes, LayoutVerified};
 
+#[cfg(all(target_os = "linux", feature = "openssl"))]
+use openssl::symm::{encrypt_aead, Cipher};
+
 struct Inner<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> {
     ready: AtomicBool,
-    buffer: Mutex<Vec<u8>>,
+    buffer: Arc<Mutex<Option<Vec<u8>>>>,
     counter: u64,
     keypair: Arc<KeyPair>,
     peer: Peer<E, C, T, B>,
@@ -40,7 +43,7 @@ impl<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> SendJob<E, C,
         peer: Peer<E, C, T, B>,
     ) -> SendJob<E, C, T, B> {
         SendJob(Arc::new(Inner {
-            buffer: Mutex::new(buffer),
+            buffer: Arc::new(Mutex::new(Some(buffer))),
             counter,
             keypair,
             peer,
@@ -68,8 +71,8 @@ impl<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> ParallelJob
         {
             // make space for the tag
             let job = &*self.0;
-            let mut msg = job.buffer.lock();
-            msg.extend([0u8; SIZE_TAG].iter());
+            // Move the vector out of job buffer (take ownership) to encrypt it.
+            let mut msg = job.buffer.lock().take().unwrap();
 
             // cast to header (should never fail)
             let (mut header, packet): (LayoutVerified<&mut [u8], TransportHeader>, &mut [u8]) =
@@ -89,19 +92,53 @@ impl<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> ParallelJob
             let mut nonce = [0u8; 12];
             debug_assert_eq!(nonce.len(), CHACHA20_POLY1305.nonce_len());
             nonce[4..].copy_from_slice(header.f_counter.as_bytes());
-            let nonce = Nonce::assume_unique_for_key(nonce);
-
-            // encrypt contents of transport message in-place
-            let tag_offset = packet.len() - SIZE_TAG;
-            let key = LessSafeKey::new(
-                UnboundKey::new(&CHACHA20_POLY1305, &job.keypair.send.key[..]).unwrap(),
-            );
-            let tag = key
-                .seal_in_place_separate_tag(nonce, Aad::empty(), &mut packet[..tag_offset])
-                .unwrap();
-
-            // append tag
-            packet[tag_offset..].copy_from_slice(tag.as_ref());
+            cfg_if::cfg_if! {
+                // Use openssl library based encryption which has better peformance.
+                if #[cfg(all(target_os = "linux", feature = "openssl"))] {
+                    let cipher = Cipher::chacha20_poly1305();
+                    const AAD: [u8; 0] = [];
+                    let mut tag = vec![0u8; SIZE_TAG];
+                    let tag_offset = packet.len() - SIZE_TAG;
+                    let res = encrypt_aead(
+                        cipher,
+                        &job.keypair.send.key[..],
+                        Some(&nonce),
+                        &AAD,
+                        &packet[..tag_offset],
+                        &mut tag,
+                    );
+                    match res {
+                        Ok(ciphertext) => {
+                            // Copy cipher text back to packet.
+                            // This copy can be avoided after API supports in-place encryption.
+                            packet[..tag_offset].copy_from_slice(&ciphertext);
+                            // append tag.
+                            packet[tag_offset..].copy_from_slice(&tag);
+                        }
+                        Err(_) => {
+                            log::error!("Encryption failed");
+                            return;
+                        }
+                    }
+                } else {
+                    let nonce = Nonce::assume_unique_for_key(nonce);
+
+                    // encrypt contents of transport message in-place
+                    let tag_offset = packet.len() - SIZE_TAG;
+                    let key = LessSafeKey::new(
+                        UnboundKey::new(&CHACHA20_POLY1305, &job.keypair.send.key[..]).unwrap(),
+                    );
+                    let tag = key
+                        .seal_in_place_separate_tag(nonce, Aad::empty(), &mut packet[..tag_offset])
+                        .unwrap();
+
+                    // append tag
+                    packet[tag_offset..].copy_from_slice(tag.as_ref());
+                }
+            }
+            // Put job buffer back (move ownership) after encryption.
+            let mut data = job.buffer.lock();
+            *data = Some(msg);
         }
 
         // mark ready
@@ -120,17 +157,18 @@ impl<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> SequentialJob
         debug_assert_eq!(
             self.is_ready(),
             true,
-            "doing sequential work 
+            "doing sequential work
             on an incomplete job"
         );
         log::trace!("processing sequential send job");
 
         // send to peer
         let job = &self.0;
-        let msg = job.buffer.lock();
-        let xmit = job.peer.send_raw(&msg[..]).is_ok();
+        let msg = job.buffer.lock().take().unwrap();
+        let msg_len = msg.len();
+        let xmit = job.peer.send_raw(msg).is_ok();
 
         // trigger callback (for timers)
-        C::send(&job.peer.opaque, msg.len(), xmit, &job.keypair, job.counter);
+        C::send(&job.peer.opaque, msg_len, xmit, &job.keypair, job.counter);
     }
 }
diff --git a/src/wireguard/router/tests/bench.rs b/src/wireguard/router/tests/bench.rs
index c2334b3..579aa19 100644
--- a/src/wireguard/router/tests/bench.rs
+++ b/src/wireguard/router/tests/bench.rs
@@ -101,8 +101,10 @@ fn bench_router_outbound(b: &mut Bencher) {
 
     // create device
     let (_fake, _reader, tun_writer, _mtu) = dummy::TunTest::create(false);
+    // Use one worker thread for benchmark.
     let router: Device<_, BencherCallbacks, dummy::TunWriter, dummy::VoidBind> =
-        Device::new(num_cpus::get_physical(), tun_writer);
+        Device::new(1, tun_writer, None);
+    //Device::new(num_cpus::get_physical(), tun_writer, None);
 
     // add peer to router
     let opaque = Arc::new(TransmissionCounter::new());
@@ -201,10 +203,10 @@ fn bench_router_bidirectional(b: &mut Bencher) {
     let (_fake, _, tun_writer1, _) = dummy::TunTest::create(false);
     let (_fake, _, tun_writer2, _) = dummy::TunTest::create(false);
 
-    let router1: Device<_, TestCallbacks, _, _> = Device::new(1, tun_writer1);
+    let router1: Device<_, TestCallbacks, _, _> = Device::new(1, tun_writer1, None);
     router1.set_outbound_writer(bind_writer1);
 
-    let router2: Device<_, TestCallbacks, _, _> = Device::new(1, tun_writer2);
+    let router2: Device<_, TestCallbacks, _, _> = Device::new(1, tun_writer2), None;
     router2.set_outbound_writer(bind_writer2);
 
     // prepare opaque values for tracing callbacks
@@ -398,7 +400,7 @@ fn bench_router_inbound(b: &mut Bencher) {
     // create device
     let (_fake, _reader, tun_writer, _mtu) = dummy::TunTest::create(false);
     let router: Device<_, BencherCallbacks, dummy::TunWriter, dummy::VoidBind> =
-        Device::new(num_cpus::get_physical(), tun_writer);
+        Device::new(num_cpus::get_physical(), tun_writer, None);
 
     // add new peer
     let opaque = Arc::new(AtomicUsize::new(0));
diff --git a/src/wireguard/router/tests/tests.rs b/src/wireguard/router/tests/tests.rs
index f6205d5..3fe067c 100644
--- a/src/wireguard/router/tests/tests.rs
+++ b/src/wireguard/router/tests/tests.rs
@@ -124,7 +124,7 @@ fn test_outbound() {
 
     // create device
     let (_fake, _reader, tun_writer, _mtu) = dummy::TunTest::create(false);
-    let router: Device<_, TestCallbacks, _, _> = Device::new(1, tun_writer);
+    let router: Device<_, TestCallbacks, _, _> = Device::new(1, tun_writer, None);
     router.set_outbound_writer(dummy::VoidBind::new());
 
     let tests = vec![
@@ -296,7 +296,7 @@ fn test_bidirectional() {
                 p1, p2, confirm_with_staged_packet
             );
 
-            let ((bind_reader1, bind_writer1), (bind_reader2, bind_writer2)) =
+            let ((mut bind_reader1, bind_writer1), (mut bind_reader2, bind_writer2)) =
                 dummy::PairBind::pair();
 
             let mut confirm_packet_size = SIZE_KEEPALIVE;
@@ -305,10 +305,10 @@ fn test_bidirectional() {
             let (_fake, _, tun_writer1, _) = dummy::TunTest::create(false);
             let (_fake, _, tun_writer2, _) = dummy::TunTest::create(false);
 
-            let router1: Device<_, TestCallbacks, _, _> = Device::new(1, tun_writer1);
+            let router1: Device<_, TestCallbacks, _, _> = Device::new(1, tun_writer1, None);
             router1.set_outbound_writer(bind_writer1);
 
-            let router2: Device<_, TestCallbacks, _, _> = Device::new(1, tun_writer2);
+            let router2: Device<_, TestCallbacks, _, _> = Device::new(1, tun_writer2, None);
             router2.set_outbound_writer(bind_writer2);
 
             // prepare opaque values for tracing callbacks
diff --git a/src/wireguard/wireguard.rs b/src/wireguard/wireguard.rs
index 44d698f..670201b 100644
--- a/src/wireguard/wireguard.rs
+++ b/src/wireguard/wireguard.rs
@@ -29,6 +29,9 @@ use hjul::Runner;
 use spin::{Mutex, RwLock};
 use x25519_dalek::{PublicKey, StaticSecret};
 
+#[cfg(all(target_os = "linux", feature = "cndp"))]
+use toml::{map::Map, Value};
+
 pub struct WireguardInner<T: Tun, B: UDP> {
     // identifier (for logging)
     pub id: u32,
@@ -58,6 +61,9 @@ pub struct WireguardInner<T: Tun, B: UDP> {
     pub last_under_load: Mutex<Instant>,
     pub pending: AtomicUsize, // number of pending handshake packets in queue
     pub queue: ParallelQueue<HandshakeJob<B::Endpoint>>,
+
+    #[cfg(all(target_os = "linux", feature = "cndp"))]
+    toml_map: Option<Map<String, Value>>,
 }
 
 pub struct WireGuard<T: Tun, B: UDP> {
@@ -254,8 +260,23 @@ impl<T: Tun, B: UDP> WireGuard<T, B> {
         // increment reader count
         wg.tun_readers.increase();
 
+        #[cfg(all(target_os = "linux", feature = "cndp"))]
+        let toml_map = self.toml_map.clone();
+
         // start worker
         thread::spawn(move || {
+            // For CNDP, set core affinity for TUN reader thread.
+            cfg_if::cfg_if! {
+                if #[cfg(all(target_os = "linux", feature = "cndp"))] {
+                    let tun_reader_core_id = match Self::read_config(&toml_map,"tun_reader_thread_coreid") {
+                        Some(v) => v.as_integer().expect("core id should be integer"),
+                        None => -1,
+                    };
+                    if tun_reader_core_id > 0 {
+                        core_affinity::set_for_current(core_affinity::CoreId { id: tun_reader_core_id as usize });
+                    }
+                }
+            }
             tun_worker(&wg, reader);
             wg.tun_readers.decrease();
         });
@@ -266,15 +287,36 @@ impl<T: Tun, B: UDP> WireGuard<T, B> {
     }
 
     pub fn new(writer: T::Writer) -> WireGuard<T, B> {
+        let mut worker_thread_base_coreid = None;
+        let mut num_workers = NUM_WORKERS;
+        cfg_if::cfg_if! {
+            if #[cfg(all(target_os = "linux", feature = "cndp"))] {
+                let toml_map = Self::load_config();
+                worker_thread_base_coreid = match Self::read_config(&toml_map,
+                            "wg_worker_thread_base_coreid") {
+                    Some(v) => Some(v.as_integer().expect("core id should be integer") as usize) ,
+                    None => None,
+                };
+                num_workers = match Self::read_config(&toml_map,
+                    "wg_num_workers") {
+                    Some(v) => v.as_integer().expect("wg_num_workers should be +ve integer") as usize ,
+                    None => NUM_WORKERS,
+                };
+            }
+        }
         // workers equal to number of physical cores
-        let cpus = num_cpus::get();
+        // Commented legacy code for reference.
+        // More worker threads can degrade performance in CPUs with may cores due to threading overhead.
+        // let cpus = num_cpus::get();
 
         // create handshake queue
-        let (tx, mut rxs) = ParallelQueue::new(cpus, 128);
+        // let (tx, mut rxs) = ParallelQueue::new(cpus, 128); // Commented legacy code for reference.
+        let (tx, mut rxs) = ParallelQueue::new(num_workers, 128);
 
         // create router
         let router: router::Device<B::Endpoint, PeerInner<T, B>, T::Writer, B::Writer> =
-            router::Device::new(num_cpus::get(), writer);
+            // router::Device::new(num_cpus::get(), writer); // Commented legacy code for reference.
+            router::Device::new(num_workers, writer, worker_thread_base_coreid);
 
         // create arc to state
         let wg = WireGuard {
@@ -289,6 +331,8 @@ impl<T: Tun, B: UDP> WireGuard<T, B> {
                 peers: RwLock::new(handshake::Device::new()),
                 runner: Mutex::new(Runner::new(TIMERS_TICK, TIMERS_SLOTS, TIMERS_CAPACITY)),
                 queue: tx,
+                #[cfg(all(target_os = "linux", feature = "cndp"))]
+                toml_map: toml_map,
             }),
         };
 
@@ -300,4 +344,40 @@ impl<T: Tun, B: UDP> WireGuard<T, B> {
 
         wg
     }
+
+    #[cfg(all(target_os = "linux", feature = "cndp"))]
+    fn load_config() -> Option<Map<String, Value>> {
+        // Parse toml.
+        // Get wg_cndp.toml file path.
+        // Assumption is that toml file is copied in same directory as executable. This has to be
+        // either done manually or via some script.
+        let mut cndp_toml_dir = std::env::current_exe().expect("Can't find path to executable");
+        cndp_toml_dir.pop();
+        cndp_toml_dir.push("wg_cndp.toml");
+        let toml_contents = std::fs::read_to_string(cndp_toml_dir.to_str().unwrap())
+            .expect("Unable to read toml file");
+        // Convert toml as Map<String, Value>
+        let toml_map = toml_contents
+            .parse::<Value>()
+            .ok()
+            .and_then(|r| match r {
+                Value::Table(table) => Some(table),
+                _ => None,
+            })
+            .unwrap_or(Map::new());
+
+        Some(toml_map)
+    }
+
+    #[cfg(all(target_os = "linux", feature = "cndp"))]
+    pub fn read_config(toml_map: &Option<Map<String, Value>>, key: &str) -> Option<Value> {
+        if let Some(toml_map) = toml_map {
+            let val = match toml_map.get(key) {
+                Some(v) => Some(v.clone()),
+                None => None,
+            };
+            return val;
+        }
+        return None;
+    }
 }
diff --git a/src/wireguard/workers.rs b/src/wireguard/workers.rs
index 27acf2f..7619721 100644
--- a/src/wireguard/workers.rs
+++ b/src/wireguard/workers.rs
@@ -58,11 +58,15 @@ pub fn tun_worker<T: Tun, B: UDP>(wg: &WireGuard<T, B>, reader: T::Reader) {
     loop {
         // create vector big enough for any transport message (based on MTU)
         let mtu = wg.mtu.load(Ordering::Relaxed);
-        let size = mtu + SIZE_MESSAGE_PREFIX + 1;
-        let mut msg: Vec<u8> = vec![0; size + CAPACITY_MESSAGE_POSTFIX];
+        let size = mtu + SIZE_MESSAGE_PREFIX + 1 + CAPACITY_MESSAGE_POSTFIX;
+        let mut msg: Vec<u8> = vec![0; size];
+        let msg_len = msg.len();
 
         // read a new IP packet
-        let payload = match reader.read(&mut msg[..], SIZE_MESSAGE_PREFIX) {
+        let payload = match reader.read(
+            &mut msg[..(msg_len - CAPACITY_MESSAGE_POSTFIX)],
+            SIZE_MESSAGE_PREFIX,
+        ) {
             Ok(payload) => payload,
             Err(e) => {
                 debug!("TUN worker, failed to read from tun device: {}", e);
@@ -83,11 +87,13 @@ pub fn tun_worker<T: Tun, B: UDP>(wg: &WireGuard<T, B>, reader: T::Reader) {
             payload,
             padded
         );
-        msg.truncate(SIZE_MESSAGE_PREFIX + padded);
+        msg.truncate(SIZE_MESSAGE_PREFIX + padded + CAPACITY_MESSAGE_POSTFIX);
+
         debug_assert!(padded <= mtu);
         debug_assert_eq!(
             if padded < mtu {
-                (msg.len() - SIZE_MESSAGE_PREFIX) % MESSAGE_PADDING_MULTIPLE
+                (msg.len() - SIZE_MESSAGE_PREFIX - CAPACITY_MESSAGE_POSTFIX)
+                    % MESSAGE_PADDING_MULTIPLE
             } else {
                 0
             },
@@ -100,7 +106,7 @@ pub fn tun_worker<T: Tun, B: UDP>(wg: &WireGuard<T, B>, reader: T::Reader) {
     }
 }
 
-pub fn udp_worker<T: Tun, B: UDP>(wg: &WireGuard<T, B>, reader: B::Reader) {
+pub fn udp_worker<T: Tun, B: UDP>(wg: &WireGuard<T, B>, mut reader: B::Reader) {
     loop {
         // create vector big enough for any message given current MTU
         let mtu = wg.mtu.load(Ordering::Relaxed);
@@ -195,7 +201,7 @@ pub fn handshake_worker<T: Tun, B: UDP>(
                         if let Some(msg) = resp {
                             resp_len = msg.len() as u64;
                             // TODO: consider a more elegant solution for accessing the bind
-                            let _ = wg.router.send_raw(&msg[..], &mut src).map_err(|e| {
+                            let _ = wg.router.send_raw(msg, &mut src).map_err(|e| {
                                 debug!(
                                     "{} : handshake worker, failed to send response, error = {}",
                                     wg, e
@@ -255,7 +261,7 @@ pub fn handshake_worker<T: Tun, B: UDP>(
                     );
                     let device = wg.peers.read();
                     let _ = device.begin(&mut OsRng, &pk).map(|msg| {
-                        let _ = peer.send_raw(&msg[..]).map_err(|e| {
+                        let _ = peer.send_raw(msg).map_err(|e| {
                             debug!("{} : handshake worker, failed to send handshake initiation, error = {}", wg, e)
                         });
                         peer.opaque().sent_handshake_initiation();
-- 
2.34.1

