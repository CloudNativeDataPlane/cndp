From fd970dcd28ca965fcf6838d9aeeefd06216b2bab Mon Sep 17 00:00:00 2001
From: Manoj Gopalakrishnan <manoj.gopalakrishnan@intel.com>
Date: Tue, 27 Jul 2021 04:35:26 -0700
Subject: [PATCH 1/7] Integarte CNDP (Cloud Native Data Plane) with Wireguard

     - Enable CNDP/AF-XDP support in wireguard to send and receive UDP packets.
     - CNDP C library is ported to Rust.
     - Use burst CNDP UDP read/write of wireguard packets for better performance.
     - Wireguard UDP packets parsed/generated using Rust pnet library.
     - Helper script to setup wireguard with cndp.
     - Example application to send/recv packets using CNDP/Wireguard stack and
       using rust mpsc channel instead of kernel Tun.

Signed-off-by: Manoj Gopalakrishnan <manoj.gopalakrishnan@intel.com>
---
 .gitignore                                    |    3 +-
 Cargo.lock                                    | 1312 ----------------
 Cargo.toml                                    |   42 +-
 build.rs                                      |   69 +
 src/main_cndp_packet.rs                       |  396 +++++
 src/main_cndp_ping.rs                         |  762 +++++++++
 src/platform/dummy/udp.rs                     |    4 +-
 src/platform/linux/cndp/README.md             |   68 +
 src/platform/linux/cndp/cndp.rs               |  501 ++++++
 src/platform/linux/cndp/cndp_pkt_fwd.jsonc    |  187 +++
 src/platform/linux/cndp/cndprustwg.sh         |   88 ++
 src/platform/linux/cndp/endpoint.rs           |   43 +
 src/platform/linux/cndp/eth_packet_rw.rs      |  845 ++++++++++
 src/platform/linux/cndp/fwd.jsonc             |  157 ++
 src/platform/linux/cndp/jcfg_parse/fwd.h      |   80 +
 .../linux/cndp/jcfg_parse/meson.build         |   22 +
 .../linux/cndp/jcfg_parse/parse-jsonc.c       |  178 +++
 .../linux/cndp/jcfg_parse/rust_helper.c       |   27 +
 .../linux/cndp/jcfg_parse/rust_helper.h       |   37 +
 src/platform/linux/cndp/jcfg_parse/stats.c    |  307 ++++
 src/platform/linux/cndp/mod.rs                |   11 +
 src/platform/linux/cndp/packet.rs             |  660 ++++++++
 src/platform/linux/cndp/pktgen_cfg/pktgen.cfg |   55 +
 src/platform/linux/cndp/pktgen_cfg/xdp.cfg    |  140 ++
 src/platform/linux/cndp/tun_channel.rs        |  245 +++
 src/platform/linux/cndp/udp.rs                | 1365 +++++++++++++++++
 src/platform/linux/cndp/util.rs               |   37 +
 src/platform/linux/cndp/wg_cndp.toml          |   35 +
 src/platform/linux/cndp/wrapper.h             |   13 +
 src/platform/linux/mod.rs                     |   10 +
 src/platform/linux/tun.rs                     |    6 +-
 src/platform/linux/udp.rs                     |    8 +-
 src/platform/udp.rs                           |    4 +-
 src/wireguard/constants.rs                    |    3 +
 src/wireguard/handshake/macs.rs               |    6 +-
 src/wireguard/handshake/noise.rs              |    6 +-
 src/wireguard/router/device.rs                |   21 +-
 src/wireguard/router/peer.rs                  |    2 +-
 src/wireguard/router/queue.rs                 |   27 +
 src/wireguard/router/receive.rs               |   52 +-
 src/wireguard/router/send.rs                  |   79 +-
 src/wireguard/router/tests/tests.rs           |    2 +-
 src/wireguard/wireguard.rs                    |   86 +-
 src/wireguard/workers.rs                      |    6 +-
 44 files changed, 6633 insertions(+), 1374 deletions(-)
 delete mode 100644 Cargo.lock
 create mode 100644 build.rs
 create mode 100644 src/main_cndp_packet.rs
 create mode 100644 src/main_cndp_ping.rs
 create mode 100644 src/platform/linux/cndp/README.md
 create mode 100644 src/platform/linux/cndp/cndp.rs
 create mode 100644 src/platform/linux/cndp/cndp_pkt_fwd.jsonc
 create mode 100755 src/platform/linux/cndp/cndprustwg.sh
 create mode 100644 src/platform/linux/cndp/endpoint.rs
 create mode 100644 src/platform/linux/cndp/eth_packet_rw.rs
 create mode 100644 src/platform/linux/cndp/fwd.jsonc
 create mode 100644 src/platform/linux/cndp/jcfg_parse/fwd.h
 create mode 100644 src/platform/linux/cndp/jcfg_parse/meson.build
 create mode 100644 src/platform/linux/cndp/jcfg_parse/parse-jsonc.c
 create mode 100644 src/platform/linux/cndp/jcfg_parse/rust_helper.c
 create mode 100644 src/platform/linux/cndp/jcfg_parse/rust_helper.h
 create mode 100644 src/platform/linux/cndp/jcfg_parse/stats.c
 create mode 100644 src/platform/linux/cndp/mod.rs
 create mode 100644 src/platform/linux/cndp/packet.rs
 create mode 100644 src/platform/linux/cndp/pktgen_cfg/pktgen.cfg
 create mode 100644 src/platform/linux/cndp/pktgen_cfg/xdp.cfg
 create mode 100644 src/platform/linux/cndp/tun_channel.rs
 create mode 100644 src/platform/linux/cndp/udp.rs
 create mode 100644 src/platform/linux/cndp/util.rs
 create mode 100644 src/platform/linux/cndp/wg_cndp.toml
 create mode 100644 src/platform/linux/cndp/wrapper.h

diff --git a/.gitignore b/.gitignore
index 802feda..7ca64af 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,4 +2,5 @@
 **/*.rs.bk
 proptest-regressions/
 Cargo.lock
-.idea/
\ No newline at end of file
+.idea/
+**/bindings.rs
diff --git a/Cargo.lock b/Cargo.lock
deleted file mode 100644
index 2941071..0000000
--- a/Cargo.lock
+++ /dev/null
@@ -1,1312 +0,0 @@
-# This file is automatically @generated by Cargo.
-# It is not intended for manual editing.
-[[package]]
-name = "addr2line"
-version = "0.13.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1b6a2d3371669ab3ca9797670853d61402b03d0b4b9ebf33d677dfa720203072"
-dependencies = [
- "gimli",
-]
-
-[[package]]
-name = "adler"
-version = "0.2.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ee2a4ec343196209d6594e19543ae87a39f96d5534d7174822a3ad825dd6ed7e"
-
-[[package]]
-name = "aead"
-version = "0.3.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7fc95d1bdb8e6666b2b217308eeeb09f2d6728d104be3e31916cc74d15420331"
-dependencies = [
- "generic-array",
-]
-
-[[package]]
-name = "aho-corasick"
-version = "0.7.13"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "043164d8ba5c4c3035fec9bbee8647c0261d788f3474306f93bb65901cae0e86"
-dependencies = [
- "memchr",
-]
-
-[[package]]
-name = "arraydeque"
-version = "0.4.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f0ffd3d69bd89910509a5d31d1f1353f38ccffdd116dd0099bbd6627f7bd8ad8"
-
-[[package]]
-name = "atty"
-version = "0.2.14"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8"
-dependencies = [
- "hermit-abi",
- "libc",
- "winapi 0.3.9",
-]
-
-[[package]]
-name = "autocfg"
-version = "1.0.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a"
-
-[[package]]
-name = "backtrace"
-version = "0.3.50"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "46254cf2fdcdf1badb5934448c1bcbe046a56537b3987d96c51a7afc5d03f293"
-dependencies = [
- "addr2line",
- "cfg-if 0.1.10",
- "libc",
- "miniz_oxide",
- "object",
- "rustc-demangle",
-]
-
-[[package]]
-name = "bit-set"
-version = "0.5.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6e11e16035ea35e4e5997b393eacbf6f63983188f7a2ad25bfb13465f5ad59de"
-dependencies = [
- "bit-vec",
-]
-
-[[package]]
-name = "bit-vec"
-version = "0.6.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5f0dc55f2d8a1a85650ac47858bb001b4c0dd73d79e3c455a842925e68d29cd3"
-
-[[package]]
-name = "bitflags"
-version = "0.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4f67931368edf3a9a51d29886d245f1c3db2f1ef0dcc9e35ff70341b78c10d23"
-
-[[package]]
-name = "bitflags"
-version = "1.2.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693"
-
-[[package]]
-name = "blake2"
-version = "0.9.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "10a5720225ef5daecf08657f23791354e1685a8c91a4c60c7f3d3b2892f978f4"
-dependencies = [
- "crypto-mac 0.8.0",
- "digest",
- "opaque-debug",
-]
-
-[[package]]
-name = "bumpalo"
-version = "3.4.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2e8c087f005730276d1096a652e92a8bacee2e2472bcc9715a74d2bec38b5820"
-
-[[package]]
-name = "byteorder"
-version = "1.3.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "08c48aae112d48ed9f069b33538ea9e3e90aa263cfa3d1c24309612b1f7472de"
-
-[[package]]
-name = "cc"
-version = "1.0.60"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ef611cc68ff783f18535d77ddd080185275713d852c4f5cbb6122c462a7a825c"
-
-[[package]]
-name = "cfg-if"
-version = "0.1.10"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822"
-
-[[package]]
-name = "cfg-if"
-version = "1.0.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
-
-[[package]]
-name = "chacha20"
-version = "0.6.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ed8738f14471a99f0e316c327e68fc82a3611cc2895fcb604b89eedaf8f39d95"
-dependencies = [
- "cipher",
- "zeroize",
-]
-
-[[package]]
-name = "chacha20poly1305"
-version = "0.7.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "af1fc18e6d90c40164bf6c317476f2a98f04661e310e79830366b7e914c58a8e"
-dependencies = [
- "aead",
- "chacha20",
- "cipher",
- "poly1305",
- "zeroize",
-]
-
-[[package]]
-name = "cipher"
-version = "0.2.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "12f8e7987cbd042a63249497f41aed09f8e65add917ea6566effbc56578d6801"
-dependencies = [
- "generic-array",
-]
-
-[[package]]
-name = "clear_on_drop"
-version = "0.2.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c9cc5db465b294c3fa986d5bbb0f3017cd850bff6dd6c52f9ccff8b4d21b7b08"
-dependencies = [
- "cc",
-]
-
-[[package]]
-name = "cpuid-bool"
-version = "0.2.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "dcb25d077389e53838a8158c8e99174c5a9d902dee4904320db714f3c653ffba"
-
-[[package]]
-name = "cpuprofiler"
-version = "0.0.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "43f8479dbcfd2bbaa0c0c26779b913052b375981cdf533091f2127ea3d42e52b"
-dependencies = [
- "error-chain",
- "lazy_static",
- "pkg-config",
-]
-
-[[package]]
-name = "crossbeam-channel"
-version = "0.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "dca26ee1f8d361640700bde38b2c37d8c22b3ce2d360e1fc1c74ea4b0aa7d775"
-dependencies = [
- "cfg-if 1.0.0",
- "crossbeam-utils",
-]
-
-[[package]]
-name = "crossbeam-utils"
-version = "0.8.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "02d96d1e189ef58269ebe5b97953da3274d83a93af647c2ddd6f9dab28cedb8d"
-dependencies = [
- "autocfg",
- "cfg-if 1.0.0",
- "lazy_static",
-]
-
-[[package]]
-name = "crypto-mac"
-version = "0.8.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b584a330336237c1eecd3e94266efb216c56ed91225d634cb2991c5f3fd1aeab"
-dependencies = [
- "generic-array",
- "subtle",
-]
-
-[[package]]
-name = "crypto-mac"
-version = "0.10.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4857fd85a0c34b3c3297875b747c1e02e06b6a0ea32dd892d8192b9ce0813ea6"
-dependencies = [
- "generic-array",
- "subtle",
-]
-
-[[package]]
-name = "curve25519-dalek"
-version = "3.0.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c8492de420e9e60bc9a1d66e2dbb91825390b738a388606600663fc529b4b307"
-dependencies = [
- "byteorder",
- "digest",
- "rand_core",
- "subtle",
- "zeroize",
-]
-
-[[package]]
-name = "dashmap"
-version = "4.0.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4b937cd1fbd1f194ac842196bd2529f21618088ee6d8bff6a46ece611451c96b"
-dependencies = [
- "cfg-if 1.0.0",
- "num_cpus",
-]
-
-[[package]]
-name = "digest"
-version = "0.9.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d3dd60d1080a57a05ab032377049e0591415d2b31afd7028356dbf3cc6dcb066"
-dependencies = [
- "generic-array",
-]
-
-[[package]]
-name = "env_logger"
-version = "0.8.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f26ecb66b4bdca6c1409b40fb255eefc2bd4f6d135dab3c3124f80ffa2a9661e"
-dependencies = [
- "atty",
- "humantime",
- "log 0.4.11",
- "regex",
- "termcolor",
-]
-
-[[package]]
-name = "error-chain"
-version = "0.12.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2d2f06b9cac1506ece98fe3231e3cc9c4410ec3d5b1f24ae1c8946f0742cdefc"
-dependencies = [
- "backtrace",
- "version_check",
-]
-
-[[package]]
-name = "fnv"
-version = "1.0.7"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"
-
-[[package]]
-name = "fuchsia-zircon"
-version = "0.3.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2e9763c69ebaae630ba35f74888db465e49e259ba1bc0eda7d06f4a067615d82"
-dependencies = [
- "bitflags 1.2.1",
- "fuchsia-zircon-sys",
-]
-
-[[package]]
-name = "fuchsia-zircon-sys"
-version = "0.3.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3dcaa9ae7725d12cdb85b3ad99a434db70b468c09ded17e012d86b5c1010f7a7"
-
-[[package]]
-name = "generic-array"
-version = "0.14.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "501466ecc8a30d1d3b7fc9229b122b2ce8ed6e9d9223f1138d4babb253e51817"
-dependencies = [
- "typenum",
- "version_check",
-]
-
-[[package]]
-name = "getrandom"
-version = "0.1.15"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fc587bc0ec293155d5bfa6b9891ec18a1e330c234f896ea47fbada4cadbe47e6"
-dependencies = [
- "cfg-if 0.1.10",
- "libc",
- "wasi",
-]
-
-[[package]]
-name = "gimli"
-version = "0.22.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "aaf91faf136cb47367fa430cd46e37a788775e7fa104f8b4bcb3861dc389b724"
-
-[[package]]
-name = "glob"
-version = "0.2.11"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8be18de09a56b60ed0edf84bc9df007e30040691af7acd1c41874faac5895bfb"
-
-[[package]]
-name = "hermit-abi"
-version = "0.1.15"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3deed196b6e7f9e44a2ae8d94225d80302d81208b1bb673fd21fe634645c85a9"
-dependencies = [
- "libc",
-]
-
-[[package]]
-name = "hex"
-version = "0.4.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "644f9158b2f133fd50f5fb3242878846d9eb792e445c893805ff0e3824006e35"
-
-[[package]]
-name = "hjul"
-version = "0.2.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b543d59589bf4d94a3dd2294162b5eeafc969962a675d544e597b03233869180"
-dependencies = [
- "mio",
- "mio-extras",
- "spin 0.5.2",
-]
-
-[[package]]
-name = "hmac"
-version = "0.10.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c1441c6b1e930e2817404b5046f1f989899143a12bf92de603b69f4e0aee1e15"
-dependencies = [
- "crypto-mac 0.10.0",
- "digest",
-]
-
-[[package]]
-name = "humantime"
-version = "2.0.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3c1ad908cc71012b7bea4d0c53ba96a8cba9962f048fa68d143376143d863b7a"
-
-[[package]]
-name = "instant"
-version = "0.1.9"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "61124eeebbd69b8190558df225adf7e4caafce0d743919e5d6b19652314ec5ec"
-dependencies = [
- "cfg-if 1.0.0",
-]
-
-[[package]]
-name = "iovec"
-version = "0.1.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b2b3ea6ff95e175473f8ffe6a7eb7c00d054240321b84c57051175fe3c1e075e"
-dependencies = [
- "libc",
-]
-
-[[package]]
-name = "ip_network_table-deps-treebitmap"
-version = "0.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8e537132deb99c0eb4b752f0346b6a836200eaaa3516dd7e5514b63930a09e5d"
-
-[[package]]
-name = "ipnetwork"
-version = "0.17.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "02c3eaab3ac0ede60ffa41add21970a7df7d91772c03383aac6c2c3d53cc716b"
-dependencies = [
- "serde",
-]
-
-[[package]]
-name = "js-sys"
-version = "0.3.45"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ca059e81d9486668f12d455a4ea6daa600bd408134cd17e3d3fb5a32d1f016f8"
-dependencies = [
- "wasm-bindgen",
-]
-
-[[package]]
-name = "kernel32-sys"
-version = "0.2.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d"
-dependencies = [
- "winapi 0.2.8",
- "winapi-build",
-]
-
-[[package]]
-name = "lazy_static"
-version = "1.4.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646"
-
-[[package]]
-name = "lazycell"
-version = "1.3.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55"
-
-[[package]]
-name = "libc"
-version = "0.2.77"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f2f96b10ec2560088a8e76961b00d47107b3a625fecb76dedb29ee7ccbf98235"
-
-[[package]]
-name = "lock_api"
-version = "0.4.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "dd96ffd135b2fd7b973ac026d28085defbe8983df057ced3eb4f2130b0831312"
-dependencies = [
- "scopeguard",
-]
-
-[[package]]
-name = "log"
-version = "0.3.9"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e19e8d5c34a3e0e2223db8e060f9e8264aeeb5c5fc64a4ee9965c062211c024b"
-dependencies = [
- "log 0.4.11",
-]
-
-[[package]]
-name = "log"
-version = "0.4.11"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4fabed175da42fed1fa0746b0ea71f412aa9d35e76e95e59b192c64b9dc2bf8b"
-dependencies = [
- "cfg-if 0.1.10",
-]
-
-[[package]]
-name = "memchr"
-version = "2.3.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3728d817d99e5ac407411fa471ff9800a778d88a24685968b36824eaf4bee400"
-
-[[package]]
-name = "miniz_oxide"
-version = "0.4.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c60c0dfe32c10b43a144bad8fc83538c52f58302c92300ea7ec7bf7b38d5a7b9"
-dependencies = [
- "adler",
- "autocfg",
-]
-
-[[package]]
-name = "mio"
-version = "0.6.22"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fce347092656428bc8eaf6201042cb551b8d67855af7374542a92a0fbfcac430"
-dependencies = [
- "cfg-if 0.1.10",
- "fuchsia-zircon",
- "fuchsia-zircon-sys",
- "iovec",
- "kernel32-sys",
- "libc",
- "log 0.4.11",
- "miow",
- "net2",
- "slab",
- "winapi 0.2.8",
-]
-
-[[package]]
-name = "mio-extras"
-version = "2.0.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "52403fe290012ce777c4626790c8951324a2b9e3316b3143779c72b029742f19"
-dependencies = [
- "lazycell",
- "log 0.4.11",
- "mio",
- "slab",
-]
-
-[[package]]
-name = "miow"
-version = "0.2.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8c1f2f3b1cf331de6896aabf6e9d55dca90356cc9960cca7eaaf408a355ae919"
-dependencies = [
- "kernel32-sys",
- "net2",
- "winapi 0.2.8",
- "ws2_32-sys",
-]
-
-[[package]]
-name = "net2"
-version = "0.2.35"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3ebc3ec692ed7c9a255596c67808dee269f64655d8baf7b4f0638e51ba1d6853"
-dependencies = [
- "cfg-if 0.1.10",
- "libc",
- "winapi 0.3.9",
-]
-
-[[package]]
-name = "num-traits"
-version = "0.2.12"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ac267bcc07f48ee5f8935ab0d24f316fb722d7a1292e2913f0cc196b29ffd611"
-dependencies = [
- "autocfg",
-]
-
-[[package]]
-name = "num_cpus"
-version = "1.13.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "05499f3756671c15885fee9034446956fff3f243d6077b91e5767df161f766b3"
-dependencies = [
- "hermit-abi",
- "libc",
-]
-
-[[package]]
-name = "object"
-version = "0.20.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1ab52be62400ca80aa00285d25253d7f7c437b7375c4de678f5405d3afe82ca5"
-
-[[package]]
-name = "once_cell"
-version = "1.4.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "260e51e7efe62b592207e9e13a68e43692a7a279171d6ba57abd208bf23645ad"
-
-[[package]]
-name = "opaque-debug"
-version = "0.3.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "624a8340c38c1b80fd549087862da4ba43e08858af025b236e509b6649fc13d5"
-
-[[package]]
-name = "parking_lot"
-version = "0.11.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6d7744ac029df22dca6284efe4e898991d28e3085c706c972bcd7da4a27a15eb"
-dependencies = [
- "instant",
- "lock_api",
- "parking_lot_core",
-]
-
-[[package]]
-name = "parking_lot_core"
-version = "0.8.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9ccb628cad4f84851442432c60ad8e1f607e29752d0bf072cbd0baf28aa34272"
-dependencies = [
- "cfg-if 1.0.0",
- "instant",
- "libc",
- "redox_syscall",
- "smallvec",
- "winapi 0.3.9",
-]
-
-[[package]]
-name = "pkg-config"
-version = "0.3.18"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d36492546b6af1463394d46f0c834346f31548646f6ba10849802c9c9a27ac33"
-
-[[package]]
-name = "pnet"
-version = "0.27.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b657d5b9a98a2c81b82549922b8b15984e49f8120cd130b11a09f81b9b55d633"
-dependencies = [
- "ipnetwork",
- "pnet_base",
- "pnet_datalink",
- "pnet_packet",
- "pnet_sys",
- "pnet_transport",
-]
-
-[[package]]
-name = "pnet_base"
-version = "0.27.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4e4688aa497ef62129f302a5800ebde67825f8ff129f43690ca84099f6620bed"
-
-[[package]]
-name = "pnet_datalink"
-version = "0.27.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "59001c9c4d9d23bf2f61afaaf134a766fd6932ba2557c606b9112157053b9ac7"
-dependencies = [
- "ipnetwork",
- "libc",
- "pnet_base",
- "pnet_sys",
- "winapi 0.3.9",
-]
-
-[[package]]
-name = "pnet_macros"
-version = "0.27.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d894a90dbdbe976e624453fc31b1912f658083778329442dda1cca94f76a3e76"
-dependencies = [
- "regex",
- "syntex",
- "syntex_syntax",
-]
-
-[[package]]
-name = "pnet_macros_support"
-version = "0.27.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4b99269a458570bc06a9132254349f6543d9abc92e88b68d8de934aac9481f6c"
-dependencies = [
- "pnet_base",
-]
-
-[[package]]
-name = "pnet_packet"
-version = "0.27.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "33f8238f4eb897a55ca06510cd71afb5b5ca7b4ff2d7188f1ca855fc1710133e"
-dependencies = [
- "glob",
- "pnet_base",
- "pnet_macros",
- "pnet_macros_support",
- "syntex",
-]
-
-[[package]]
-name = "pnet_sys"
-version = "0.27.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7589e4c4e7ed72a3ffdff8a65d3bea84e8c3a23e19d0a10e8f45efdf632fff15"
-dependencies = [
- "libc",
- "winapi 0.3.9",
-]
-
-[[package]]
-name = "pnet_transport"
-version = "0.27.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "326abdfd2e70e8e943bd58087b59686de170cac050a3b19c9fcc84db01690af5"
-dependencies = [
- "libc",
- "pnet_base",
- "pnet_packet",
- "pnet_sys",
-]
-
-[[package]]
-name = "poly1305"
-version = "0.6.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4b7456bc1ad2d4cf82b3a016be4c2ac48daf11bf990c1603ebd447fe6f30fca8"
-dependencies = [
- "cpuid-bool",
- "universal-hash",
-]
-
-[[package]]
-name = "ppv-lite86"
-version = "0.2.9"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c36fa947111f5c62a733b652544dd0016a43ce89619538a8ef92724a6f501a20"
-
-[[package]]
-name = "proc-macro2"
-version = "1.0.21"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "36e28516df94f3dd551a587da5357459d9b36d945a7c37c3557928c1c2ff2a2c"
-dependencies = [
- "unicode-xid 0.2.1",
-]
-
-[[package]]
-name = "proptest"
-version = "0.10.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "12e6c80c1139113c28ee4670dc50cc42915228b51f56a9e407f0ec60f966646f"
-dependencies = [
- "bit-set",
- "bitflags 1.2.1",
- "byteorder",
- "lazy_static",
- "num-traits",
- "quick-error",
- "rand",
- "rand_chacha",
- "rand_xorshift",
- "regex-syntax",
- "rusty-fork",
- "tempfile",
-]
-
-[[package]]
-name = "quick-error"
-version = "1.2.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a1d01941d82fa2ab50be1e79e6714289dd7cde78eba4c074bc5a4374f650dfe0"
-
-[[package]]
-name = "quote"
-version = "1.0.7"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "aa563d17ecb180e500da1cfd2b028310ac758de548efdd203e18f283af693f37"
-dependencies = [
- "proc-macro2",
-]
-
-[[package]]
-name = "rand"
-version = "0.7.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03"
-dependencies = [
- "getrandom",
- "libc",
- "rand_chacha",
- "rand_core",
- "rand_hc",
-]
-
-[[package]]
-name = "rand_chacha"
-version = "0.2.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f4c8ed856279c9737206bf725bf36935d8666ead7aa69b52be55af369d193402"
-dependencies = [
- "ppv-lite86",
- "rand_core",
-]
-
-[[package]]
-name = "rand_core"
-version = "0.5.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "90bde5296fc891b0cef12a6d03ddccc162ce7b2aff54160af9338f8d40df6d19"
-dependencies = [
- "getrandom",
-]
-
-[[package]]
-name = "rand_hc"
-version = "0.2.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ca3129af7b92a17112d59ad498c6f81eaf463253766b90396d39ea7a39d6613c"
-dependencies = [
- "rand_core",
-]
-
-[[package]]
-name = "rand_xorshift"
-version = "0.2.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "77d416b86801d23dde1aa643023b775c3a462efc0ed96443add11546cdf1dca8"
-dependencies = [
- "rand_core",
-]
-
-[[package]]
-name = "redox_syscall"
-version = "0.1.57"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "41cc0f7e4d5d4544e8861606a285bb08d3e70712ccc7d2b84d7c0ccfaf4b05ce"
-
-[[package]]
-name = "regex"
-version = "1.3.9"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9c3780fcf44b193bc4d09f36d2a3c87b251da4a046c87795a0d35f4f927ad8e6"
-dependencies = [
- "aho-corasick",
- "memchr",
- "regex-syntax",
- "thread_local",
-]
-
-[[package]]
-name = "regex-syntax"
-version = "0.6.18"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "26412eb97c6b088a6997e05f69403a802a92d520de2f8e63c2b65f9e0f47c4e8"
-
-[[package]]
-name = "remove_dir_all"
-version = "0.5.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3acd125665422973a33ac9d3dd2df85edad0f4ae9b00dafb1a05e43a9f5ef8e7"
-dependencies = [
- "winapi 0.3.9",
-]
-
-[[package]]
-name = "ring"
-version = "0.16.15"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "952cd6b98c85bbc30efa1ba5783b8abf12fec8b3287ffa52605b9432313e34e4"
-dependencies = [
- "cc",
- "libc",
- "once_cell",
- "spin 0.5.2",
- "untrusted",
- "web-sys",
- "winapi 0.3.9",
-]
-
-[[package]]
-name = "rustc-demangle"
-version = "0.1.16"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4c691c0e608126e00913e33f0ccf3727d5fc84573623b8d65b2df340b5201783"
-
-[[package]]
-name = "rustc-serialize"
-version = "0.3.24"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda"
-
-[[package]]
-name = "rusty-fork"
-version = "0.3.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cb3dcc6e454c328bb824492db107ab7c0ae8fcffe4ad210136ef014458c1bc4f"
-dependencies = [
- "fnv",
- "quick-error",
- "tempfile",
- "wait-timeout",
-]
-
-[[package]]
-name = "scopeguard"
-version = "1.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd"
-
-[[package]]
-name = "serde"
-version = "1.0.116"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "96fe57af81d28386a513cbc6858332abc6117cfdb5999647c6444b8f43a370a5"
-
-[[package]]
-name = "slab"
-version = "0.4.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c111b5bd5695e56cffe5129854aa230b39c93a305372fdbb2668ca2394eea9f8"
-
-[[package]]
-name = "smallvec"
-version = "1.4.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fbee7696b84bbf3d89a1c2eccff0850e3047ed46bfcd2e92c29a2d074d57e252"
-
-[[package]]
-name = "spin"
-version = "0.5.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6e63cff320ae2c57904679ba7cb63280a3dc4613885beafb148ee7bf9aa9042d"
-
-[[package]]
-name = "spin"
-version = "0.7.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "652ac3743312871a5fb703f0337e68ffa3cdc28c863efad0b8dc858fa10c991b"
-
-[[package]]
-name = "subtle"
-version = "2.4.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1e81da0851ada1f3e9d4312c704aa4f8806f0f9d69faaf8df2f3464b4a9437c2"
-
-[[package]]
-name = "syn"
-version = "1.0.41"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6690e3e9f692504b941dc6c3b188fd28df054f7fb8469ab40680df52fdcc842b"
-dependencies = [
- "proc-macro2",
- "quote",
- "unicode-xid 0.2.1",
-]
-
-[[package]]
-name = "synstructure"
-version = "0.12.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b834f2d66f734cb897113e34aaff2f1ab4719ca946f9a7358dba8f8064148701"
-dependencies = [
- "proc-macro2",
- "quote",
- "syn",
- "unicode-xid 0.2.1",
-]
-
-[[package]]
-name = "syntex"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0a30b08a6b383a22e5f6edc127d169670d48f905bb00ca79a00ea3e442ebe317"
-dependencies = [
- "syntex_errors",
- "syntex_syntax",
-]
-
-[[package]]
-name = "syntex_errors"
-version = "0.42.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "04c48f32867b6114449155b2a82114b86d4b09e1bddb21c47ff104ab9172b646"
-dependencies = [
- "libc",
- "log 0.3.9",
- "rustc-serialize",
- "syntex_pos",
- "term",
- "unicode-xid 0.0.3",
-]
-
-[[package]]
-name = "syntex_pos"
-version = "0.42.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3fd49988e52451813c61fecbe9abb5cfd4e1b7bb6cdbb980a6fbcbab859171a6"
-dependencies = [
- "rustc-serialize",
-]
-
-[[package]]
-name = "syntex_syntax"
-version = "0.42.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7628a0506e8f9666fdabb5f265d0059b059edac9a3f810bda077abb5d826bd8d"
-dependencies = [
- "bitflags 0.5.0",
- "libc",
- "log 0.3.9",
- "rustc-serialize",
- "syntex_errors",
- "syntex_pos",
- "term",
- "unicode-xid 0.0.3",
-]
-
-[[package]]
-name = "tempfile"
-version = "3.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7a6e24d9338a0a5be79593e2fa15a648add6138caa803e2d5bc782c371732ca9"
-dependencies = [
- "cfg-if 0.1.10",
- "libc",
- "rand",
- "redox_syscall",
- "remove_dir_all",
- "winapi 0.3.9",
-]
-
-[[package]]
-name = "term"
-version = "0.4.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fa63644f74ce96fbeb9b794f66aff2a52d601cbd5e80f4b97123e3899f4570f1"
-dependencies = [
- "kernel32-sys",
- "winapi 0.2.8",
-]
-
-[[package]]
-name = "termcolor"
-version = "1.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bb6bfa289a4d7c5766392812c0a1f4c1ba45afa1ad47803c11e1f407d846d75f"
-dependencies = [
- "winapi-util",
-]
-
-[[package]]
-name = "thread_local"
-version = "1.0.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d40c6d1b69745a6ec6fb1ca717914848da4b44ae29d9b3080cbee91d72a69b14"
-dependencies = [
- "lazy_static",
-]
-
-[[package]]
-name = "typenum"
-version = "1.12.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "373c8a200f9e67a0c95e62a4f52fbf80c23b4381c05a17845531982fa99e6b33"
-
-[[package]]
-name = "unicode-xid"
-version = "0.0.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "36dff09cafb4ec7c8cf0023eb0b686cb6ce65499116a12201c9e11840ca01beb"
-
-[[package]]
-name = "unicode-xid"
-version = "0.2.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f7fe0bb3479651439c9112f72b6c505038574c9fbb575ed1bf3b797fa39dd564"
-
-[[package]]
-name = "universal-hash"
-version = "0.4.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8326b2c654932e3e4f9196e69d08fdf7cfd718e1dc6f66b347e6024a0c961402"
-dependencies = [
- "generic-array",
- "subtle",
-]
-
-[[package]]
-name = "untrusted"
-version = "0.7.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a156c684c91ea7d62626509bce3cb4e1d9ed5c4d978f7b4352658f96a4c26b4a"
-
-[[package]]
-name = "version_check"
-version = "0.9.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b5a972e5669d67ba988ce3dc826706fb0a8b01471c088cb0b6110b805cc36aed"
-
-[[package]]
-name = "wait-timeout"
-version = "0.2.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9f200f5b12eb75f8c1ed65abd4b2db8a6e1b138a20de009dacee265a2498f3f6"
-dependencies = [
- "libc",
-]
-
-[[package]]
-name = "wasi"
-version = "0.9.0+wasi-snapshot-preview1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cccddf32554fecc6acb585f82a32a72e28b48f8c4c1883ddfeeeaa96f7d8e519"
-
-[[package]]
-name = "wasm-bindgen"
-version = "0.2.68"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1ac64ead5ea5f05873d7c12b545865ca2b8d28adfc50a49b84770a3a97265d42"
-dependencies = [
- "cfg-if 0.1.10",
- "wasm-bindgen-macro",
-]
-
-[[package]]
-name = "wasm-bindgen-backend"
-version = "0.2.68"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f22b422e2a757c35a73774860af8e112bff612ce6cb604224e8e47641a9e4f68"
-dependencies = [
- "bumpalo",
- "lazy_static",
- "log 0.4.11",
- "proc-macro2",
- "quote",
- "syn",
- "wasm-bindgen-shared",
-]
-
-[[package]]
-name = "wasm-bindgen-macro"
-version = "0.2.68"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6b13312a745c08c469f0b292dd2fcd6411dba5f7160f593da6ef69b64e407038"
-dependencies = [
- "quote",
- "wasm-bindgen-macro-support",
-]
-
-[[package]]
-name = "wasm-bindgen-macro-support"
-version = "0.2.68"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f249f06ef7ee334cc3b8ff031bfc11ec99d00f34d86da7498396dc1e3b1498fe"
-dependencies = [
- "proc-macro2",
- "quote",
- "syn",
- "wasm-bindgen-backend",
- "wasm-bindgen-shared",
-]
-
-[[package]]
-name = "wasm-bindgen-shared"
-version = "0.2.68"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1d649a3145108d7d3fbcde896a468d1bd636791823c9921135218ad89be08307"
-
-[[package]]
-name = "web-sys"
-version = "0.3.45"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4bf6ef87ad7ae8008e15a355ce696bed26012b7caa21605188cfd8214ab51e2d"
-dependencies = [
- "js-sys",
- "wasm-bindgen",
-]
-
-[[package]]
-name = "winapi"
-version = "0.2.8"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a"
-
-[[package]]
-name = "winapi"
-version = "0.3.9"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
-dependencies = [
- "winapi-i686-pc-windows-gnu",
- "winapi-x86_64-pc-windows-gnu",
-]
-
-[[package]]
-name = "winapi-build"
-version = "0.1.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc"
-
-[[package]]
-name = "winapi-i686-pc-windows-gnu"
-version = "0.4.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"
-
-[[package]]
-name = "winapi-util"
-version = "0.1.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "70ec6ce85bb158151cae5e5c87f95a8e97d2c0c4b001223f33a334e3ce5de178"
-dependencies = [
- "winapi 0.3.9",
-]
-
-[[package]]
-name = "winapi-x86_64-pc-windows-gnu"
-version = "0.4.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
-
-[[package]]
-name = "wireguard-rs"
-version = "0.1.4"
-dependencies = [
- "aead",
- "arraydeque",
- "blake2",
- "byteorder",
- "chacha20poly1305",
- "clear_on_drop",
- "cpuprofiler",
- "crossbeam-channel",
- "dashmap",
- "digest",
- "env_logger",
- "generic-array",
- "hex",
- "hjul",
- "hmac",
- "ip_network_table-deps-treebitmap",
- "libc",
- "log 0.4.11",
- "num_cpus",
- "parking_lot",
- "pnet",
- "proptest",
- "rand",
- "rand_chacha",
- "rand_core",
- "ring",
- "spin 0.7.0",
- "subtle",
- "x25519-dalek",
- "zerocopy",
-]
-
-[[package]]
-name = "ws2_32-sys"
-version = "0.2.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d59cefebd0c892fa2dd6de581e937301d8552cb44489cdff035c6187cb63fa5e"
-dependencies = [
- "winapi 0.2.8",
- "winapi-build",
-]
-
-[[package]]
-name = "x25519-dalek"
-version = "1.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bc614d95359fd7afc321b66d2107ede58b246b844cf5d8a0adcca413e439f088"
-dependencies = [
- "curve25519-dalek",
- "rand_core",
- "zeroize",
-]
-
-[[package]]
-name = "zerocopy"
-version = "0.3.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6580539ad917b7c026220c4b3f2c08d52ce54d6ce0dc491e66002e35388fab46"
-dependencies = [
- "byteorder",
- "zerocopy-derive",
-]
-
-[[package]]
-name = "zerocopy-derive"
-version = "0.2.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d498dbd1fd7beb83c86709ae1c33ca50942889473473d287d56ce4770a18edfb"
-dependencies = [
- "proc-macro2",
- "syn",
- "synstructure",
-]
-
-[[package]]
-name = "zeroize"
-version = "1.1.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "05f33972566adbd2d3588b0491eb94b98b43695c4ef897903470ede4f3f5a28a"
-dependencies = [
- "zeroize_derive",
-]
-
-[[package]]
-name = "zeroize_derive"
-version = "1.0.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c3f369ddb18862aba61aa49bf31e74d29f0f162dec753063200e1dc084345d16"
-dependencies = [
- "proc-macro2",
- "quote",
- "syn",
- "synstructure",
-]
diff --git a/Cargo.toml b/Cargo.toml
index 640d8cb..d634bbc 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -5,12 +5,22 @@ license = "MIT"
 name = "wireguard-rs"
 version = "0.1.4"
 
+[[bin]]
+name = "cndp-ping"
+path = "src/main_cndp_ping.rs"
+required-features = ["cndp"]
+
+[[bin]]
+name = "cndp-packet"
+path = "src/main_cndp_packet.rs"
+required-features = ["cndp"]
+
 [dependencies]
-aead = "^0.3"
 arraydeque = "0.4.5"
 blake2 = "^0.9"
 byteorder = "1.3"
-chacha20poly1305 = "^0.7"
+cfg-if = "^1.0.0"
+chacha20poly1305 = "^0.8"
 clear_on_drop = "0.2.3"
 cpuprofiler = {version = "*", optional = true}
 crossbeam-channel = "^0.5"
@@ -29,6 +39,13 @@ rand_core = "^0.5"
 ring = "0.16"
 spin = "0.7"
 zerocopy = "0.3"
+pnet = {version = "^0.28", optional = true }
+core_affinity = {version= "0.5.10", optional = true }
+toml = {version = "0.5.8", optional = true }
+clap ={version = "2.33.3", optional = true }
+once_cell = {version = "1.7.2", optional = true }
+openssl = {version = "^0.10", optional = true, features = ["vendored"]  }
+crossbeam-queue = {version = "^0.3", optional = true }
 
 [dependencies.treebitmap]
 package = "ip_network_table-deps-treebitmap"
@@ -45,10 +62,31 @@ version = "^2.4"
 #features = ["nightly"]
 
 [features]
+default = ["cndp", "openssl_enc_dec"]
 profiler = ["cpuprofiler"]
 start_up = []
+openssl_enc_dec = ["openssl"]
+cndp = ["pnet", "core_affinity", "bindgen", "meson", "pkg-config", "toml", "clap", "once_cell", "crossbeam-queue"]
 
 [dev-dependencies]
 pnet = "^0.27"
 proptest = "^0.10"
 rand_chacha = "^0.2"
+
+[build-dependencies]
+bindgen = {version = "0.57.0", optional = true }
+meson = { version = "1.0.0", optional = true }
+pkg-config = { version = "0.3.19", optional = true }
+
+[profile.dev]
+lto = true
+opt-level = 3
+
+[profile.release]
+opt-level = 3
+# Without enabling lto, packet processing with pnet is slow.
+# For example, without lto, pnet get/set mac address is ~50% slower.
+lto = true
+
+# Uncomment to enable debug symbols.
+debug = 2
diff --git a/build.rs b/build.rs
new file mode 100644
index 0000000..054e92f
--- /dev/null
+++ b/build.rs
@@ -0,0 +1,69 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+
+#[cfg(all(target_os = "linux", not(feature = "cndp")))]
+fn main() {}
+
+#[cfg(all(target_os = "linux", feature = "cndp"))]
+fn main() {
+    extern crate bindgen;
+    use std::env;
+    use std::fs;
+    use std::path::PathBuf;
+
+    // PKG_CONFIG_PATH environment variable should be set to directory containing libcndp.pc file.
+    let pkg_lib_dir = pkg_config::get_variable("libcndp", "libdir").unwrap();
+    let pkg_include_dir = pkg_config::get_variable("libcndp", "includedir").unwrap();
+
+    // Tell cargo to tell rustc to link the cndp shared library.
+    println!("cargo:rustc-link-search=native={}", pkg_lib_dir);
+    println!("cargo:rustc-link-lib=cndp");
+
+    // Tell cargo to invalidate the built crate whenever the wrapper.h or jcfg_parse changes
+    println!("cargo:rerun-if-changed=src/platform/linux/cndp/wrapper.h");
+    let jcfg_parse_dir = "src/platform/linux/cndp/jcfg_parse";
+    let jcfg_parse_files = fs::read_dir(jcfg_parse_dir).unwrap();
+    for file in jcfg_parse_files {
+        println!("cargo:rerun-if-changed={}", file.unwrap().path().display())
+    }
+
+    // Build jcfg_parse library.
+    let jcfg_parse_build_path = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
+    let jcfg_parse_build_path = jcfg_parse_build_path.join("build");
+    let jcfg_parse_build_path = jcfg_parse_build_path.to_str().unwrap();
+    meson::build(jcfg_parse_dir, jcfg_parse_build_path);
+
+    // Set jcfg_parse library path.
+    println!("cargo:rustc-link-search=native={}", jcfg_parse_build_path);
+    println!("cargo:rustc-link-lib=rust_jcfg_parse");
+
+    // Set cndp include search path CNDP_INCLUDE_PATH from environment variable.
+    let cndp_include_clang_arg = format!(r#"-I{}/cndp"#, pkg_include_dir);
+
+    // Set LD_LIBRARY_PATH env. This is required to run cargo tests.
+    println!(
+        "cargo:rustc-env=LD_LIBRARY_PATH={}:{}",
+        pkg_lib_dir, jcfg_parse_build_path
+    );
+
+    // The bindgen::Builder is the main entry point to bindgen, and lets you build up options for
+    // the resulting bindings.
+    let bindings = bindgen::Builder::default()
+        // The input header we would like to generate bindings for.
+        .header("src/platform/linux/cndp/wrapper.h")
+        .clang_arg(cndp_include_clang_arg)
+        // Tell cargo to invalidate the built crate whenever any of the included header files changed.
+        .parse_callbacks(Box::new(bindgen::CargoCallbacks))
+        // Finish the builder and generate the bindings.
+        .generate()
+        // Unwrap the Result and panic on failure.
+        .expect("Unable to generate bindings");
+
+    // Write the bindings to the $CARGO_MANIFEST_DIR/src/bindings.rs file.
+    let mut out_path_manifest = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
+    out_path_manifest.push("src/platform/linux/cndp");
+    bindings
+        .write_to_file(out_path_manifest.join("bindings.rs"))
+        .expect("Couldn't write bindings!");
+}
diff --git a/src/main_cndp_packet.rs b/src/main_cndp_packet.rs
new file mode 100644
index 0000000..1b51e9e
--- /dev/null
+++ b/src/main_cndp_packet.rs
@@ -0,0 +1,396 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+
+#![cfg_attr(feature = "unstable", feature(test))]
+
+extern crate alloc;
+
+#[cfg(feature = "profiler")]
+extern crate cpuprofiler;
+
+#[cfg(feature = "profiler")]
+use cpuprofiler::PROFILER;
+
+mod configuration;
+mod platform;
+mod wireguard;
+
+mod util;
+
+use std::process::exit;
+use std::sync::{Arc, RwLock};
+use std::thread;
+use std::time;
+
+use clap::{App, Arg};
+
+use configuration::Configuration;
+
+use platform::linux::cndp::cndp::CndpError;
+use platform::linux::cndp::endpoint::CndpEndpoint;
+use platform::linux::cndp::eth_packet_rw::*;
+use platform::linux::cndp::packet::CndpPacket;
+use platform::linux::cndp::tun_channel;
+use platform::tun::Status;
+use platform::uapi::{BindUAPI, PlatformUAPI};
+use platform::*;
+
+use wireguard::WireGuard;
+
+#[cfg(feature = "profiler")]
+fn profiler_stop() {
+    println!("Stopping profiler");
+    PROFILER.lock().unwrap().stop().unwrap();
+}
+
+#[cfg(not(feature = "profiler"))]
+fn profiler_stop() {}
+
+#[cfg(feature = "profiler")]
+fn profiler_start(name: &str) {
+    use std::path::Path;
+
+    // find first available path to save profiler output
+    let mut n = 0;
+    loop {
+        let path = format!("./{}-{}.profile", name, n);
+        if !Path::new(path.as_str()).exists() {
+            println!("Starting profiler: {}", path);
+            PROFILER.lock().unwrap().start(path).unwrap();
+            break;
+        };
+        n += 1;
+    }
+}
+
+fn main() {
+    // Parse command line arguments.
+    let matches = App::new("CNDP Wireguard Ping Example")
+        .version("0.1.0")
+        .about("CNDP Wireguard Ping Example")
+        .arg(
+            Arg::with_name("foreground")
+                .short("f")
+                .long("foreground")
+                .takes_value(false)
+                .help("Run app in foreground"),
+        )
+        .arg(
+            Arg::with_name("disable_drop_privileges")
+                .short("p")
+                .long("disable-drop-privileges")
+                .takes_value(false)
+                .help("Drop privileges for daemon process. Set gid/uid to nobody"),
+        )
+        .arg(
+            Arg::with_name("device")
+                .short("d")
+                .long("device")
+                .takes_value(true)
+                .help("WireGuard interface name"),
+        )
+        .arg(
+            Arg::with_name("traffic_gen_mac")
+                .short("t")
+                .long("traffic-gen-mac")
+                .takes_value(true)
+                .help("Local NIC Interface name generating/terminating traffic"),
+        )
+        .arg(
+            Arg::with_name("send")
+                .short("s")
+                .long("send")
+                .takes_value(false)
+                .help("Send traffic to remote"),
+        )
+        .get_matches();
+
+    let mut foreground = false;
+    if matches.is_present("foreground") {
+        foreground = true;
+    }
+    let mut drop_privileges = true;
+    if matches.is_present("disable_drop_privileges") {
+        drop_privileges = false;
+    }
+    // Wireguard interface name.
+    let name = matches.value_of("device").expect("No device name supplied");
+    // Traffic gen interface.
+    let traffic_gen_mac = matches
+        .value_of("traffic_gen_mac")
+        .expect("traffic_gen_mac is not provided");
+    let traffic_gen_mac = String::from(traffic_gen_mac);
+    // Send traffic
+    let mut send = false;
+    if matches.is_present("send") {
+        send = true;
+    }
+
+    // Create UAPI socket.
+    let uapi = plt::UAPI::bind(name).unwrap_or_else(|e| {
+        eprintln!("Failed to create UAPI listener: {}", e);
+        exit(-2);
+    });
+
+    // Create TUN (Rust channel) device.
+    let (tun_app_reader, tun_app_writer, mut readers, writer, status) =
+        tun_channel::TunChannel::create(name).unwrap_or_else(|e| {
+            eprintln!("Failed to create TUN device: {}", e);
+            exit(-3);
+        });
+
+    // drop privileges
+    if drop_privileges {
+        match util::drop_privileges() {
+            Ok(_) => (),
+            Err(e) => {
+                eprintln!("Failed to drop privileges: {}", e);
+                exit(-4);
+            }
+        }
+    }
+
+    // daemonize to background
+    if !foreground {
+        match util::daemonize() {
+            Ok(_) => (),
+            Err(e) => {
+                eprintln!("Failed to daemonize: {}", e);
+                exit(-5);
+            }
+        }
+    }
+
+    // start logging
+    env_logger::builder()
+        .try_init()
+        .expect("Failed to initialize event logger");
+
+    log::info!("Starting {} WireGuard device.", name);
+
+    // start profiler (if enabled)
+    #[cfg(feature = "profiler")]
+    profiler_start(name.as_str());
+
+    // create WireGuard device
+    let wg: WireGuard<tun_channel::TunChannel, plt::UDP> = WireGuard::new(writer);
+
+    // add all Tun readers
+    while let Some(reader) = readers.pop() {
+        wg.add_tun_reader(reader);
+    }
+
+    // wrap in configuration interface
+    let cfg = configuration::WireGuardConfig::new(wg.clone());
+    let tun_up = Arc::new(RwLock::new(false));
+    let tun_up_clone = Arc::clone(&tun_up);
+    // start Tun event thread
+    {
+        let cfg = cfg.clone();
+        let mut status = status;
+        thread::spawn(move || loop {
+            match status.event() {
+                Err(e) => {
+                    log::info!("Tun device error {}", e);
+                    profiler_stop();
+                    exit(0);
+                }
+                Ok(tun::TunEvent::Up(mtu)) => {
+                    log::info!("Tun up (mtu = {})", mtu);
+                    let _ = cfg.up(mtu); // TODO: handle
+                    let mut tun_up = tun_up_clone.write().unwrap();
+                    *tun_up = true;
+                }
+                Ok(tun::TunEvent::Down) => {
+                    log::info!("Tun down");
+                    cfg.down();
+                    let mut tun_up = tun_up_clone.write().unwrap();
+                    *tun_up = false;
+                }
+            }
+        });
+    }
+
+    // start UAPI server
+    let cfg = cfg.clone();
+    thread::spawn(move || loop {
+        // accept and handle UAPI config connections
+        match uapi.connect() {
+            Ok(mut stream) => {
+                let cfg = cfg.clone();
+                thread::spawn(move || {
+                    configuration::uapi::handle(&mut stream, &cfg);
+                });
+            }
+            Err(err) => {
+                log::info!("UAPI connection error: {}", err);
+                profiler_stop();
+                exit(-1);
+            }
+        }
+    });
+
+    // Wait for wireguard setup to complete before starting app send/recv.
+    let tun_up_clone = Arc::clone(&tun_up);
+    loop {
+        {
+            let tun_up = tun_up_clone.read().unwrap();
+            // Check if TUN is up.
+            if *tun_up {
+                log::info!("Wireguard enabled. Start App send/recv thread");
+                break;
+            }
+        }
+        // Wait for 1 sec and then check again.
+        thread::sleep(time::Duration::from_secs(1));
+    }
+    let tun_up_clone = Arc::clone(&tun_up);
+    test_send_recv_packet_different_thread(
+        tun_app_reader,
+        tun_app_writer,
+        tun_up_clone,
+        send,
+        traffic_gen_mac,
+    );
+
+    // Block until all tun readers closed.
+    wg.wait();
+    profiler_stop();
+    log::info!("Application exiting.");
+}
+
+fn test_send_recv_packet_different_thread(
+    tun_app_reader: tun_channel::TunChannelAppReader,
+    tun_app_writer: tun_channel::TunChannelAppWriter,
+    tun_up: Arc<RwLock<bool>>,
+    send: bool,
+    traffic_gen_mac: String,
+) {
+    // Bind to traffic generator CNDP reader/writer.
+    let (mut reader, writer, owner) = match CndpPacketSyncChannel::bind() {
+        Ok(r) => r,
+        Err(e) => {
+            log::error!("Error Bind {}", e);
+            return;
+        }
+    };
+
+    // Tun up/down check thread.
+    let tun_up_clone = Arc::clone(&tun_up);
+    let tun_check_thread_handle = thread::spawn(move || {
+        loop {
+            if !check_if_tun_up(&tun_up_clone) {
+                break;
+            }
+            thread::sleep(time::Duration::from_secs(1));
+        }
+        // Drop owner. This will quit packet reader/writer threads.
+        std::mem::drop(owner);
+        // Quit CNDP.
+        platform::linux::cndp::cndp::CndpInstance::quit_cndp();
+        log::info!("Exit Tun check thread");
+    });
+
+    // Receive packets thread.
+    let tun_up_clone = Arc::clone(&tun_up);
+    let app_recv_thread_handle = thread::spawn(move || {
+        let mut app_pkts_recvd = 0;
+        // Dst mac of traffic generator interface.
+        let dst_mac = CndpPacket::get_mac_from_string(&traffic_gen_mac);
+        let mut dst = CndpEndpoint::new(None, None, dst_mac);
+        let timeout = time::Duration::from_micros(20);
+        log::info!("Start receive packets thread");
+        loop {
+            if !check_if_tun_up(&tun_up_clone) {
+                break;
+            }
+            match tun_app_reader.read_timeout(timeout) {
+                Ok(packet) => {
+                    app_pkts_recvd += 1;
+                    log::debug!("Received app packet of length = {}", packet.len());
+                    // Write packet to traffic generator interface.
+                    match writer.write(packet, &mut dst) {
+                        Err(CndpError::Disconnected) => {
+                            log::info!("Packet writer disconnected");
+                            break;
+                        }
+                        Err(e) => {
+                            log::info!("Error writing packet {}", e);
+                            break;
+                        }
+                        Ok(_) => {}
+                    }
+                }
+                Err(tun_channel::TunChannelAppError::Timeout) => {}
+                Err(_) => {
+                    log::info!("Tun app read failed. Terminating app recv thread.");
+                    break;
+                }
+            }
+        }
+        log::info!("app_pkts_recvd = {}", app_pkts_recvd);
+    });
+
+    // Send packets thread.
+    if send {
+        let app_send_thread_handle = thread::spawn(move || {
+            log::info!("Start Send packets thread");
+            let mut app_pkts_sent = 0;
+            let mut app_pkts_skip = 0;
+            const MAX_PKT_SIZE: usize = 1500;
+            loop {
+                let mut packet: Vec<u8> = vec![0; MAX_PKT_SIZE];
+                // Read packet from traffic generator interface.
+                let (payload_len, _src) = match reader.read(&mut packet) {
+                    Err(CndpError::Disconnected) => {
+                        log::info!("Packet reader disconnected");
+                        break;
+                    }
+                    Err(e) => {
+                        log::error!("Error reading Packet {}", e);
+                        break;
+                    }
+                    Ok(v) => v,
+                };
+                packet.truncate(payload_len);
+                log::debug!(
+                    "Send app packet of length = {} to tun at time {} ",
+                    packet.len(),
+                    time::SystemTime::now()
+                        .duration_since(std::time::UNIX_EPOCH)
+                        .unwrap()
+                        .as_micros()
+                );
+                match tun_app_writer.write(packet) {
+                    Ok(_) => {
+                        app_pkts_sent += 1;
+                    }
+                    Err(tun_channel::TunChannelAppError::BufferFull) => {
+                        app_pkts_skip += 1;
+                    }
+                    Err(_) => {
+                        log::info!("Tun app write failed. Terminating app send thread.");
+                        break;
+                    }
+                }
+            }
+            log::info!(
+                "app_pkts_sent = {}, app_pkts_skip = {}",
+                app_pkts_sent,
+                app_pkts_skip
+            );
+        });
+        // Wait for packet send thread to quit.
+        app_send_thread_handle.join().unwrap();
+    }
+    // Wait for packet recv thread to quit.
+    app_recv_thread_handle.join().unwrap();
+    // Wait for Tun check thread to quit.
+    tun_check_thread_handle.join().unwrap();
+}
+
+fn check_if_tun_up(tun_up: &Arc<RwLock<bool>>) -> bool {
+    let tun_up = tun_up.read().unwrap();
+    *tun_up
+}
diff --git a/src/main_cndp_ping.rs b/src/main_cndp_ping.rs
new file mode 100644
index 0000000..2af3f98
--- /dev/null
+++ b/src/main_cndp_ping.rs
@@ -0,0 +1,762 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+
+#![cfg_attr(feature = "unstable", feature(test))]
+
+extern crate alloc;
+
+#[cfg(feature = "profiler")]
+extern crate cpuprofiler;
+
+#[cfg(feature = "profiler")]
+use cpuprofiler::PROFILER;
+
+mod configuration;
+mod platform;
+mod wireguard;
+
+mod util;
+
+use std::convert::TryInto;
+use std::mem;
+use std::net::IpAddr;
+use std::process::exit;
+use std::sync::{Arc, Mutex, RwLock};
+use std::thread;
+use std::time;
+
+use clap::{App, Arg};
+
+use configuration::Configuration;
+
+use platform::linux::cndp::tun_channel;
+use platform::tun::Status;
+use platform::uapi::{BindUAPI, PlatformUAPI};
+use platform::*;
+
+use wireguard::WireGuard;
+
+use pnet::packet::icmp::echo_reply::{EchoReplyPacket, MutableEchoReplyPacket};
+use pnet::packet::icmp::echo_request::{EchoRequestPacket, MutableEchoRequestPacket};
+use pnet::packet::icmp::{checksum, IcmpCode, IcmpPacket, IcmpTypes};
+use pnet::packet::ip::IpNextHeaderProtocols;
+use pnet::packet::ipv4::{self, Ipv4Packet, MutableIpv4Packet};
+use pnet::packet::Packet;
+
+#[cfg(feature = "profiler")]
+fn profiler_stop() {
+    println!("Stopping profiler");
+    PROFILER.lock().unwrap().stop().unwrap();
+}
+
+#[cfg(not(feature = "profiler"))]
+fn profiler_stop() {}
+
+#[cfg(feature = "profiler")]
+fn profiler_start(name: &str) {
+    use std::path::Path;
+
+    // find first available path to save profiler output
+    let mut n = 0;
+    loop {
+        let path = format!("./{}-{}.profile", name, n);
+        if !Path::new(path.as_str()).exists() {
+            println!("Starting profiler: {}", path);
+            PROFILER.lock().unwrap().start(path).unwrap();
+            break;
+        };
+        n += 1;
+    }
+}
+
+fn main() {
+    // Parse command line arguments.
+    let matches = App::new("CNDP Wireguard Ping Example")
+        .version("0.1.0")
+        .about("CNDP Wireguard Ping Example")
+        .arg(
+            Arg::with_name("foreground")
+                .short("f")
+                .long("foreground")
+                .takes_value(false)
+                .help("Run app in foreground"),
+        )
+        .arg(
+            Arg::with_name("disable_drop_privileges")
+                .short("p")
+                .long("disable-drop-privileges")
+                .takes_value(false)
+                .help("Drop privileges for daemon process. Set gid/uid to nobody"),
+        )
+        .arg(
+            Arg::with_name("local_ip")
+                .short("l")
+                .long("local")
+                .takes_value(true)
+                .help("Local Ip address"),
+        )
+        .arg(
+            Arg::with_name("remote_ip")
+                .short("r")
+                .long("remote")
+                .takes_value(true)
+                .help("Remote Ip address"),
+        )
+        .arg(
+            Arg::with_name("ping_interval")
+                .short("i")
+                .long("interval")
+                .takes_value(true)
+                .help("Ping interval in ms"),
+        )
+        .arg(
+            Arg::with_name("device")
+                .short("d")
+                .long("device")
+                .takes_value(true)
+                .help("WireGuard interface name"),
+        )
+        .get_matches();
+
+    let mut foreground = false;
+    if matches.is_present("foreground") {
+        foreground = true;
+    }
+    let mut drop_privileges = true;
+    if matches.is_present("disable_drop_privileges") {
+        drop_privileges = false;
+    }
+    // Wireguard interface name.
+    let name = matches.value_of("device").expect("No device name supplied");
+    // Local ip.
+    let local_ip = matches
+        .value_of("local_ip")
+        .expect("Local ip addr is not provided");
+    let local_ip = String::from(local_ip);
+    // Remote ip.
+    let remote_ip = matches
+        .value_of("remote_ip")
+        .expect("Remote ip addr is not provided");
+    let remote_ip = String::from(remote_ip);
+    // Ping interval.
+    let ping_interval = matches
+        .value_of("ping_interval")
+        .unwrap_or("1000")
+        .parse::<u64>()
+        .expect("unable to parse ping interval");
+
+    // Create UAPI socket.
+    let uapi = plt::UAPI::bind(name).unwrap_or_else(|e| {
+        eprintln!("Failed to create UAPI listener: {}", e);
+        exit(-2);
+    });
+
+    // Create TUN (Rust channel) device.
+    let (tun_app_reader, tun_app_writer, mut readers, writer, status) =
+        tun_channel::TunChannel::create(name).unwrap_or_else(|e| {
+            eprintln!("Failed to create TUN device: {}", e);
+            exit(-3);
+        });
+
+    // drop privileges
+    if drop_privileges {
+        match util::drop_privileges() {
+            Ok(_) => (),
+            Err(e) => {
+                eprintln!("Failed to drop privileges: {}", e);
+                exit(-4);
+            }
+        }
+    }
+
+    // daemonize to background
+    if !foreground {
+        match util::daemonize() {
+            Ok(_) => (),
+            Err(e) => {
+                eprintln!("Failed to daemonize: {}", e);
+                exit(-5);
+            }
+        }
+    }
+
+    // start logging
+    env_logger::builder()
+        .try_init()
+        .expect("Failed to initialize event logger");
+
+    log::info!("Starting {} WireGuard device.", name);
+
+    // start profiler (if enabled)
+    #[cfg(feature = "profiler")]
+    profiler_start(name.as_str());
+
+    // create WireGuard device
+    let wg: WireGuard<tun_channel::TunChannel, plt::UDP> = WireGuard::new(writer);
+
+    // add all Tun readers
+    while let Some(reader) = readers.pop() {
+        wg.add_tun_reader(reader);
+    }
+
+    // wrap in configuration interface
+    let cfg = configuration::WireGuardConfig::new(wg.clone());
+    let tun_up = Arc::new(RwLock::new(false));
+    let tun_up_clone = Arc::clone(&tun_up);
+
+    // start Tun event thread
+    {
+        let cfg = cfg.clone();
+        let mut status = status;
+        thread::spawn(move || loop {
+            match status.event() {
+                Err(e) => {
+                    log::info!("Tun device error {}", e);
+                    profiler_stop();
+                    exit(0);
+                }
+                Ok(tun::TunEvent::Up(mtu)) => {
+                    log::info!("Tun up (mtu = {})", mtu);
+                    let _ = cfg.up(mtu); // TODO: handle
+                    let mut tun_up = tun_up_clone.write().unwrap();
+                    *tun_up = true;
+                }
+                Ok(tun::TunEvent::Down) => {
+                    log::info!("Tun down");
+                    cfg.down();
+                    let mut tun_up = tun_up_clone.write().unwrap();
+                    *tun_up = false;
+                }
+            }
+        });
+    }
+
+    // start UAPI server
+    thread::spawn(move || loop {
+        // accept and handle UAPI config connections
+        match uapi.connect() {
+            Ok(mut stream) => {
+                let cfg = cfg.clone();
+                thread::spawn(move || {
+                    configuration::uapi::handle(&mut stream, &cfg);
+                });
+            }
+            Err(err) => {
+                log::info!("UAPI connection error: {}", err);
+                profiler_stop();
+                exit(-1);
+            }
+        }
+    });
+
+    // Wait for wireguard setup to complete before starting app send/recv.
+    let tun_up_clone = Arc::clone(&tun_up);
+    loop {
+        {
+            let tun_up = tun_up_clone.read().unwrap();
+            // Check if TUN is up.
+            if *tun_up {
+                log::info!("Wireguard enabled. Start App send/recv thread");
+                break;
+            }
+        }
+        // Wait for 1 sec and then check again.
+        thread::sleep(time::Duration::from_secs(1));
+    }
+
+    let tun_up_clone = Arc::clone(&tun_up);
+    let test_same_thread = true;
+    if test_same_thread {
+        // Test ping app send/recv in same thread.
+        test_ping_send_recv_same_thread(
+            tun_app_reader,
+            tun_app_writer,
+            tun_up_clone,
+            local_ip,
+            remote_ip,
+            ping_interval,
+        );
+    } else {
+        // Test ping app send/recv in different thread.
+        test_ping_send_recv_different_thread(
+            tun_app_reader,
+            tun_app_writer,
+            tun_up_clone,
+            local_ip,
+            remote_ip,
+            ping_interval,
+        );
+    }
+
+    // Block until all tun readers closed.
+    wg.wait();
+    profiler_stop();
+    log::info!("Application exiting.");
+}
+
+fn test_ping_send_recv_same_thread(
+    tun_app_reader: tun_channel::TunChannelAppReader,
+    tun_app_writer: tun_channel::TunChannelAppWriter,
+    tun_up: Arc<RwLock<bool>>,
+    local_ip: String,
+    remote_ip: String,
+    ping_interval: u64,
+) {
+    // Tun up/down check thread.
+    let tun_up_clone = Arc::clone(&tun_up);
+    let tun_check_thread_handle = thread::spawn(move || {
+        loop {
+            if !check_if_tun_up(&tun_up_clone) {
+                break;
+            }
+            thread::sleep(time::Duration::from_secs(1));
+        }
+        // Quit CNDP.
+        platform::linux::cndp::cndp::CndpInstance::quit_cndp();
+        log::info!("Exit Tun check thread");
+    });
+
+    // Send/Recv packets thread.
+    let tun_up_clone = Arc::clone(&tun_up);
+    let app_send_recv_thread_handle = thread::spawn(move || {
+        // Ping interval.
+        let duration = time::Duration::from_millis(ping_interval);
+        let mut seq = 0;
+        let id = std::process::id() as u16;
+        let mut icmp_echo_request_pkts_sent = 0;
+        // Send initial few packets causing handshake.
+        let mut icmp_echo_reply_pkts_recvd = 0;
+        let mut total_rtt = 0.0;
+        let mut last_echo_req_sent_time = time::Instant::now();
+        let mut is_first_echo_req_packet = true;
+        loop {
+            if !check_if_tun_up(&tun_up_clone) {
+                break;
+            }
+            // Send Echo request packet after delay.
+            let delay = last_echo_req_sent_time.elapsed();
+            if delay > duration || is_first_echo_req_packet {
+                let src = local_ip.parse().unwrap();
+                let dst = remote_ip.parse().unwrap();
+                let packet = make_ipv4_icmp_echo_req_packet(src, dst, seq, id);
+                log::debug!("Send echo request packet of length = {}", packet.len());
+                match tun_app_writer.write(packet) {
+                    Ok(_) => {
+                        log::info!(
+                            "Sent ICMP echo request {} -> {} (seq={:?}, id={:?}) at time {}",
+                            src,
+                            dst,
+                            seq,
+                            id,
+                            time::SystemTime::now()
+                                .duration_since(time::UNIX_EPOCH)
+                                .unwrap()
+                                .as_micros()
+                        );
+                        last_echo_req_sent_time = time::Instant::now();
+                        icmp_echo_request_pkts_sent += 1;
+                        seq += 1;
+                        is_first_echo_req_packet = false;
+                    }
+                    Err(tun_channel::TunChannelAppError::BufferFull) => {}
+                    Err(_) => {
+                        log::info!("Tun App Write failed. Terminating app send/recv thread.");
+                        break;
+                    }
+                }
+            }
+            // Recv packets.
+            match tun_app_reader.read_timeout(duration) {
+                Ok(packet) => {
+                    log::debug!("Received app packet of length = {}", packet.len());
+                    let header = Ipv4Packet::new(&packet);
+                    handle_ipv4_icmp_packet(
+                        &tun_app_writer,
+                        &header,
+                        &mut icmp_echo_reply_pkts_recvd,
+                        &mut total_rtt,
+                    );
+                }
+                Err(tun_channel::TunChannelAppError::Timeout) => {
+                    log::debug!("Tun app read timeout.");
+                    continue;
+                }
+                Err(_) => {
+                    log::debug!("Tun app read failed. Terminating app send/recv thread.");
+                    break;
+                }
+            }
+        }
+        log::info!(
+            "icmp_echo_request_pkts_sent = {}",
+            icmp_echo_request_pkts_sent
+        );
+        log::info!(
+            "icmp_echo_reply_pkts_recvd = {}",
+            icmp_echo_reply_pkts_recvd
+        );
+    });
+    // Wait for thread to stop.
+    app_send_recv_thread_handle.join().unwrap();
+    // Wait for Tun check thread to quit.
+    tun_check_thread_handle.join().unwrap();
+}
+
+fn test_ping_send_recv_different_thread(
+    tun_app_reader: tun_channel::TunChannelAppReader,
+    tun_app_writer: tun_channel::TunChannelAppWriter,
+    tun_up: Arc<RwLock<bool>>,
+    local_ip: String,
+    remote_ip: String,
+    ping_interval: u64,
+) {
+    let total_packets = Arc::new(Mutex::new(0usize));
+    let icmp_echo_request_pkts_sent = total_packets.clone();
+    let tun_app_writer_recv_thread = tun_app_writer.clone();
+
+    // Tun up/down check thread.
+    let tun_up_clone = Arc::clone(&tun_up);
+    let tun_check_thread_handle = thread::spawn(move || {
+        loop {
+            if !check_if_tun_up(&tun_up_clone) {
+                break;
+            }
+            thread::sleep(time::Duration::from_secs(1));
+        }
+        // Quit CNDP.
+        platform::linux::cndp::cndp::CndpInstance::quit_cndp();
+        log::info!("Exit Tun check thread");
+    });
+
+    // Send packets thread.
+    let tun_up_clone = Arc::clone(&tun_up);
+    let app_send_thread_handle = thread::spawn(move || {
+        // Ping send interval.
+        let duration = time::Duration::from_millis(ping_interval);
+        let mut seq = 0;
+        let id = std::process::id() as u16;
+        loop {
+            if !check_if_tun_up(&tun_up_clone) {
+                break;
+            }
+            let src = local_ip.parse().unwrap();
+            let dst = remote_ip.parse().unwrap();
+            let packet = make_ipv4_icmp_echo_req_packet(src, dst, seq, id);
+            log::debug!("Send echo request packet of length = {}", packet.len());
+            match tun_app_writer.write(packet) {
+                Ok(_) => {
+                    log::info!(
+                        "Sent ICMP echo request {} -> {} (seq={:?}, id={:?}) at time {}",
+                        src,
+                        dst,
+                        seq,
+                        id,
+                        time::SystemTime::now()
+                            .duration_since(std::time::UNIX_EPOCH)
+                            .unwrap()
+                            .as_micros(),
+                    );
+                    let mut icmp_echo_request_pkts_sent =
+                        icmp_echo_request_pkts_sent.lock().unwrap();
+                    *icmp_echo_request_pkts_sent += 1;
+                    seq += 1;
+                }
+                Err(tun_channel::TunChannelAppError::BufferFull) => {}
+                Err(_) => {
+                    log::debug!("Tun app write failed. Terminating app send thread.");
+                    break;
+                }
+            }
+            thread::sleep(duration);
+        }
+        let icmp_echo_request_pkts_sent = icmp_echo_request_pkts_sent.lock().unwrap();
+        log::info!(
+            "icmp_echo_request_pkts_sent = {}",
+            *icmp_echo_request_pkts_sent
+        );
+    });
+
+    // Receive packets thread.
+    let tun_up_clone = Arc::clone(&tun_up);
+    let app_recv_thread_handle = thread::spawn(move || {
+        let mut icmp_echo_reply_pkts_recvd = 0;
+        let mut total_rtt = 0.0;
+        //let total_packets_sent = { *total_packets.lock().unwrap() };
+        let timeout = time::Duration::from_micros(20);
+        loop {
+            if !check_if_tun_up(&tun_up_clone) {
+                break;
+            }
+            match tun_app_reader.read_timeout(timeout) {
+                Ok(packet) => {
+                    log::debug!("Received app packet of length = {}", packet.len());
+                    let header = Ipv4Packet::new(&packet);
+                    handle_ipv4_icmp_packet(
+                        &tun_app_writer_recv_thread,
+                        &header,
+                        &mut icmp_echo_reply_pkts_recvd,
+                        &mut total_rtt,
+                    );
+                }
+                Err(tun_channel::TunChannelAppError::Timeout) => {
+                    continue;
+                }
+                Err(_) => {
+                    log::debug!("Tun app read failed. Terminating app recv thread.");
+                    break;
+                }
+            }
+        }
+        log::info!(
+            "icmp_echo_reply_pkts_recvd = {}",
+            icmp_echo_reply_pkts_recvd
+        );
+    });
+    // Wait for send/recv thread to quit.
+    app_send_thread_handle.join().unwrap();
+    app_recv_thread_handle.join().unwrap();
+    // Wait for Tun check thread to quit.
+    tun_check_thread_handle.join().unwrap();
+}
+
+fn check_if_tun_up(tun_up: &Arc<RwLock<bool>>) -> bool {
+    let tun_up = tun_up.read().unwrap();
+    *tun_up
+}
+
+const ICMP_PAYLOAD_SIZE: usize = 16;
+const IPV4_HEADER_LEN: usize = 20;
+
+enum IcmpPacketType<'a> {
+    EchoRep(EchoReplyPacket<'a>),
+    EchoReq(EchoRequestPacket<'a>),
+}
+
+fn make_ipv4_icmp_echo_req_packet(src: IpAddr, dst: IpAddr, seq: u16, id: u16) -> Vec<u8> {
+    // Create echo request packet.
+    let size = EchoRequestPacket::minimum_packet_size() + ICMP_PAYLOAD_SIZE;
+    let mut p: Vec<u8> = vec![0; size];
+    let mut echo_req = MutableEchoRequestPacket::new(&mut p).unwrap();
+    echo_req.set_sequence_number(seq);
+    echo_req.set_identifier(id);
+    echo_req.set_icmp_type(IcmpTypes::EchoRequest);
+    echo_req.set_icmp_code(IcmpCode::new(0));
+    // Set payload to current time.
+    let curr_time = time::SystemTime::now()
+        .duration_since(time::UNIX_EPOCH)
+        .unwrap()
+        .as_micros();
+    let arr = unsafe { mem::transmute::<u128, [u8; ICMP_PAYLOAD_SIZE]>(curr_time) };
+    echo_req.set_payload(&arr);
+    // Set checksum.
+    let checksum = checksum(&IcmpPacket::new(echo_req.packet()).unwrap());
+    echo_req.set_checksum(checksum);
+
+    // Create "IP packet".
+    let length = size + MutableIpv4Packet::minimum_packet_size();
+    let mut msg = vec![0; length];
+    match dst {
+        IpAddr::V4(dst) => {
+            let mut packet = MutableIpv4Packet::new(&mut msg[..]).unwrap();
+            packet.set_destination(dst);
+            packet.set_header_length((IPV4_HEADER_LEN / 4) as u8);
+            packet.set_total_length(length.try_into().expect("length IPv4 packet exceeded max"));
+            packet.set_source(if let IpAddr::V4(src) = src {
+                src
+            } else {
+                panic!("src.version != dst.version")
+            });
+            packet.set_version(4);
+            packet.set_ttl(64);
+            packet.set_next_level_protocol(IpNextHeaderProtocols::Icmp);
+            packet.set_payload(&p);
+            let checksum = ipv4::checksum(&packet.to_immutable());
+            packet.set_checksum(checksum);
+        }
+        IpAddr::V6(_) => {
+            log::debug!("Ipv6 Not Supported");
+        }
+    }
+    msg
+}
+
+fn make_ipv4_icmp_echo_reply_packet(
+    src: IpAddr,
+    dst: IpAddr,
+    seq: u16,
+    id: u16,
+    payload: &[u8],
+) -> Vec<u8> {
+    // Create echo reply packet.
+    let size = EchoReplyPacket::minimum_packet_size() + payload.len();
+    let mut p: Vec<u8> = vec![0; size];
+    let mut echo_reply = MutableEchoReplyPacket::new(&mut p).unwrap();
+    echo_reply.set_sequence_number(seq);
+    echo_reply.set_identifier(id);
+    echo_reply.set_icmp_type(IcmpTypes::EchoReply);
+    echo_reply.set_icmp_code(IcmpCode::new(0));
+    echo_reply.set_payload(payload);
+    let checksum = checksum(&IcmpPacket::new(echo_reply.packet()).unwrap());
+    echo_reply.set_checksum(checksum);
+
+    // Create "IP packet".
+    let length = size + MutableIpv4Packet::minimum_packet_size();
+    let mut msg = vec![0; length];
+    match dst {
+        IpAddr::V4(dst) => {
+            let mut packet = MutableIpv4Packet::new(&mut msg[..]).unwrap();
+            packet.set_destination(dst);
+            packet.set_header_length((IPV4_HEADER_LEN / 4) as u8);
+            packet.set_total_length(length.try_into().expect("length IPv4 packet exceeded max"));
+            packet.set_source(if let IpAddr::V4(src) = src {
+                src
+            } else {
+                panic!("ip src version != ip dst version")
+            });
+            packet.set_version(4);
+            packet.set_ttl(64);
+            packet.set_next_level_protocol(IpNextHeaderProtocols::Icmp);
+            packet.set_payload(&p);
+            let checksum = ipv4::checksum(&packet.to_immutable());
+            packet.set_checksum(checksum);
+        }
+        IpAddr::V6(_) => {
+            log::debug!("Ipv6 Not Supported");
+        }
+    }
+    msg
+}
+
+fn handle_ipv4_icmp_packet<'a>(
+    tun_app_writer: &tun_channel::TunChannelAppWriter,
+    header: &'a Option<Ipv4Packet>,
+    icmp_echo_reply_pkts_recvd: &mut usize,
+    total_rtt: &mut f64,
+) {
+    if let Some(header) = header {
+        let source = IpAddr::V4(header.get_source());
+        let destination = IpAddr::V4(header.get_destination());
+        let protocol = header.get_next_level_protocol();
+        if protocol == IpNextHeaderProtocols::Icmp {
+            let icmp_packet = handle_icmp_packet(source, destination, header.payload());
+            if let Some(icmp_packet) = icmp_packet {
+                match icmp_packet {
+                    IcmpPacketType::EchoRep(echo_reply_packet) => {
+                        let payload = echo_reply_packet.payload();
+                        if payload.len() < ICMP_PAYLOAD_SIZE {
+                            log::info!(
+                                "Recv ICMP echo reply   {} -> {} (seq={:?}, id={:?}, unknown ICMP payload)",
+                                source,
+                                destination,
+                                echo_reply_packet.get_sequence_number(),
+                                echo_reply_packet.get_identifier(),
+                            );
+                            return;
+                        }
+                        // Retrieve packet sent time from payload.
+                        let send_time = unsafe {
+                            let num = 0u128;
+                            let mut arr = mem::transmute::<u128, [u8; ICMP_PAYLOAD_SIZE]>(num);
+                            arr.copy_from_slice(payload);
+                            mem::transmute::<[u8; ICMP_PAYLOAD_SIZE], u128>(arr)
+                        };
+                        let curr_time = time::SystemTime::now()
+                            .duration_since(time::UNIX_EPOCH)
+                            .unwrap()
+                            .as_micros();
+                        let elapsed_micro_sec = curr_time - send_time;
+                        let elapsed_ms = elapsed_micro_sec as f64 / 1000 as f64;
+                        *icmp_echo_reply_pkts_recvd += 1;
+                        let mut avg_rtt = 0.0;
+                        // Ignore initial few packets for average rtt calculation as delay is high
+                        // for initial few packets since initial handshake with peer takes time.
+                        let initial_packets_ignore = 25;
+                        if *icmp_echo_reply_pkts_recvd > initial_packets_ignore {
+                            *total_rtt += elapsed_ms;
+                            avg_rtt = *total_rtt as f64
+                                / (*icmp_echo_reply_pkts_recvd - initial_packets_ignore) as f64;
+                        }
+                        log::info!(
+                            "Recv ICMP echo reply   {} -> {} (seq={:?}, id={:?}, elapsed_ms={} ms, avg rtt={:.3} ms)",
+                            source,
+                            destination,
+                            echo_reply_packet.get_sequence_number(),
+                            echo_reply_packet.get_identifier(),
+                            elapsed_ms,
+                            avg_rtt,
+                        );
+                        log::info!("Recv ICMP echo reply at time {}", curr_time);
+                    }
+                    IcmpPacketType::EchoReq(echo_request_packet) => {
+                        let seq = echo_request_packet.get_sequence_number();
+                        let id = echo_request_packet.get_identifier();
+                        let payload = echo_request_packet.payload();
+                        log::info!(
+                            "Recv ICMP echo request {} -> {} (seq={:?}, id={:?})",
+                            source,
+                            destination,
+                            seq,
+                            id
+                        );
+                        // Send Echo Reply to source.
+                        let packet =
+                            make_ipv4_icmp_echo_reply_packet(destination, source, seq, id, payload);
+                        log::debug!("Send echo reply packet of length = {}", packet.len());
+                        match tun_app_writer.write(packet) {
+                            Ok(_) => {
+                                log::info!(
+                                    "Sent ICMP echo reply   {} -> {} (seq={:?}, id={:?}) at time {}",
+                                    destination,
+                                    source,
+                                    seq,
+                                    id,
+                                    time::SystemTime::now()
+                                        .duration_since(time::UNIX_EPOCH)
+                                        .unwrap()
+                                        .as_micros()
+                                );
+                            }
+                            Err(tun_channel::TunChannelAppError::BufferFull) => {}
+                            Err(_) => {
+                                log::debug!("Write echo reply packet failed.");
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
+
+fn handle_icmp_packet<'a>(
+    source: IpAddr,
+    destination: IpAddr,
+    packet: &'a [u8],
+) -> Option<IcmpPacketType<'a>> {
+    let icmp_packet = IcmpPacket::new(packet);
+    if let Some(icmp_packet) = icmp_packet {
+        match icmp_packet.get_icmp_type() {
+            IcmpTypes::EchoReply => {
+                let echo_reply_packet = EchoReplyPacket::new(packet).unwrap();
+                return Some(IcmpPacketType::EchoRep(echo_reply_packet));
+            }
+            IcmpTypes::EchoRequest => {
+                let echo_request_packet = EchoRequestPacket::new(packet).unwrap();
+                return Some(IcmpPacketType::EchoReq(echo_request_packet));
+            }
+            _ => {
+                log::debug!(
+                    "ICMP packet {} -> {} (type={:?})",
+                    source,
+                    destination,
+                    icmp_packet.get_icmp_type()
+                );
+                return None;
+            }
+        }
+    } else {
+        log::debug!("Malformed ICMP Packet");
+    }
+    return None;
+}
diff --git a/src/platform/dummy/udp.rs b/src/platform/dummy/udp.rs
index 88630af..20700a9 100644
--- a/src/platform/dummy/udp.rs
+++ b/src/platform/dummy/udp.rs
@@ -46,7 +46,7 @@ pub struct VoidBind {}
 impl Reader<UnitEndpoint> for VoidBind {
     type Error = BindError;
 
-    fn read(&self, _buf: &mut [u8]) -> Result<(usize, UnitEndpoint), Self::Error> {
+    fn read(&mut self, _buf: &mut [u8]) -> Result<(usize, UnitEndpoint), Self::Error> {
         Ok((0, UnitEndpoint {}))
     }
 }
@@ -84,7 +84,7 @@ pub struct PairReader<E> {
 
 impl Reader<UnitEndpoint> for PairReader<UnitEndpoint> {
     type Error = BindError;
-    fn read(&self, buf: &mut [u8]) -> Result<(usize, UnitEndpoint), Self::Error> {
+    fn read(&mut self, buf: &mut [u8]) -> Result<(usize, UnitEndpoint), Self::Error> {
         let vec = self
             .recv
             .lock()
diff --git a/src/platform/linux/cndp/README.md b/src/platform/linux/cndp/README.md
new file mode 100644
index 0000000..cfaddd6
--- /dev/null
+++ b/src/platform/linux/cndp/README.md
@@ -0,0 +1,68 @@
+# Wireguard using CNDP (Cloud Native Data Plane) .
+
+## Overview
+
+Wireguard uses CNDP/AF-XDP to send and receive packets from/to user space. Wireguard with CNDP will run on Linux platform.
+
+Cloud Native Data Plane (CNDP) provides a set of User-space libraries for accelerating packet processing for cloud applications.  It aims to accomplish better performance (N Times faster) than that of Linux standard network interfaces by taking advantage of Intel technologies and features (e.g. AVX 512, DSA, CLDEMOTE…). The first version of the library is built upon AF_XDP, an interface that delivers packets straight to User-space bypassing the Linux Kernel Networking stack.
+
+## Usage (Linux)
+
+### Building
+
+Wireguard with CNDP is most recently tested on Ubuntu 21.04, 5.11.0-18-generic kernel. It is expected to work on other ubuntu and kernel versions which is supported by CNDP.
+
+To build wireguard-rs with CNDP on Linux:
+
+1. Obtain nightly `cargo` and `rustc` through [rustup](https://rustup.rs/)
+2. Clone the repository: `git clone https://gitlab.devtools.intel.com/nclg-arch/poc/wireguard-rs.git`.
+3. Use cndp branch - `git checkout cndp`
+4. Run `cargo build --release` from inside the `wireguard-rs` directory.
+
+### Wireguard CNDP helper script
+
+Helper script [cndprustwg.sh](./cndprustwg.sh)  is provided to start wireguard user space application using CNDP. Update the following variables in the script as per the required configuration and then run the script in both endpoints (local and remote).
+
+1. WG_ROOT - Wireguard CNDP root folder (absolute path)
+2. PRIVATE_KEY - Private key file (absolute path).
+3. WG_LOCAL_IP - Wireguard interface local IP.
+4. WG_LOCAL_LISTEN_PORT - Wireguard interface local IP.
+5. WG_PEER_IP - Wireguard interface peer IP.
+6. WG_PEER_LISTEN_PORT - Peer listen port.
+7. WG_PEER_ENDPOINT_IP - Peer endpoint IP.
+8. WG_PEER_PUBLIC_KEY - Peer public key (base64 encoded)
+
+### Configure ethtool filter
+
+Before running the script, configure an ethtool filter to steer packets to a specific queue. This should be done for both local and remote Wireguard endpoints.
+
+`sudo ethool -N <devname> flow-type udp4 src-ip <src ip> dst-ip <dst ip> action <qid>`
+
+Here src-ip and dst-ip corresponds to local and remote peer endpoint IP. We could create separate rules for sending and receiving packets. For example, below rules are for sending and receiving UDP packets.
+
+`sudo ethtool -N enp134s0f0 flow-type udp4 src-ip 48.0.0.155 dst-ip 48.0.0.154 action 23`
+
+`sudo ethtool -N enp134s0f0 flow-type udp4 src-ip 48.0.0.154 dst-ip 48.0.0.155 action 33`
+
+### Update CNDP JSON configuration file
+
+Edit the example JSON file [fwd.jsonc](./fwd.jsonc) or [cndp_pkt_fwd.jsonc](./cndp_pkt_fwd.jsonc) configuration file.  Make sure the "lports" section has the same netdev name and queue id for which the ethtool filter is configured. Make sure the "threads" section has the correct "lports" configured. JSON file contains the netdev configuration of the n/w interface used by wireguard to send/receive packets from/to from remote endpoint.
+
+### Update WG CNDP toml file
+
+Edit [wg_cndp.toml](./wg_cndp.toml) toml file. Set "jsonc" to absolute path of CNDP JSON configuration file. Other parameters are optional. See the toml file comments for description of these parameters.
+
+### Run the helper script
+
+The helper script is used to configure and stat wireguard interface. This script should be run on both endpoints (this could be two different systems).
+
+**Usage**: `cndprustwg.sh [debug|release] [cndp-packet|cndp-ping|wireguard-rs]`
+
+There are 3 executables use by the script. By default, script will run in *release* mode and uses *wireguard-rs* executable.
+
+1. wireguard-rs - This is the default executable which uses Linux Kernel TUN for data path to send and receive network packets.
+2. cndp-ping - Custom ping application developed on top of Wireguard and CNDP stack which sends and receives ICMP request/reply packets.
+3. cndp-packet - Custom application developed on top of Wireguard and CNDP stack which sends and receives network(tcp/udp) packets. This executable uses [DPDK pktgen application](https://pktgen-dpdk.readthedocs.io/en/latest/) to send and receive packets to/from a n/w interface. Sample pktgen configuration files are located in directory [pktgen_cfg](./pktgen_cfg). The mac address of the n/w interface should be configured in the variable "TRAFFIC_GEN_MAC" in the script [cndprustwg.sh](./cndprustwg.sh).  [cndp_pkt_fwd.jsonc](./cndp_pkt_fwd.jsonc) configuration file should be updated with the netdev corresponding to the n/w interface used by pktgen application.
+
+Running this script will create an interface `rsuwg0`, configure it based on the settings provided in the script and fork into the background. To remove the interface, use  `sudo ip link del rsuwg0`, or if your system does not support removing interfaces directly, you may instead remove the control socket via `rm -f /var/run/wireguard/rsuwg0.sock`, which will result in wireguard-rs shutting down.
+
diff --git a/src/platform/linux/cndp/cndp.rs b/src/platform/linux/cndp/cndp.rs
new file mode 100644
index 0000000..92267f9
--- /dev/null
+++ b/src/platform/linux/cndp/cndp.rs
@@ -0,0 +1,501 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+
+#![allow(non_upper_case_globals)]
+#![allow(non_camel_case_types)]
+#![allow(non_snake_case)]
+#![allow(dead_code)]
+
+use once_cell::sync::OnceCell;
+use pnet::datalink::MacAddr;
+use std::env;
+use std::error::Error;
+use std::fmt;
+use std::fs;
+use std::net::IpAddr;
+use std::os::raw::c_void;
+use std::sync::RwLock;
+use toml::map::Map;
+use toml::Value;
+
+// Include Rust bindings for C code.
+include!(concat!(
+    env!("CARGO_MANIFEST_DIR"),
+    "/src/platform/linux/cndp/bindings.rs"
+));
+
+use super::packet::*;
+use super::util::*;
+
+pub struct CndpInstance {
+    pub finfo: RwLock<fwd_info>,
+    cne_uid: i32,
+    toml_map: Option<Map<String, Value>>,
+}
+
+pub static CNDPINSTANCE: OnceCell<CndpInstance> = OnceCell::new();
+
+impl CndpInstance {
+    // Get singleton instance of cndp.
+    pub fn get_instance() -> &'static CndpInstance {
+        static CNDPINSTANCE: OnceCell<CndpInstance> = OnceCell::new();
+        CNDPINSTANCE.get_or_init(|| CndpInstance::init())
+    }
+
+    fn init() -> CndpInstance {
+        log::debug!("CndpInstance init");
+        let mut cndp = CndpInstance {
+            finfo: RwLock::new(fwd_info {
+                jinfo: std::ptr::null_mut(),
+                flags: 0,
+                quit: 0,
+                opts: app_options {
+                    no_metrics: false,
+                    no_restapi: true,
+                    cli: true,
+                    mode: std::ptr::null_mut(),
+                },
+            }),
+            cne_uid: -1,
+            toml_map: None,
+        };
+        let ret = Self::bind_json(&mut cndp);
+        if ret.is_err() {
+            panic!("bind_json error");
+        }
+        cndp
+    }
+}
+
+// Set Send/Sync Markers to send this across threads.
+unsafe impl Send for jcfg_thd {}
+unsafe impl Sync for jcfg_thd {}
+unsafe impl Send for jcfg_lport {}
+unsafe impl Sync for jcfg_lport {}
+unsafe impl Send for fwd_info {}
+unsafe impl Sync for fwd_info {}
+
+#[derive(Debug)]
+pub enum CndpError {
+    Disconnected,
+    BindJsonError,
+    CneInitializeError,
+    ReaderError,
+    WriterError,
+}
+
+impl Error for CndpError {
+    fn description(&self) -> &str {
+        "Generic Bind Error"
+    }
+
+    fn source(&self) -> Option<&(dyn Error + 'static)> {
+        None
+    }
+}
+
+impl fmt::Display for CndpError {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        match self {
+            CndpError::Disconnected => write!(f, "Cndp disconnected"),
+            CndpError::BindJsonError => write!(f, "Cndp bind json error"),
+            CndpError::CneInitializeError => write!(f, "Cndp initialize error"),
+            CndpError::ReaderError => write!(f, "Cndp reader error"),
+            CndpError::WriterError => write!(f, "Cndp writer error"),
+        }
+    }
+}
+
+pub struct CneRegister {
+    pub cne_uid: i32,
+}
+
+impl CneRegister {
+    pub fn new(s: &str, core_id: Option<usize>) -> CneRegister {
+        let mut cne_uid = -1;
+        unsafe {
+            if cne_id() < 0 {
+                // Need to register Rust thread with Cndp.
+                cne_uid = cne_register(get_cstring_from_str(s).as_ptr());
+                log::debug!("CneRegister for {}, uid = {}", s, cne_uid);
+                if let Some(core_id) = core_id {
+                    let current_cne_lcore_id = cne_lcore_id();
+                    if current_cne_lcore_id != core_id as i32 {
+                        log::debug!(
+                            "Current core id = {}, Set core id = {}",
+                            current_cne_lcore_id,
+                            core_id
+                        );
+                        core_affinity::set_for_current(core_affinity::CoreId { id: core_id });
+                    }
+                }
+            }
+        }
+        CneRegister { cne_uid: cne_uid }
+    }
+}
+
+impl CndpInstance {
+    pub fn bind_json(cndp: &mut CndpInstance) -> Result<(), CndpError> {
+        unsafe {
+            let x = cne_init();
+            if x < 0 {
+                return Err(CndpError::CneInitializeError);
+            }
+            // Register cne.
+            let cne_uid = cne_register(get_cstring_from_str("CndpInstance Bind").as_ptr());
+            let cne_id = cne_id();
+            log::debug!("cne_uid = {}, cne_id = {}", cne_uid, cne_id);
+            cndp.cne_uid = cne_uid;
+            let mut finfo = cndp.finfo.write().unwrap();
+            let finfo_ptr = &mut *finfo as *mut _;
+            // Parse toml.
+            // Get wg_cndp.toml file path.
+            // Assumption is that toml file is copied in same directory as executable. This has to be
+            // either done manually or via some script.
+            let mut cndp_toml_dir = std::env::current_exe().expect("Can't find path to executable");
+            cndp_toml_dir.pop();
+            cndp_toml_dir.push("wg_cndp.toml");
+            let toml_contents = fs::read_to_string(cndp_toml_dir.to_str().unwrap())
+                .expect("Unable to read toml file");
+            // Convert toml as Map<String, Value>
+            let toml_map = toml_contents
+                .parse::<Value>()
+                .ok()
+                .and_then(|r| match r {
+                    Value::Table(table) => Some(table),
+                    _ => None,
+                })
+                .unwrap_or(Map::new());
+            // Parse Json file and initialize AF_XDP socket.
+            let json_file = match toml_map.get("jsonc") {
+                Some(v) => String::from(v.as_str().expect("jsonc should be string")),
+                None => panic!("jsonc is mandatory"),
+            };
+            let jsonfile_cstring = get_cstring_from_str(&json_file);
+            log::info!("CNDP json file = {}", json_file);
+            // Parse CNDP Json file and initialize CNDP.
+            let ret = parse_file(jsonfile_cstring.as_ptr(), finfo_ptr);
+            if ret < 0 {
+                log::error!("Error initializing CNDP with jsonc file");
+                return Err(CndpError::BindJsonError);
+            }
+            // Store toml map.
+            cndp.toml_map = Some(toml_map);
+            // Signals
+            let mut signals = [SIGINT as i32, SIGUSR1 as i32];
+            let signals_ptr = &mut signals[0] as *mut i32;
+            // Register function exit callback.
+            let finfo_cvoid_ptr: *mut c_void = &mut *finfo as *mut _ as *mut c_void;
+            cne_on_exit(
+                Some(Self::cndp_on_exit),
+                finfo_cvoid_ptr,
+                signals_ptr,
+                signals.len() as i32,
+            );
+            return Ok(());
+        }
+    }
+
+    pub fn read_config(key: &str) -> Option<Value> {
+        let cndp = CndpInstance::get_instance();
+        let toml_map = &cndp.toml_map.clone().unwrap();
+        let val = match toml_map.get(key) {
+            Some(v) => Some(v.clone()),
+            None => None,
+        };
+        return val;
+    }
+
+    pub fn get_thread_from_index<'a>(index: i32) -> Option<&'a mut jcfg_thd> {
+        let cndp = CndpInstance::get_instance();
+        let finfo = cndp.finfo.write().unwrap();
+        get_jcfg_thread((*finfo).jinfo, index)
+    }
+
+    pub fn get_thread_lport_from_index<'a>(
+        jcfg_thread: &'a mut jcfg_thd,
+        index: i32,
+    ) -> Option<&'a mut jcfg_lport> {
+        get_jcfg_thread_lport(jcfg_thread, index as u16)
+    }
+
+    pub fn get_interface_details(
+        netdev: &str,
+    ) -> (Option<String>, Option<MacAddr>, Option<IpAddr>) {
+        log::debug!("netdev = {}", netdev);
+        let src_ip = CndpPacket::get_ip_addr_from_ifname(netdev);
+        log::debug!("ipv4_addr = {:?}", src_ip);
+        let src_mac = CndpPacket::get_mac_from_ifname(netdev);
+        log::debug!("src_mac = {:?}", src_mac);
+        return (Some(String::from(netdev)), src_mac, src_ip);
+    }
+
+    pub fn has_cndp_quit() -> bool {
+        let cndp = CndpInstance::get_instance();
+        let finfo = cndp.finfo.read().unwrap();
+        let ret = match (*finfo).quit {
+            1 => true,
+            _ => false,
+        };
+        ret
+    }
+
+    pub fn quit_cndp() {
+        let cndp = CndpInstance::get_instance();
+        let mut finfo = cndp.finfo.write().unwrap();
+        (*finfo).quit = 1;
+    }
+}
+
+impl CndpInstance {
+    pub fn show_metrics(core_id: Option<usize>) {
+        let register = CneRegister::new("cndp_show_metrics", core_id);
+        // Caller should run this function in a separate thread.
+        unsafe {
+            let stat_string = "\n[yellow]*** [cyan:-:italic]Rust UDP Show Metrics [], \
+                    [blue]PID[]: [red]%d[] \
+                    [blue]lcore \
+                    [red]%d[] [blue]Mode[]: [red:-:italic]%s[]\n";
+            let stat_cstring = get_cstring_from_str(stat_string);
+            let test_cstring = get_cstring_from_str("UDP read/write");
+            cne_printf(
+                stat_cstring.as_ptr(),
+                getpid(),
+                cne_lcore_id(),
+                test_cstring.as_ptr(),
+            );
+            let locale_cstring = get_cstring_from_str("");
+            setlocale(LC_ALL as i32, locale_cstring.as_ptr());
+            loop {
+                sleep(1);
+                /* Test for quiting after sleep to avoid calling print_port_stats() */
+                if CndpInstance::has_cndp_quit() {
+                    log::info!("CNDP thread has quit");
+                    break;
+                }
+                {
+                    let cndp = CndpInstance::get_instance();
+                    let mut finfo = cndp.finfo.write().unwrap();
+                    let finfo_ptr = &mut *finfo as *mut _;
+                    print_port_stats_all(finfo_ptr);
+                }
+            }
+            let exit_string = ">>> [cyan]Rust UDP Metrics thread Exiting[]: [green]Bye![]\n";
+            cne_printf(get_cstring_from_str(exit_string).as_ptr());
+            // Destroy metrics.
+            metrics_destroy();
+            // Unregister.
+            cne_unregister(register.cne_uid);
+        }
+    }
+
+    #[no_mangle]
+    pub unsafe extern "C" fn cndp_on_exit(sig: i32, _arg: *mut c_void, exit_type: i32) {
+        let cndp = CndpInstance::get_instance();
+        let mut finfo = cndp.finfo.write().unwrap();
+
+        let terminate_cstring =
+            get_cstring_from_str("\n>>> [cyan]Terminating with signal [green]%d[]\n");
+        if exit_type == CNE_CAUGHT_SIGNAL as i32 {
+            if sig == SIGUSR1 as i32 {
+                return;
+            }
+            cne_printf_pos(99, 1, terminate_cstring.as_ptr(), sig);
+            (*finfo).quit = 1;
+        } else if exit_type == CNE_CALLED_EXIT as i32 {
+            if sig > 0 {
+                cne_printf_pos(99, 1, terminate_cstring.as_ptr(), sig);
+            }
+            cne_printf(get_cstring_from_str(">>> [blue]Closing lport(s)[]\n").as_ptr());
+            jcfg_object_foreach(
+                (*finfo).jinfo,
+                jcfg_cb_type_t_JCFG_THREAD_TYPE,
+                Some(Self::cndp_jcfg_thread_quit),
+                _arg,
+            );
+            cne_printf(get_cstring_from_str(">>> [blue]Done[]\n").as_ptr());
+            // Destroy metrics.
+            metrics_destroy();
+            (*finfo).quit = 1;
+        }
+    }
+
+    #[no_mangle]
+    pub unsafe extern "C" fn cndp_jcfg_thread_quit(
+        _jinfo: *mut jcfg_info_t,
+        obj: *mut c_void,
+        _arg: *mut c_void,
+        _index: i32,
+    ) -> i32 {
+        if obj.is_null() {
+            return 0;
+        }
+        let thd = &mut *(obj as *mut jcfg_thd_t);
+        thd.quit = 1;
+
+        // Get lport count and thread name
+        let lport_cnt = thd.lport_cnt;
+        let thd_name = get_str_from_raw_ptr(thd.name);
+        // Close lports
+        if thd.lports.is_null() || lport_cnt == 0 {
+            log::debug!("No lports attached to thread {} ", thd_name);
+            return 0;
+        } else {
+            log::debug!("Close {} lports attached to thread {}", lport_cnt, thd_name);
+            for i in 0..lport_cnt {
+                let lport = get_item_at_index(i, thd.lports).unwrap();
+                if lport.is_null() {
+                    break;
+                }
+                let cstring = get_cstring_from_str(">>>    [blue]lport [red]%d[] - '[cyan]%s[]'\n");
+                let port_index = (*lport).lpid;
+                let port_name = (*lport).name;
+                cne_printf(cstring.as_ptr(), port_index as i32, port_name);
+                if pktdev_close(port_index) < 0 {
+                    log::debug!("pktdev_close() returned error");
+                }
+                if pktdev_port_remove(port_index as i32) < 0 {
+                    log::debug!("pktdev_port_remove() returned error");
+                }
+                free_lport(lport);
+            }
+        }
+        return 0;
+    }
+}
+
+impl Drop for CndpInstance {
+    fn drop(&mut self) {
+        if self.cne_uid >= 0 {
+            unsafe {
+                let mut finfo = self.finfo.write().unwrap();
+                (*finfo).quit = 1;
+                cne_printf(get_cstring_from_str(">>> [blue]Closing lport(s)[]\n").as_ptr());
+                let finfo_cvoid_ptr: *mut c_void = &mut *finfo as *mut _ as *mut c_void;
+                jcfg_object_foreach(
+                    finfo.jinfo,
+                    jcfg_cb_type_t_JCFG_THREAD_TYPE,
+                    Some(Self::cndp_jcfg_thread_quit),
+                    finfo_cvoid_ptr,
+                );
+                cne_printf(get_cstring_from_str(">>> [blue]Done[]\n").as_ptr());
+                // Destroy metrics.
+                metrics_destroy();
+                // Unregister cne.
+                cne_unregister(self.cne_uid);
+            }
+        }
+    }
+}
+
+pub fn get_tx_buffers(fport: &fwd_port) -> Option<*mut *mut txbuff_t> {
+    // Check if fwd_port processing thread is valid.
+    if fport.thd.is_null() {
+        return None;
+    }
+    let fwd_port_thd = unsafe { &mut *(fport.thd as *mut jcfg_thd_t) };
+    // Check if fwd port thread private data (txbuff**) is valid.
+    if fwd_port_thd.private.is_null() {
+        return None;
+    }
+    // Get TX buffers -> txbuff** pointer
+    let txbuff_pptr = fwd_port_thd.private as *mut *mut txbuff_t;
+    return Some(txbuff_pptr);
+}
+
+pub fn get_rx_mbufs(fport: &fwd_port) -> Option<*mut *mut pktmbuf_s> {
+    // Get RX mbufs -> pktmbuf** pointer
+    let mut rx_mbufs = fport.rx_mbufs;
+    let rx_mbufs = &mut rx_mbufs[0] as *mut *mut _;
+    return Some(rx_mbufs);
+}
+
+pub fn get_tx_mbufs(fport: &fwd_port) -> Option<*mut *mut pktmbuf_s> {
+    // Get TX mbufs -> pktmbuf** pointer
+    let mut tx_mbufs = fport.tx_mbufs;
+    let tx_mbufs = &mut tx_mbufs[0] as *mut *mut _;
+    return Some(tx_mbufs);
+}
+
+pub fn get_item_at_index<T>(index: u16, item_pptr: *mut *mut T) -> Option<*mut T> {
+    if item_pptr.is_null() {
+        return None;
+    }
+    let item = unsafe { *item_pptr.offset(index as isize) };
+    return Some(item);
+}
+
+pub fn get_pktmbuf_data(pkt_mbuf: *const pktmbuf_s) -> Option<*mut u8> {
+    if pkt_mbuf.is_null() {
+        return None;
+    } else {
+        unsafe {
+            let buff_addr = (*pkt_mbuf).buf_addr as *mut u8;
+            let data_off = (*pkt_mbuf).data_off;
+            if buff_addr.is_null() {
+                return None;
+            }
+            let data_addr = buff_addr.offset(data_off as isize);
+            return Some(data_addr);
+        }
+    }
+}
+
+pub fn set_pktmbuf_data_len(pkt_mbuf: *mut pktmbuf_s, data_len: u16) {
+    if pkt_mbuf.is_null() {
+        return;
+    } else {
+        unsafe {
+            (*pkt_mbuf).data_len = data_len;
+        }
+    }
+}
+
+pub fn get_pktmbuf_data_len(pkt_mbuf: *const pktmbuf_s) -> u16 {
+    if pkt_mbuf.is_null() {
+        return 0;
+    } else {
+        let data_len = unsafe { (*pkt_mbuf).data_len };
+        return data_len;
+    }
+}
+
+pub fn get_fwd_port<'a>(lport: *const jcfg_lport_t) -> Option<&'a fwd_port> {
+    // Check if lport is valid.
+    if lport.is_null() {
+        return None;
+    }
+    let lport: &jcfg_lport_t = unsafe { &*(lport as *const jcfg_lport_t) };
+    // Check if lport private data (fwd_port) is valid.
+    if lport.private.is_null() {
+        return None;
+    }
+    let fport: &fwd_port = unsafe { &*(lport.private as *const fwd_port) };
+    return Some(fport);
+}
+
+pub fn get_jcfg_thread<'a>(jinfo: *mut jcfg_info_t, index: i32) -> Option<&'a mut jcfg_thd> {
+    let jcfg_thread = unsafe { jcfg_thd_by_index(jinfo as *mut jcfg_info_t, index) };
+    if jcfg_thread.is_null() {
+        return None;
+    }
+    let jcfg_thread: &mut jcfg_thd = unsafe { &mut *(jcfg_thread as *mut jcfg_thd) };
+    return Some(jcfg_thread);
+}
+
+pub fn get_jcfg_thread_lport<'a>(
+    jcfg_thread: &'a mut jcfg_thd,
+    index: u16,
+) -> Option<&'a mut jcfg_lport> {
+    let lport_pptr = jcfg_thread.lports as *mut *mut jcfg_lport_t;
+    if lport_pptr.is_null() {
+        return None;
+    }
+    if let Some(lport_ptr) = get_item_at_index(index, lport_pptr) {
+        let lport: &mut jcfg_lport = unsafe { &mut *(lport_ptr as *mut jcfg_lport) };
+        return Some(lport);
+    }
+    return None;
+}
diff --git a/src/platform/linux/cndp/cndp_pkt_fwd.jsonc b/src/platform/linux/cndp/cndp_pkt_fwd.jsonc
new file mode 100644
index 0000000..3c446bb
--- /dev/null
+++ b/src/platform/linux/cndp/cndp_pkt_fwd.jsonc
@@ -0,0 +1,187 @@
+{
+    // (R) - Required entry
+    // (O) - Optional entry
+    // All descriptions are optional and short form is 'desc'
+    // The order of the entries in this file are handled when it is parsed and the
+    // entries can be in any order.
+
+    // (R) Application information
+    //    name        - (O) the name of the application
+    //    description - (O) the description of the application
+    "application": {
+        "name": "pktfwd",
+        "description": "A simple packet forwarder"
+    },
+
+    // (O) Default values
+    //    bufcnt - (O) UMEM default buffer count in 1K increments
+    //    bufsz  - (O) UMEM buffer size in 1K increments
+    //    rxdesc - (O) Number of RX ring descriptors in 1K increments
+    //    txdesc - (O) Number of TX ring descriptors in 1K increments
+    //    cache  - (O) MBUF Pool cache size in number of entries
+    //    mtype  - (O) Memory type for mmap allocations
+    "defaults": {
+        "bufcnt": 16,
+        "bufsz": 2,
+        "rxdesc": 2,
+        "txdesc": 2,
+        "cache": 256,
+        "mtype": "2MB"
+    },
+
+    // List of all UMEM's to be created
+    // key/val - (R) The 'key' is the name of the umem for later reference.
+    //               The 'val' is the object describing the UMEM buffer.
+    //               Multiple umem regions can be defined.
+    // A UMEM can support multiple lports using the regions array. Each lports can use
+    // one of the regions.
+    //    bufcnt  - (R) The number of buffers in 1K increments in the UMEM space.
+    //    bufsz   - (R) The size in 1K increments of each buffer in the UMEM space.
+    //    mtype   - (O) If missing or empty string or missing means use 4KB or default system pages.
+    //    regions - (O) Array of sizes one per region in 1K increments, total must be <= bufcnt
+    //    rxdesc  - (O) Number of RX descriptors to be allocated in 1K increments,
+    //                  if not present or zero use defaults.rxdesc, normally zero.
+    //    txdesc  - (O) Number of TX descriptors to be allocated in 1K increments,
+    //                  if not present or zero use defaults.txdesc, normally zero.
+    //    description | desc - (O) Description of the umem space.
+    "umems": {
+        "umem0": {
+            "bufcnt": 64,
+            "bufsz": 2,
+            "mtype": "2MB",
+            "regions": [
+                16,
+                16,
+                16,
+                16,
+            ],
+            "rxdesc": 0,
+            "txdesc": 0,
+            "description": "UMEM Description 0"
+        }
+    },
+
+
+    // List of all lports to be used in the application
+    // An lport is defined by a netdev/queue ID pair, which is a socket containing a Rx/Tx ring pair.
+    // Each queue ID is assigned to a single socket or a socket is the lport defined by netdev/qid.
+    // Note: A netdev can be shared between lports as the qid is unique per lport
+    //       If netdev is not defined or empty then it must be a virtual interface and not
+    //       associated with a netdev/queue ID.
+    // key/val - (R) The 'key' is the logical name e.g. 'eth0:0', 'eth1:0', ... to be used by the
+    //               application to reference an lport. The 'val' object contains information about
+    //               each lport.
+    //    netdev        - (R) The netdev device to be used, the part before the colon
+    //                     must reflect the netdev name
+    //    pmd           - (R) All PMDs have a name i.e. 'net_af_xdp', 'ring', ...
+    //    qid           - (R) Is the queue id to use for this lport, defined by ethtool command line
+    //    umem          - (R) The UMEM assigned to this lport
+    //    region        - (O) UMEM region index value, default region 0
+    //    busy_poll     - (O) Enable busy polling support, true or false, default false
+    //    busy_timeout  - (O) 1-65535 or 0 - use default value, values in milliseconds
+    //    busy_budget   - (O) 0xFFFF disabled, 0 use default, >0 budget value
+    //    inhibit_prog_load - (O) inhibit loading the BPF program if true, default false
+    //    force_wakeup  - (O) force TX wakeup calls for CVL NIC, default false
+    //    skb_mode      - (O) Enable XDP_FLAGS_SKB_MODE when creating af_xdp socket, forces copy mode, default false
+    //    description   - (O) the description, 'desc' can be used as well
+    "lports": {
+        "enp134s0f0:0": {
+            "pmd": "net_af_xdp",
+            "qid": 23,
+            "umem": "umem0",
+            "busy_poll": true,
+            "region": 0,
+            "description": "LAN 0 port"
+        },
+        "enp134s0f0:1": {
+            "pmd": "net_af_xdp",
+            "qid": 33,
+            "umem": "umem0",
+            "busy_poll": true,
+            "region": 1,
+            "description": "LAN 1 port"
+        },
+        "enp28s0f1:0": {
+            "pmd": "net_af_xdp",
+            "qid": 12,
+            "umem": "umem0",
+            "busy_poll": true,
+            "region": 2,
+            "description": "LAN 0 port"
+        },
+        "enp28s0f1:1": {
+            "pmd": "net_af_xdp",
+            "qid": 13,
+            "umem": "umem0",
+            "busy_poll": true,
+            "region": 3,
+            "description": "LAN 1 port"
+        }
+    },
+
+    // (O) Define the lcore groups for each thread to run
+    //     Can be integers or a string for a range of lcores
+    //     e.g. [10], [10-14,16], [10-12, 14-15, 17-18, 20]
+    // Names of a lcore group and its lcores assigned to the group.
+    // The initial group is for the main thread of the application.
+    // The default group is special and is used if a thread if not assigned to a group.
+    "lcore-groups": {
+        "initial": [22],
+        "group0": [25],
+        "group1": [35],
+        "group2": [36],
+        "group3": [37],
+        "default": ["22-37"]
+    },
+
+    // (O) Set of common options application defined.
+    //     The Key can be any string and value can be boolean, string, array or integer
+    //     An array must contain only a single value type, boolean, integer, string and
+    //     can't be a nested array.
+    //   no-metrics - (O) Disable metrics gathering and thread
+    //   no-restapi - (O) Disable RestAPI support
+    //   cli        - (O) Enable/Disable CLI supported
+    //   mode       - (O) Mode type [drop | rx-only], tx-only, [lb | loopback], fwd, acl-strict, acl-permissive
+    "options": {
+        "no-metrics": false,
+        "no-restapi": false,
+        "cli": true,
+        "mode": "drop"
+    },
+
+    // List of threads to start and information for that thread. Application can start
+    // it's own threads for any reason and are not required to be configured by this file.
+    //
+    //   Key/Val   - (R) A unique thread name.
+    //                   The format is <type-string>[:<identifier>] the ':' and identifier
+    //                   are optional if all thread names are unique
+    //      group  - (O) The lcore-group this thread belongs to. The
+    //      lports - (O) The list of lports assigned to this thread and can not shared lports.
+    //      description | desc - (O) The description
+    "threads": {
+        "main": {
+            "group": "initial",
+            "description": "CLI Thread"
+        },
+        "fwd:0": {
+            "group": "group0",
+            "lports": ["enp134s0f0:0"],
+            "description": "Thread 0"
+        },
+        "fwd:1": {
+            "group": "group1",
+            "lports": ["enp134s0f0:1"],
+            "description": "Thread 1"
+        },
+        "fwd:2": {
+            "group": "group2",
+            "lports": ["enp28s0f1:0"],
+            "description": "Thread 2"
+        },
+        "fwd:3": {
+            "group": "group3",
+            "lports": ["enp28s0f1:1"],
+            "description": "Thread 3"
+        }       
+    }
+}
diff --git a/src/platform/linux/cndp/cndprustwg.sh b/src/platform/linux/cndp/cndprustwg.sh
new file mode 100755
index 0000000..d83c858
--- /dev/null
+++ b/src/platform/linux/cndp/cndprustwg.sh
@@ -0,0 +1,88 @@
+#!/bin/bash
+# SPDX-License-Identifier: BSD-3-Clause
+# Copyright(c) 2019-2021 Intel Corporation.
+
+# Run this script as sudo
+# Usage: ./cndprustwg.sh [debug|release] [cndp-packet|cndp-ping|wireguard-rs].
+# Wireguard CNDP Root folder
+WG_ROOT="/home/manoj/wireguard/cndp/wireguard-rs"
+# Build type (debug/release). Use release by default.
+BUILD=${1:-release}
+# Build type (debug/release). Use release by default.
+EXE=${2:-wireguard-rs}
+# Set private key file.
+# Private/Public key should be generated once before running this script 
+# using following commands.
+# 1) Private key -> "sudo wg genkey > rsuwgprivate"
+# 2) Public key  -> "wg pubkey < rsuwgprivate > rsuwgpublic"
+PRIVATE_KEY="/home/manoj/wireguard/rsuwgprivate"
+# Wireguard MTU size.
+WG_MTU=1420
+# Wirguard interface local ip.
+WG_LOCAL_IP=10.0.4.1
+# Wireguard local listen port.
+WG_LOCAL_LISTEN_PORT=5400
+# Wirguard interface remote peer ip.
+WG_PEER_IP=10.0.4.2
+# Wireguard remote peer listen port.
+WG_PEER_LISTEN_PORT=5500
+# Wireguard remote peer endpoint ip.
+WG_PEER_ENDPOINT_IP=48.0.0.155
+# Wireguard remote peer endpoint.
+WG_PEER_ENDPOINT=$WG_PEER_ENDPOINT_IP:$WG_PEER_LISTEN_PORT
+# Peer public key (base64 encoded)
+WG_PEER_PUBLIC_KEY="DV/f0jntATrrng/D7jVmqBz6IFlHWjPT/QsmhDut5Es="
+
+# Delete existing interface
+sudo ip link del rsuwg0
+# Wait for interface to go down.
+sleep 1
+# Copy wg_cndp.toml file to target directory containing the executable.
+cp $WG_ROOT/src/platform/linux/cndp/wg_cndp.toml $WG_ROOT/target/$BUILD/wg_cndp.toml
+# Start and configure wireguard
+if [ "$BUILD" == "debug" ]; then
+	RUST_LOG_VAL=debug
+else
+	RUST_LOG_VAL=info
+fi
+# Check the binary to execute
+if [ "$EXE" == "cndp-ping" ]; then
+	RUST_EXE=cndp-ping
+	ARGS="--disable-drop-privileges --device rsuwg0 --local $WG_LOCAL_IP --remote $WG_PEER_IP --interval 1000"
+elif [ "$EXE" == "cndp-packet" ]; then
+	RUST_EXE=cndp-packet
+	TRAFFIC_GEN_MAC=3c:fd:fe:a8:5f:bc
+	MODE=${3:-send}
+	if [ "$MODE" == "send" ]; then
+		ARGS="--disable-drop-privileges --device rsuwg0 --traffic-gen-mac $TRAFFIC_GEN_MAC --send"
+	else
+		ARGS="--disable-drop-privileges --device rsuwg0 --traffic-gen-mac $TRAFFIC_GEN_MAC"
+	fi
+else
+	RUST_EXE=wireguard-rs
+	ARGS="--disable-drop-privileges rsuwg0"
+fi
+sudo RUST_LOG=$RUST_LOG_VAL LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$WG_ROOT/build LD_PRELOAD=$LD_LIBRARY_PATH/libpmd_af_xdp.so $WG_ROOT/target/$BUILD/$RUST_EXE $ARGS
+# Wait for interface to come up.
+sleep 1
+
+# Set wireguard interface ip addr.
+sudo ip addr add $WG_LOCAL_IP/24 dev rsuwg0
+# Set private key in wg interface.
+sudo wg set rsuwg0 private-key $PRIVATE_KEY
+# Set MTU.
+sudo ip link set mtu $WG_MTU dev rsuwg0
+# Set listening port.
+sudo wg set rsuwg0 listen-port $WG_LOCAL_LISTEN_PORT
+# Set remote peer public key, wireguard ip, endpoint and listen port.
+if [ "$EXE" == "cndp-packet" ]; then
+	WG_PEER_IP1=10.50.0.2 # Remote IP used by packet generator.
+	ALLOWED_IPS=$WG_PEER_IP/32,$WG_PEER_IP1/32
+else
+	ALLOWED_IPS=$WG_PEER_IP/32
+fi
+sudo wg set rsuwg0 peer $WG_PEER_PUBLIC_KEY allowed-ips $ALLOWED_IPS endpoint $WG_PEER_ENDPOINT
+# Enable wireguard interface.
+sudo ip link set rsuwg0 up
+# Wait for interface to come up.
+sleep 1
diff --git a/src/platform/linux/cndp/endpoint.rs b/src/platform/linux/cndp/endpoint.rs
new file mode 100644
index 0000000..d5fe10e
--- /dev/null
+++ b/src/platform/linux/cndp/endpoint.rs
@@ -0,0 +1,43 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+
+use pnet::datalink::MacAddr;
+use std::net::IpAddr;
+use std::net::SocketAddr;
+
+use super::super::super::Endpoint;
+
+#[derive(Debug, Clone, Copy)]
+pub struct CndpEndpoint {
+    pub ip: Option<IpAddr>,
+    pub port: Option<u16>,
+    pub mac: Option<MacAddr>,
+}
+
+impl Endpoint for CndpEndpoint {
+    fn from_address(sock_addr: SocketAddr) -> CndpEndpoint {
+        CndpEndpoint {
+            ip: Some(sock_addr.ip()),
+            port: Some(sock_addr.port()),
+            mac: None,
+        }
+    }
+
+    fn into_address(&self) -> SocketAddr {
+        SocketAddr::new(self.ip.unwrap(), self.port.unwrap())
+    }
+
+    fn clear_src(&mut self) {
+    }
+}
+
+impl CndpEndpoint {
+    pub fn new(ip: Option<IpAddr>, port: Option<u16>, mac: Option<MacAddr>) -> CndpEndpoint {
+        CndpEndpoint {
+            ip: ip,
+            port: port,
+            mac: mac,
+        }
+    }
+}
diff --git a/src/platform/linux/cndp/eth_packet_rw.rs b/src/platform/linux/cndp/eth_packet_rw.rs
new file mode 100644
index 0000000..a9940fc
--- /dev/null
+++ b/src/platform/linux/cndp/eth_packet_rw.rs
@@ -0,0 +1,845 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+
+use hjul::{Runner, Timer};
+use std::collections::HashSet;
+use std::error::Error;
+use std::ops::Deref;
+use std::slice;
+use std::sync::mpsc::{sync_channel, Receiver, RecvTimeoutError, SyncSender};
+use std::sync::{Arc, RwLock};
+use std::thread;
+use std::time::Duration;
+use std::time::SystemTime;
+
+use super::super::super::endpoint::Endpoint;
+use super::endpoint::CndpEndpoint;
+
+use super::cndp::*;
+use super::packet::*;
+use super::util::*;
+
+pub trait Reader<E: Endpoint>: Send + Sync {
+    type Error: Error;
+
+    fn read(&mut self, buf: &mut [u8]) -> Result<(usize, E), Self::Error>;
+}
+
+pub trait Writer<E: Endpoint>: Send + Sync + 'static {
+    type Error: Error;
+
+    fn write(&self, buf: Vec<u8>, dst: &mut E) -> Result<(), Self::Error>;
+}
+
+pub trait PacketReadWrite: Send + Sync + 'static {
+    type Error: Error;
+    type Endpoint: Endpoint;
+
+    /* Until Rust gets type equality constraints these have to be generic */
+    type Writer: Writer<Self::Endpoint>;
+    type Reader: Reader<Self::Endpoint>;
+}
+
+pub trait Owner: Send {
+    type Error: Error;
+}
+
+pub trait PlatformPacketReadWrite: PacketReadWrite {
+    type Owner: Owner;
+
+    /// Bind returning the reader/writer and
+    /// an associated instance of the owner type, which closes upon "drop"
+    #[allow(clippy::type_complexity)]
+    fn bind() -> Result<(Self::Reader, Self::Writer, Self::Owner), Self::Error>;
+}
+
+// CNDP Packet Json Data
+pub struct CndpPacketJsonData<'a> {
+    pub iface_name: Option<String>,
+    pub endpoint: Option<CndpEndpoint>,
+    pub fwd_port_thd_reader: &'a mut jcfg_thd,
+    pub fwd_port_thd_writer: &'a mut jcfg_thd,
+    pub lport_reader: jcfg_lport,
+    pub lport_writer: jcfg_lport,
+    pub reader_core_id: Option<usize>,
+    pub writer_core_id: Option<usize>,
+    pub writer_sender_channel_core_id: Option<usize>,
+}
+
+// CNDP Packet Bind
+pub struct CndpPacketReader<'a> {
+    pub iface_name: Option<String>,
+    endpoint: Option<CndpEndpoint>,
+    fwd_port_thd: Arc<RwLock<&'a mut jcfg_thd>>,
+    lport: jcfg_lport,
+    core_id: Option<usize>,
+    cne_uids: RwLock<HashSet<i32>>,
+    cur_pkt_index: i32,
+    last_num_pkts_read: u16,
+}
+
+pub struct CndpPacketBufferedWriterInner<'a> {
+    pub iface_name: Option<String>,
+    endpoint: Option<CndpEndpoint>,
+    fwd_port_thd: Arc<RwLock<&'a mut jcfg_thd>>,
+    lport: jcfg_lport,
+    core_id: Option<usize>,
+    cne_uids: RwLock<HashSet<i32>>,
+    pkts: RwLock<Vec<PacketSendData>>,
+    runner: Runner,
+    timer: RwLock<Option<Timer>>,
+}
+
+pub struct CndpPacketBufferedWriter<'a> {
+    inner: Arc<CndpPacketBufferedWriterInner<'a>>,
+}
+
+pub struct PacketSendData {
+    pub buf: Vec<u8>,
+    pub src_endpoint: CndpEndpoint,
+    pub dst_endpoint: CndpEndpoint,
+}
+
+pub struct CndpPacketWriterSenderChannel<'a> {
+    iface_name: Option<String>,
+    endpoint: Option<CndpEndpoint>,
+    fwd_port_thd: Arc<RwLock<&'a mut jcfg_thd>>,
+    core_id: Option<usize>,
+    cne_uids: RwLock<HashSet<i32>>,
+    sender: SyncSender<PacketSendData>,
+}
+
+pub struct CndpPacketWriterReceiverChannel<'a> {
+    fwd_port_thd: Arc<RwLock<&'a mut jcfg_thd>>,
+    lport: jcfg_lport,
+    core_id: Option<usize>,
+    receiver: Receiver<PacketSendData>,
+}
+
+struct CndpPacketCommon {}
+
+#[derive(Clone)]
+pub struct CndpPacketSyncChannel {}
+
+#[derive(Clone)]
+pub struct CndpPacketBuffered {}
+
+impl PacketReadWrite for CndpPacketSyncChannel {
+    type Error = CndpError;
+    type Endpoint = CndpEndpoint;
+    type Reader = CndpPacketReader<'static>;
+    type Writer = CndpPacketWriterSenderChannel<'static>;
+}
+
+impl PacketReadWrite for CndpPacketBuffered {
+    type Error = CndpError;
+    type Endpoint = CndpEndpoint;
+    type Reader = CndpPacketReader<'static>;
+    type Writer = CndpPacketBufferedWriter<'static>;
+}
+
+impl CndpPacketCommon {
+    const READ_SLEEP_TIME_IN_MICROS: u64 = 20;
+    const READ_BURST_PKTS: u16 = 128;
+    const WRITE_THRESHOLD_NUM_PKTS: usize = 32;
+    const WRITE_WAIT_DURATION_IN_MICROS: u64 = 10;
+    const WRITE_CALLBACK_TIMER_DURATION_IN_MICROS: u64 = 100;
+}
+
+impl<'a> Reader<CndpEndpoint> for CndpPacketReader<'a> {
+    type Error = CndpError;
+    fn read(&mut self, buf: &mut [u8]) -> Result<(usize, CndpEndpoint), Self::Error> {
+        // If this function is called from a Wireguard Rust thread register it with CNDP.
+        let register = CneRegister::new("CndpPacketReader", self.core_id);
+        if register.cne_uid > 0 {
+            let mut cne_uids = self.cne_uids.write().unwrap();
+            (*cne_uids).insert(register.cne_uid);
+        }
+        // Loop till we get atleast 1 packet or thread quits.
+        loop {
+            if CndpPacketCommon::has_fwd_port_thd_quit(&self.fwd_port_thd)
+                || CndpInstance::has_cndp_quit()
+            {
+                log::debug!("Cndp Packet Reader forward port thread quitted");
+                return Err(CndpError::Disconnected);
+            }
+            // Get lport for fwd thread.
+            let lport = self.lport;
+            let (eth_payload_len, endpoint) = self.read_lport(buf, &lport);
+            if eth_payload_len > 0 {
+                return Ok((eth_payload_len, endpoint));
+            } else {
+                // If there are no packets then sleep for sometime.
+                // This will reduce CPU utilization instead of reading in tight loop
+                // and keeping CPU busy at 100%.
+                if self.last_num_pkts_read == 0 {
+                    thread::sleep(Duration::from_micros(
+                        CndpPacketCommon::READ_SLEEP_TIME_IN_MICROS,
+                    ));
+                }
+            }
+        }
+    }
+}
+
+impl<'a> CndpPacketReader<'a> {
+    fn read_lport(&mut self, buf: &mut [u8], lport: &jcfg_lport) -> (usize, CndpEndpoint) {
+        if let Some(fport) = get_fwd_port(lport) {
+            // Get RX pktmbuf buffers -> pktmbuf** pointer
+            let rx_pktmbufs_pptr = get_rx_mbufs(&fport).unwrap();
+            if self.last_num_pkts_read == 0 {
+                // Get burst of RX packets.
+                self.last_num_pkts_read = unsafe {
+                    pktdev_rx_burst_fn(
+                        fport.lport as u16,
+                        rx_pktmbufs_pptr,
+                        CndpPacketCommon::READ_BURST_PKTS,
+                    )
+                };
+                if self.last_num_pkts_read > 0 {
+                    self.cur_pkt_index = 0;
+                    log::debug!(
+                        "Read bulk {} Packets at time {}",
+                        self.last_num_pkts_read,
+                        SystemTime::now()
+                            .duration_since(std::time::UNIX_EPOCH)
+                            .unwrap()
+                            .as_micros()
+                    );
+                }
+            }
+            // Process RX packet.
+            if self.last_num_pkts_read > 0 {
+                // Get a single RX pktmbuf.
+                let pkt_mbuf = get_item_at_index(self.cur_pkt_index as u16, rx_pktmbufs_pptr);
+                self.cur_pkt_index = self.cur_pkt_index + 1;
+                // Parse pktmbuf to get eth payload, length and endpoint.
+                let (eth_payload_len, endpoint) = CndpPacketCommon::parse_pktmbuf(buf, &pkt_mbuf);
+                // If all packets are processed free them.
+                if self.cur_pkt_index == self.last_num_pkts_read as i32 {
+                    // Free RX buffers.
+                    unsafe {
+                        pktmbuf_free_bulk_fn(rx_pktmbufs_pptr, self.last_num_pkts_read as u32)
+                    };
+                    self.cur_pkt_index = -1;
+                    self.last_num_pkts_read = 0;
+                }
+                return (eth_payload_len as usize, endpoint);
+            }
+        }
+        return (0, CndpEndpoint::new(None, None, None));
+    }
+}
+
+impl<'a> Drop for CndpPacketReader<'a> {
+    fn drop(&mut self) {
+        log::debug!("CndpPacketReader drop");
+        let cne_uids = self.cne_uids.write().unwrap();
+        CndpPacketCommon::unregister_cne_uids(&(*cne_uids));
+    }
+}
+
+impl CndpPacketCommon {
+    pub fn get_json_data<'a>() -> CndpPacketJsonData<'a> {
+        // Reader uses fwd thread 0 (at index 3) and lport index 0 for fwd thread 2.
+        let fwd_port_thd_reader =
+            CndpInstance::get_thread_from_index(3).expect("No fwd thread present at index 3");
+        let lport_reader = *CndpInstance::get_thread_lport_from_index(fwd_port_thd_reader, 0)
+            .expect("No lport present at index 0");
+
+        // Get interface details
+        let (iface_name, src_mac, src_ip) =
+            CndpInstance::get_interface_details(get_str_from_raw_ptr(lport_reader.netdev));
+        let bind_endpoint = CndpEndpoint::new(src_ip, None, src_mac);
+        let reader_thread_coreid = match CndpInstance::read_config("packet_reader_thread_coreid") {
+            Some(v) => Some(v.as_integer().expect("core id should be integer") as usize),
+            None => None,
+        };
+
+        // Writer uses fwd thread 1 (at index 4) and lport index 0 for fwd thread 3.
+        let fwd_port_thd_writer =
+            CndpInstance::get_thread_from_index(4).expect("No fwd thread present at index 4");
+        let lport_writer = *CndpInstance::get_thread_lport_from_index(fwd_port_thd_writer, 0)
+            .expect("No lport present at index 0");
+        let writer_thread_coreid = match CndpInstance::read_config("packet_writer_thread_coreid") {
+            Some(v) => Some(v.as_integer().expect("core id should be integer") as usize),
+            None => None,
+        };
+        let writer_sender_channel_thread_coreid =
+            match CndpInstance::read_config("packet_writer_sender_channel_thread_coreid") {
+                Some(v) => Some(v.as_integer().expect("core id should be integer") as usize),
+                None => None,
+            };
+        // Create CndpJsonBind return value.
+        let json_data = CndpPacketJsonData {
+            iface_name: iface_name,
+            endpoint: Some(bind_endpoint),
+            fwd_port_thd_reader: fwd_port_thd_reader,
+            fwd_port_thd_writer: fwd_port_thd_writer,
+            lport_reader: lport_reader,
+            lport_writer: lport_writer,
+            reader_core_id: reader_thread_coreid,
+            writer_core_id: writer_thread_coreid,
+            writer_sender_channel_core_id: writer_sender_channel_thread_coreid,
+        };
+        return json_data;
+    }
+
+    pub fn parse_pktmbuf(
+        buf: &mut [u8],
+        pkt_mbuf: &Option<*mut pktmbuf_s>,
+    ) -> (usize, CndpEndpoint) {
+        // Validate pktmbuf.
+        if pkt_mbuf.is_none() {
+            log::debug!("Cndp Reader pktmbuf is null");
+            return (0, CndpEndpoint::new(None, None, None));
+        };
+        let pkt_mbuf = pkt_mbuf.unwrap();
+        // Get pktmbuf data length.
+        let data_len = get_pktmbuf_data_len(pkt_mbuf);
+        if data_len == 0 {
+            log::debug!("Cndp Reader pktmbuf data len = 0");
+            return (0, CndpEndpoint::new(None, None, None));
+        }
+        // Get pktmbuf data pointer.
+        let pkt_data_addr = get_pktmbuf_data(pkt_mbuf);
+        if pkt_data_addr.is_none() {
+            log::debug!("Cndp Reader pktmbuf data is null");
+            return (0, CndpEndpoint::new(None, None, None));
+        };
+        let pkt_data_addr = pkt_data_addr.unwrap();
+        // Create CNDP packet structure.
+        let mut cndp_eth_packet = CndpPacket::new(pkt_data_addr, data_len as usize).unwrap();
+        let (eth_payload, eth_payload_len) = cndp_eth_packet.get_eth_payload_ptr();
+        if eth_payload_len > 0 {
+            let eth_payload = eth_payload.unwrap();
+            if eth_payload.is_null() {
+                // Eth payload should not be null if eth_payload_len > 0
+                panic!("Eth payload is null when eth payload length > 0");
+            }
+            let p = unsafe { slice::from_raw_parts_mut(eth_payload, eth_payload_len as usize) };
+            buf[..eth_payload_len as usize].copy_from_slice(&p[..]);
+        } else {
+            log::debug!("Cndp Reader Packet payload len = 0");
+        }
+        let endpoint = CndpEndpoint::new(
+            cndp_eth_packet.src_ip,
+            cndp_eth_packet.src_port,
+            cndp_eth_packet.src_mac,
+        );
+        log::debug!(
+            "Read 1 packet Ethernet Packet(size = {}) at time {}",
+            data_len,
+            SystemTime::now()
+                .duration_since(std::time::UNIX_EPOCH)
+                .unwrap()
+                .as_micros()
+        );
+        return (eth_payload_len as usize, endpoint);
+    }
+
+    pub fn update_pktmbuf(
+        buf: &[u8],
+        pkt_mbuf: &Option<*mut pktmbuf_s>,
+        src: &CndpEndpoint,
+        dst: &CndpEndpoint,
+    ) -> i32 {
+        // Validate pktmbuf.
+        if pkt_mbuf.is_none() {
+            log::debug!("Cndp Reader pktmbuf is null");
+            return -1;
+        };
+        let pkt_mbuf = pkt_mbuf.unwrap();
+        // Get total length of packet.
+        let data_len = CndpPacket::get_eth_packet_len(buf.len()) as u16;
+        // Get pktmbuf data pointer.
+        let pkt_data_addr = get_pktmbuf_data(pkt_mbuf);
+        if pkt_data_addr.is_none() {
+            log::debug!("Cndp Reader pktmbuf data is null");
+            return -1;
+        };
+        let pkt_data_addr = pkt_data_addr.unwrap();
+        // Create CNDP packet structure.
+        let mut cndp_eth_packet = CndpPacket::new(pkt_data_addr, data_len as usize).unwrap();
+        // Update CNDP packet.
+        cndp_eth_packet.update_eth_packet(src.mac.unwrap(), dst.mac.unwrap(), buf, true);
+        // Set packet length.
+        set_pktmbuf_data_len(pkt_mbuf, data_len);
+        return 0;
+    }
+
+    pub fn free_tx_buffers(lport_index: u16, tx_pktmbufs_pptr: *mut *mut pktmbuf_s, n_pkts: u16) {
+        unsafe {
+            if tx_pktmbufs_pptr.is_null() {
+                return;
+            }
+            /*NOTE: the RX burst is needed to prevent lockups on CVL*/
+            let n_pkts = pktdev_rx_burst_fn(lport_index, tx_pktmbufs_pptr, n_pkts);
+            if n_pkts > 0 {
+                pktmbuf_free_bulk_fn(tx_pktmbufs_pptr, n_pkts as u32);
+            }
+        }
+    }
+
+    pub fn send_pkts(pkts: &mut Vec<PacketSendData>, lport: &jcfg_lport) -> i32 {
+        if let Some(fport) = get_fwd_port(lport) {
+            // Get TX pktmbuf buffers -> pktmbuf** pointer
+            let tx_pktmbufs_pptr = get_tx_mbufs(&fport).unwrap();
+            let num_pkts_to_send = pkts.len();
+            let n_pkts = unsafe {
+                pktdev_buf_alloc(
+                    fport.lport as i32,
+                    tx_pktmbufs_pptr,
+                    num_pkts_to_send as u16,
+                ) as u16
+            };
+            if n_pkts < num_pkts_to_send as u16 {
+                log::debug!("Cannot allocate enough buffers to send all packets");
+                log::debug!("Requested = {}, Allocated = {}", num_pkts_to_send, n_pkts);
+            }
+            if n_pkts > 0 {
+                log::debug!("n_pkts = {}", n_pkts);
+                log::debug!(
+                    "start process {} packet at time {}",
+                    n_pkts,
+                    SystemTime::now()
+                        .duration_since(std::time::UNIX_EPOCH)
+                        .unwrap()
+                        .as_micros()
+                );
+                for i in 0..n_pkts {
+                    // Get data buf.
+                    // Remove packet from front of the list and move the ownership out of the list.
+                    let pkt = pkts.remove(0 as usize);
+                    let buf = pkt.buf;
+                    let src_endpoint = pkt.src_endpoint;
+                    let dst_endpoint = pkt.dst_endpoint;
+                    // Get a single TX pktmbuf.
+                    let pkt_mbuf = get_item_at_index(i as u16, tx_pktmbufs_pptr);
+                    // Update pktmbuf with data (payload + ip/udp/eth headers).
+                    let ret = CndpPacketCommon::update_pktmbuf(
+                        &buf,
+                        &pkt_mbuf,
+                        &src_endpoint,
+                        &dst_endpoint,
+                    );
+                    if ret < 0 {
+                        log::error!("update_pktmbuf failed");
+                        // Free buffers and return
+                        CndpPacketCommon::free_tx_buffers(
+                            fport.lport as u16,
+                            tx_pktmbufs_pptr,
+                            n_pkts,
+                        );
+                        return -1;
+                    }
+                }
+                let mut n = 0 as u16;
+                let mut n_pkts_to_send = n_pkts;
+                loop {
+                    // TX buffers (pktmbufs) starting at index n.
+                    let tx_mbufs = get_tx_mbufs(&fport).unwrap();
+                    let tx_mbufs = unsafe { tx_mbufs.offset(n as isize) };
+                    n = unsafe { pktdev_tx_burst_fn(fport.lport as u16, tx_mbufs, n_pkts_to_send) };
+                    log::debug!(
+                        "Sent {} packets at time {}",
+                        n,
+                        SystemTime::now()
+                            .duration_since(std::time::UNIX_EPOCH)
+                            .unwrap()
+                            .as_micros()
+                    );
+                    if n_pkts_to_send <= n {
+                        break;
+                    }
+                    log::debug!("Couldn't send all packets. Retry");
+                    n_pkts_to_send -= n;
+                }
+            }
+            CndpPacketCommon::free_tx_buffers(fport.lport as u16, tx_pktmbufs_pptr, n_pkts as u16);
+        }
+        return 0;
+    }
+
+    pub fn unregister_cne_uids(cne_uids: &HashSet<i32>) {
+        for cne_uid in cne_uids {
+            unsafe {
+                if cne_unregister(*cne_uid) < 0 {
+                    log::error!("cne_unregister failed for cne_uid = {}", *cne_uid);
+                }
+            }
+        }
+    }
+
+    pub fn has_fwd_port_thd_quit<'a>(fwd_port_thd: &Arc<RwLock<&'a mut jcfg_thd>>) -> bool {
+        let fwd_port_thd = fwd_port_thd.read().unwrap();
+        let ret = match (*fwd_port_thd).quit {
+            0 => false,
+            _ => true,
+        };
+        ret
+    }
+}
+
+impl PlatformPacketReadWrite for CndpPacketSyncChannel {
+    type Owner = CndpPacketOwner<'static>;
+    fn bind() -> Result<(Self::Reader, Self::Writer, Self::Owner), Self::Error> {
+        log::info!("Wireguard called bind ");
+        let register = CneRegister::new("CndpPacketSyncChannel", None);
+        // Get Cndp Packet Json Data.
+        let json_data = CndpPacketCommon::get_json_data();
+        // Create Arc RwLock.
+        let fwd_port_thd_reader_arc_mutex = Arc::new(RwLock::new(json_data.fwd_port_thd_reader));
+        // Create Cndp Packet Reader.
+        let reader = CndpPacketReader {
+            iface_name: json_data.iface_name.clone(),
+            endpoint: json_data.endpoint,
+            fwd_port_thd: Arc::clone(&fwd_port_thd_reader_arc_mutex),
+            lport: json_data.lport_reader,
+            core_id: json_data.reader_core_id,
+            cne_uids: RwLock::new(HashSet::new()),
+            cur_pkt_index: -1,
+            last_num_pkts_read: 0,
+        };
+        // Create Cndp Packet Writer channel.
+        // Packet writer send channel thread, sends packet to the channel.
+        // Packet writer receive channel thread, reads packet from channel,
+        // creates ethernet packet, accumulates the packets till a given
+        // threshold or till timeout occurs and then sends the burst of packet to peer node.
+        let (sender_w, receiver_w) = sync_channel::<PacketSendData>(1024);
+        // Create Arc RwLock.
+        let fwd_port_thd_writer_arc_mutex = Arc::new(RwLock::new(json_data.fwd_port_thd_writer));
+        let writer_recv = CndpPacketWriterReceiverChannel {
+            fwd_port_thd: Arc::clone(&fwd_port_thd_writer_arc_mutex),
+            lport: json_data.lport_writer,
+            core_id: json_data.writer_core_id,
+            receiver: receiver_w,
+        };
+        let writer = CndpPacketWriterSenderChannel {
+            iface_name: json_data.iface_name.clone(),
+            endpoint: json_data.endpoint,
+            fwd_port_thd: Arc::clone(&fwd_port_thd_writer_arc_mutex),
+            core_id: json_data.writer_sender_channel_core_id,
+            cne_uids: RwLock::new(HashSet::new()),
+            sender: sender_w,
+        };
+        let owner = CndpPacketOwner {
+            cne_uid: register.cne_uid,
+            fwd_port_thd_reader: Arc::clone(&fwd_port_thd_reader_arc_mutex),
+            fwd_port_thd_writer: Arc::clone(&fwd_port_thd_writer_arc_mutex),
+        };
+        // Packet writer receive channel thread.
+        thread::spawn(move || {
+            writer_recv.write();
+        });
+        return Ok((reader, writer, owner));
+    }
+}
+
+impl Writer<CndpEndpoint> for CndpPacketWriterSenderChannel<'static> {
+    type Error = CndpError;
+    fn write(&self, buf: Vec<u8>, dst: &mut CndpEndpoint) -> Result<(), Self::Error> {
+        // If this function is called from a Wireguard Rust thread register it with CNDP.
+        let register = CneRegister::new("CndpPacketWriterSenderChannel", self.core_id);
+        if register.cne_uid > 0 {
+            let mut cne_uids = self.cne_uids.write().unwrap();
+            (*cne_uids).insert(register.cne_uid);
+        }
+        if CndpPacketCommon::has_fwd_port_thd_quit(&self.fwd_port_thd)
+            || CndpInstance::has_cndp_quit()
+        {
+            log::debug!("Cndp Packet Writer forward port thread quitted");
+            return Err(CndpError::Disconnected);
+        }
+        if dst.mac.is_none() {
+            log::error!("CndpPacketWriter: dst mac is not provided");
+            return Err(CndpError::WriterError);
+        }
+        // Get lport for fwd thread.
+        let pkt_send_data = PacketSendData {
+            buf: buf,
+            src_endpoint: self.endpoint.unwrap(),
+            dst_endpoint: *dst,
+        };
+        match self.sender.send(pkt_send_data) {
+            Err(_) => {
+                log::debug!("CndpPacketWriterSenderChannel: Send Error");
+                return Err(CndpError::WriterError);
+            }
+            Ok(_) => {
+                log::debug!("CndpPacketWriterSenderChannel: Send data");
+                log::debug!(
+                    "CndpPacketWriterSenderChannel Send 1 packet at time {}",
+                    SystemTime::now()
+                        .duration_since(std::time::UNIX_EPOCH)
+                        .unwrap()
+                        .as_micros()
+                );
+            }
+        }
+        Ok(())
+    }
+}
+
+impl<'a> Drop for CndpPacketWriterSenderChannel<'a> {
+    fn drop(&mut self) {
+        log::debug!("CndpPacketWriterSenderChannel drop");
+        let cne_uids = self.cne_uids.write().unwrap();
+        CndpPacketCommon::unregister_cne_uids(&(*cne_uids));
+        log::debug!(
+            "CndpPacketWriterSenderChannel unregister {} cne_uids",
+            (*cne_uids).len()
+        );
+    }
+}
+
+impl<'a> CndpPacketWriterReceiverChannel<'a> {
+    fn write(&self) {
+        let register = CneRegister::new("CndpPacketWriterReceiverChannel", self.core_id);
+        let mut num_pkts_received = 0;
+        let mut pkts = Vec::new();
+        let wait_time = Duration::from_micros(CndpPacketCommon::WRITE_WAIT_DURATION_IN_MICROS);
+        let mut send_packets = false;
+        loop {
+            if CndpPacketCommon::has_fwd_port_thd_quit(&self.fwd_port_thd)
+                || CndpInstance::has_cndp_quit()
+            {
+                log::debug!("Cndp Writer forward port thread quitted");
+                break;
+            }
+            // If number of packets received is greater than a threshold
+            // or timeout occurs send packets received (if any).
+            match self.receiver.recv_timeout(wait_time) {
+                Ok(data) => {
+                    log::debug!(
+                        "CndpPacketWriterReceiverChannel: Receive data, num_pkts_received= {}",
+                        num_pkts_received
+                    );
+                    num_pkts_received += 1;
+                    pkts.push(data);
+                    send_packets = num_pkts_received >= CndpPacketCommon::WRITE_THRESHOLD_NUM_PKTS;
+                }
+                Err(RecvTimeoutError::Timeout) => {
+                    // Check if there are packets to be send.
+                    if !pkts.is_empty() {
+                        log::debug!(
+                            "CndpPacketWriterReceiverChannel: Timeout. Send pending packets"
+                        );
+                        send_packets = true;
+                    }
+                }
+                Err(RecvTimeoutError::Disconnected) => {
+                    log::debug!("CndpPacketWriterReceiverChannel : Disconnected");
+                    break;
+                }
+            }
+            if send_packets {
+                let lport = self.lport;
+                CndpPacketCommon::send_pkts(&mut pkts, &lport);
+                // Reset.
+                pkts.clear();
+                num_pkts_received = 0;
+                send_packets = false;
+            }
+        }
+        // Unregister this thread from CNDP.
+        unsafe { cne_unregister(register.cne_uid) };
+    }
+}
+
+impl PlatformPacketReadWrite for CndpPacketBuffered {
+    type Owner = CndpPacketOwner<'static>;
+    fn bind() -> Result<(Self::Reader, Self::Writer, Self::Owner), Self::Error> {
+        log::info!("Wireguard called bind ");
+        let register = CneRegister::new("CndpPacketBuffered", None);
+        // Get Cndp UDP Json Data.
+        let json_data = CndpPacketCommon::get_json_data();
+        // Create Arc RwLock.
+        let fwd_port_thd_reader_arc_mutex = Arc::new(RwLock::new(json_data.fwd_port_thd_reader));
+        // Create Cndp UDP Reader.
+        let reader = CndpPacketReader {
+            iface_name: json_data.iface_name.clone(),
+            endpoint: json_data.endpoint,
+            fwd_port_thd: Arc::clone(&fwd_port_thd_reader_arc_mutex),
+            lport: json_data.lport_reader,
+            core_id: json_data.reader_core_id,
+            cne_uids: RwLock::new(HashSet::new()),
+            cur_pkt_index: -1,
+            last_num_pkts_read: 0,
+        };
+
+        // Create Arc RwLock.
+        let fwd_port_thd_writer_arc_mutex = Arc::new(RwLock::new(json_data.fwd_port_thd_writer));
+        // Create Cndp UDP Buffered Writer.
+        let writer = CndpPacketBufferedWriter {
+            inner: Arc::new(CndpPacketBufferedWriterInner {
+                iface_name: json_data.iface_name.clone(),
+                endpoint: json_data.endpoint,
+                fwd_port_thd: Arc::clone(&fwd_port_thd_writer_arc_mutex),
+                lport: json_data.lport_writer,
+                core_id: json_data.writer_core_id,
+                cne_uids: RwLock::new(HashSet::new()),
+                pkts: RwLock::new(Vec::new()),
+                runner: Runner::new(Duration::from_micros(10), 1000, 1024),
+                timer: RwLock::new(None),
+            }),
+        };
+
+        let owner = CndpPacketOwner {
+            cne_uid: register.cne_uid,
+            fwd_port_thd_reader: Arc::clone(&fwd_port_thd_reader_arc_mutex),
+            fwd_port_thd_writer: Arc::clone(&fwd_port_thd_writer_arc_mutex),
+        };
+        // Show metrics if enabled. Run in a separate thread.
+        let metrics_thread_coreid = match CndpInstance::read_config("metrics_thread_coreid") {
+            Some(v) => v.as_integer().expect("core id should be integer"),
+            None => -1,
+        };
+        if metrics_thread_coreid > 0 {
+            thread::spawn(move || {
+                CndpInstance::show_metrics(Some(metrics_thread_coreid as usize));
+            });
+        }
+        return Ok((reader, writer.clone(), owner));
+    }
+}
+
+impl<'a> Deref for CndpPacketBufferedWriter<'a> {
+    type Target = CndpPacketBufferedWriterInner<'a>;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+
+impl Clone for CndpPacketBufferedWriter<'static> {
+    fn clone(&self) -> Self {
+        CndpPacketBufferedWriter {
+            inner: self.inner.clone(),
+        }
+    }
+}
+
+impl Writer<CndpEndpoint> for CndpPacketBufferedWriter<'static> {
+    type Error = CndpError;
+    fn write(&self, buf: Vec<u8>, dst: &mut CndpEndpoint) -> Result<(), Self::Error> {
+        // If this function is called from a Wireguard Rust thread register it with CNDP.
+        let register = CneRegister::new("CndpPacketBufferedWriter", self.core_id);
+        if register.cne_uid > 0 {
+            let mut cne_uids = self.cne_uids.write().unwrap();
+            (*cne_uids).insert(register.cne_uid);
+        }
+        if CndpPacketCommon::has_fwd_port_thd_quit(&self.fwd_port_thd)
+            || CndpInstance::has_cndp_quit()
+        {
+            log::debug!("Cndp Writer forward port thread quitted");
+            return Err(CndpError::Disconnected);
+        }
+        // Get lport for fwd thread.
+        let lport = self.lport;
+        let ret = self.write_lport(buf, dst, &lport);
+        if ret < 0 {
+            log::error!("Cndp Writer failed");
+            return Err(CndpError::WriterError);
+        }
+        Ok(())
+    }
+}
+
+impl CndpPacketBufferedWriter<'static> {
+    fn write_lport(&self, buf: Vec<u8>, dst: &mut CndpEndpoint, lport: &jcfg_lport) -> i32 {
+        if dst.mac.is_none() {
+            log::debug!("Dst mac is not set");
+            return -1;
+        }
+        let pkt_send_data = PacketSendData {
+            buf: buf,
+            src_endpoint: self.endpoint.unwrap(),
+            dst_endpoint: *dst,
+        };
+        // Buffer n/w packets in a vector.
+        let mut pkts = self.pkts.write().unwrap();
+        (*pkts).push(pkt_send_data);
+        if (*pkts).len() >= CndpPacketCommon::WRITE_THRESHOLD_NUM_PKTS {
+            // Stop timer if it's running and send n/w packets from this thread.
+            let timer = self.timer.read().unwrap();
+            if let Some(timer) = &*timer {
+                timer.stop();
+            }
+            CndpPacketCommon::send_pkts(&mut *pkts, lport);
+            (*pkts).clear();
+        } else {
+            let mut timer = self.timer.write().unwrap();
+            // Create timer if it doesn't exist. This timer is used to
+            // send n/w packets after a specified interval. All the packets buffered
+            // will be send when timer expires.
+            if timer.is_none() {
+                log::debug!("Create Timer and callback");
+                let writer = self.clone();
+                let runner = &self.runner;
+                let timer_new = runner.timer(move || {
+                    Self::timer_callback(&writer);
+                });
+                *timer = Some(timer_new);
+            }
+            // Start the timer, but only if the timer is not already pending.
+            let res = (*timer).as_ref().unwrap().start(Duration::from_micros(
+                CndpPacketCommon::WRITE_CALLBACK_TIMER_DURATION_IN_MICROS,
+            ));
+            if res {
+                log::debug!("Timer started");
+            } else {
+                log::debug!("Timer already running");
+            }
+        }
+        return 0;
+    }
+
+    fn timer_callback(writer: &CndpPacketBufferedWriter<'static>) {
+        let _register = CneRegister::new("CndpUdpTimerCallback", None);
+        if CndpPacketCommon::has_fwd_port_thd_quit(&writer.fwd_port_thd)
+            || CndpInstance::has_cndp_quit()
+        {
+            log::debug!("Cndp Writer forward port thread quitted");
+            return;
+        }
+        let mut pkts = writer.pkts.write().unwrap();
+        if (*pkts).len() > 0 {
+            let lport = writer.lport;
+            CndpPacketCommon::send_pkts(&mut *pkts, &lport);
+            (*pkts).clear();
+        }
+    }
+}
+
+impl<'a> Drop for CndpPacketBufferedWriter<'a> {
+    fn drop(&mut self) {
+        log::debug!("CndpUdpBufferedWriter drop");
+        let cne_uids = self.cne_uids.write().unwrap();
+        CndpPacketCommon::unregister_cne_uids(&(*cne_uids));
+    }
+}
+
+pub struct CndpPacketOwner<'a> {
+    cne_uid: i32,
+    fwd_port_thd_reader: Arc<RwLock<&'a mut jcfg_thd>>,
+    fwd_port_thd_writer: Arc<RwLock<&'a mut jcfg_thd>>,
+}
+
+impl<'a> Owner for CndpPacketOwner<'a> {
+    type Error = CndpError;
+}
+
+impl<'a> Drop for CndpPacketOwner<'a> {
+    fn drop(&mut self) {
+        log::debug!("CndpPacketOwner drop");
+        // Quit writer thread.
+        let mut fwd_port_thd_writer = self.fwd_port_thd_writer.write().unwrap();
+        (*fwd_port_thd_writer).quit = 1;
+        // Quit reader thread.
+        let mut fwd_port_thd_reader = self.fwd_port_thd_reader.write().unwrap();
+        (*fwd_port_thd_reader).quit = 1;
+        // Unregister CndpPacketOwner thread registered with CNDP.
+        unsafe { cne_unregister(self.cne_uid) };
+    }
+}
diff --git a/src/platform/linux/cndp/fwd.jsonc b/src/platform/linux/cndp/fwd.jsonc
new file mode 100644
index 0000000..51587eb
--- /dev/null
+++ b/src/platform/linux/cndp/fwd.jsonc
@@ -0,0 +1,157 @@
+{
+    // (R) - Required entry
+    // (O) - Optional entry
+    // All descriptions are optional and short form is 'desc'
+    // The order of the entries in this file are handled when it is parsed and the
+    // entries can be in any order.
+
+    // (R) Application information
+    //    name        - (O) the name of the application
+    //    description - (O) the description of the application
+    "application": {
+        "name": "pktfwd",
+        "description": "A simple packet forwarder"
+    },
+
+    // (O) Default values
+    //    bufcnt - (O) UMEM default buffer count in 1K increments
+    //    bufsz  - (O) UMEM buffer size in 1K increments
+    //    rxdesc - (O) Number of RX ring descriptors in 1K increments
+    //    txdesc - (O) Number of TX ring descriptors in 1K increments
+    //    cache  - (O) MBUF Pool cache size in number of entries
+    //    mtype  - (O) Memory type for mmap allocations
+    "defaults": {
+        "bufcnt": 16,
+        "bufsz": 2,
+        "rxdesc": 2,
+        "txdesc": 2,
+        "cache": 128,
+        "mtype": "2MB"
+    },
+
+    // List of all UMEM's to be created
+    // key/val - (R) The 'key' is the name of the umem for later reference.
+    //               The 'val' is the object describing the UMEM buffer.
+    //               Multiple umem regions can be defined.
+    // A UMEM can support multiple lports using the regions array. Each lports can use
+    // one of the regions.
+    //    bufcnt  - (R) The number of buffers in 1K increments in the UMEM space.
+    //    bufsz   - (R) The size in 1K increments of each buffer in the UMEM space.
+    //    mtype   - (O) If missing or empty string or missing means use 4KB or default system pages.
+    //    regions - (O) Array of sizes one per region in 1K increments, total must be <= bufcnt
+    //    rxdesc  - (O) Number of RX descriptors to be allocated in 1K increments,
+    //                  if not present or zero use defaults.rxdesc, normally zero.
+    //    txdesc  - (O) Number of TX descriptors to be allocated in 1K increments,
+    //                  if not present or zero use defaults.txdesc, normally zero.
+    //    description | desc - (O) Description of the umem space.
+    "umems": {
+        "umem0": {
+            "bufcnt": 32,
+            "bufsz": 2,
+            "mtype": "2MB",
+            "regions": [
+                16,
+                16
+            ],
+            "rxdesc": 0,
+            "txdesc": 0,
+            "description": "UMEM Description 0"
+        }
+    },
+
+
+    // List of all lports to be used in the application
+    // An lport is defined by a netdev/queue ID pair, which is a socket containing a Rx/Tx ring pair.
+    // Each queue ID is assigned to a single socket or a socket is the lport defined by netdev/qid.
+    // Note: A netdev can be shared between lports as the qid is unique per lport
+    //       If netdev is not defined or empty then it must be a virtual interface and not
+    //       associated with a netdev/queue ID.
+    // key/val - (R) The 'key' is the logical name e.g. 'eth0:0', 'eth1:0', ... to be used by the
+    //               application to reference an lport. The 'val' object contains information about
+    //               each lport.
+    //    netdev        - (R) The netdev device to be used, the part before the colon
+    //                     must reflect the netdev name
+    //    pmd           - (R) All PMDs have a name i.e. 'net_af_xdp', 'ring', ...
+    //    qid           - (R) Is the queue id to use for this lport, defined by ethtool command line
+    //    umem          - (R) The UMEM assigned to this lport
+    //    region        - (O) UMEM region index value, default region 0
+    //    busy_poll     - (O) Enable busy polling support, true or false, default false
+    //    busy_timeout  - (O) 1-65535 or 0 - use default value, values in milliseconds
+    //    busy_budget   - (O) 0xFFFF disabled, 0 use default, >0 budget value
+    //    inhibit_prog_load - (O) inhibit loading the BPF program if true, default false
+    //    force_wakeup  - (O) force TX wakeup calls for CVL NIC, default false
+    //    skb_mode      - (O) Enable XDP_FLAGS_SKB_MODE when creating af_xdp socket, forces copy mode, default false
+    //    description   - (O) the description, 'desc' can be used as well
+    "lports": {
+        "enp134s0f0:0": {
+            "pmd": "net_af_xdp",
+            "qid": 23,
+            "umem": "umem0",
+            "busy_poll": true,
+            "region": 0,
+            "description": "LAN 0 port"
+        },
+        "enp134s0f0:1": {
+            "pmd": "net_af_xdp",
+            "qid": 33,
+            "umem": "umem0",
+            "busy_poll": true,
+            "region": 1,
+            "description": "LAN 1 port"
+        }
+    },
+
+    // (O) Define the lcore groups for each thread to run
+    //     Can be integers or a string for a range of lcores
+    //     e.g. [10], [10-14,16], [10-12, 14-15, 17-18, 20]
+    // Names of a lcore group and its lcores assigned to the group.
+    // The initial group is for the main thread of the application.
+    // The default group is special and is used if a thread if not assigned to a group.
+    "lcore-groups": {
+        "initial": [22],
+        "group0": [25],
+        "group1": [35],
+        "default": ["22-35"]
+    },
+
+    // (O) Set of common options application defined.
+    //     The Key can be any string and value can be boolean, string, array or integer
+    //     An array must contain only a single value type, boolean, integer, string and
+    //     can't be a nested array.
+    //   no-metrics - (O) Disable metrics gathering and thread
+    //   no-restapi - (O) Disable RestAPI support
+    //   cli        - (O) Enable/Disable CLI supported
+    //   mode       - (O) Mode type [drop | rx-only], tx-only, [lb | loopback], fwd, acl-strict, acl-permissive
+    "options": {
+        "no-metrics": false,
+        "no-restapi": false,
+        "cli": true,
+        "mode": "drop"
+    },
+
+    // List of threads to start and information for that thread. Application can start
+    // it's own threads for any reason and are not required to be configured by this file.
+    //
+    //   Key/Val   - (R) A unique thread name.
+    //                   The format is <type-string>[:<identifier>] the ':' and identifier
+    //                   are optional if all thread names are unique
+    //      group  - (O) The lcore-group this thread belongs to. The
+    //      lports - (O) The list of lports assigned to this thread and can not shared lports.
+    //      description | desc - (O) The description
+    "threads": {
+        "main": {
+            "group": "initial",
+            "description": "CLI Thread"
+        },
+        "fwd:0": {
+            "group": "group0",
+            "lports": ["enp134s0f0:0"],
+            "description": "Thread 0"
+        },
+        "fwd:1": {
+            "group": "group1",
+            "lports": ["enp134s0f0:1"],
+            "description": "Thread 1"
+        }
+    }
+}
diff --git a/src/platform/linux/cndp/jcfg_parse/fwd.h b/src/platform/linux/cndp/jcfg_parse/fwd.h
new file mode 100644
index 0000000..b94964d
--- /dev/null
+++ b/src/platform/linux/cndp/jcfg_parse/fwd.h
@@ -0,0 +1,80 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+
+#ifndef _FWD_H_
+#define _FWD_H_
+
+/**
+ * @file
+ *
+ * CNE AF_XDP low-level abstraction used as a helper for Rust layer.
+ *
+ * This file provides a low-level abstraction to CNE applications for AF_XDP.
+ */
+
+#include <stdint.h>        // for uint64_t, uint32_t, uint8_t
+#include <sys/types.h>
+#include <net/ethernet.h>
+#include <net/if.h>
+#include <strings.h>        // for strcasecmp
+#include <stdbool.h>        // for bool
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <jcfg.h>           // for jcfg_info_t, jcfg_thd_t
+#include "metrics.h"        // for metrics_info_t
+#include "pktmbuf.h"        // for pktmbuf_t
+
+#define MAX_BURST   256
+
+enum {
+    FWD_DEBUG_STATS = (1 << 0), /**< Show debug stats */
+    FWD_NO_METRICS  = (1 << 1), /**< Disable the Metrics function */
+    FWD_NO_RESTAPI  = (1 << 2), /**< Disable the REST API */
+    FWD_CLI_ENABLE  = (1 << 3), /**< Enable the CLI */
+};
+
+#define NO_METRICS_TAG "no-metrics" /**< json tag for no-metrics */
+#define NO_RESTAPI_TAG "no-restapi" /**< json tag for no-restapi */
+#define ENABLE_CLI_TAG "cli"        /**< json tag to enable/disable CLI */
+#define MODE_TAG       "mode"       /**< json tag to set the mode flag */
+
+
+struct fwd_port {
+    jcfg_thd_t *thd;                /**< reference to processing thread */
+    int lport;                      /**< PKTDEV lport id */
+    pktmbuf_t *rx_mbufs[MAX_BURST]; /**< RX mbufs array */
+    pktmbuf_t *tx_mbufs[MAX_BURST]; /**< TX mbufs array */
+    uint64_t ipackets;              /**< previous rx packets */
+    uint64_t opackets;              /**< previous tx packets */
+    uint64_t ibytes;                /**< previous rx bytes */
+    uint64_t obytes;                /**< previous tx bytes */
+};
+
+struct app_options {
+    bool no_metrics; /**< Enable metrics*/
+    bool no_restapi; /**< Enable REST API*/
+    bool cli;        /**< Enable Cli*/
+    char *mode;      /**< Application mode*/
+};
+
+struct fwd_info {
+    jcfg_info_t *jinfo;      /**< JSON-C configuration */
+    uint32_t flags;          /**< Application set of flags */
+    volatile int quit; /**< flags to start and stop the application */
+    struct app_options opts; /**< Application options*/
+};
+
+int parse_file(const char *json_file, struct fwd_info *fwd);
+int enable_metrics(struct fwd_info *fwd);
+void print_port_stats_all(struct fwd_info *fwd);
+void free_lport(jcfg_lport_t *lport);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _FWD_H_ */
diff --git a/src/platform/linux/cndp/jcfg_parse/meson.build b/src/platform/linux/cndp/jcfg_parse/meson.build
new file mode 100644
index 0000000..00a9d42
--- /dev/null
+++ b/src/platform/linux/cndp/jcfg_parse/meson.build
@@ -0,0 +1,22 @@
+# SPDX-License-Identifier: BSD-3-Clause
+# Copyright(c) 2020-2021 Intel Corporation
+
+project('jcfg parse rust helper', 'c',
+  version : '1.0.0',
+  license : 'BSD')
+
+jcfg_parse_sources = files('parse-jsonc.c', 'stats.c', 'rust_helper.c')
+
+# Find cndp library dependency using pkg-config.
+# PKG_CONFIG_PATH environment variable should be set to directory containing libcndp.pc file.
+cndp_dep = dependency('libcndp', method:'pkg-config')
+cndp_lib_dir = cndp_dep.get_pkgconfig_variable('libdir')
+cndp_include_dir = cndp_dep.get_pkgconfig_variable('includedir')
+cndp_inc = include_directories(cndp_include_dir+'/cndp')
+
+cndp_dep = declare_dependency(
+    link_args : ['-lpthread', '-lbsd', '-L' + cndp_lib_dir, '-lcndp'],
+    include_directories : cndp_inc)
+
+jcfg_parse_libname = 'rust_' + 'jcfg_parse'
+librust_jcfg_parse = library(jcfg_parse_libname, jcfg_parse_sources, install: false, dependencies: [cndp_dep])
diff --git a/src/platform/linux/cndp/jcfg_parse/parse-jsonc.c b/src/platform/linux/cndp/jcfg_parse/parse-jsonc.c
new file mode 100644
index 0000000..87ae2b0
--- /dev/null
+++ b/src/platform/linux/cndp/jcfg_parse/parse-jsonc.c
@@ -0,0 +1,178 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+
+#include <stdio.h>                   // for NULL, printf, EOF
+#include <stdlib.h>                  // for free, calloc
+#include <getopt.h>                  // for getopt_long, option
+#include <bsd/string.h>              // for strlcpy
+#include <cne_log.h>                 // for CNE_LOG_ERR, CNE_ERR_RET, CNE_ERR
+#include <cne_lport.h>               // for lport_cfg
+#include <cne_mmap.h>                // for mmap_addr, mmap_alloc, mmap_size, mmap_t
+#include <pmd_af_xdp.h>              // for PMD_NET_AF_XDP_NAME
+#include <jcfg.h>                    // for jcfg_obj_t, jcfg_umem_t, jcfg_opt_t
+#include <jcfg_process.h>            // for jcfg_process
+#include <bits/getopt_core.h>        // for optind, optarg
+#include <stdint.h>                  // for uint64_t, uint32_t
+#include <strings.h>                 // for strcasecmp
+#include <string.h>                  // for strcmp
+#include <pktdev_api.h>              // for pktdev_port_setup
+#include <cne_common.h>              // for MEMPOOL_CACHE_MAX_SIZE, __cne_unused
+#include <pktmbuf.h>                 // for pktmbuf_pool_create, pktmbuf_info_t
+#include "fwd.h"                     // for fwd_info, fwd, app_options, get_app_mode
+
+static int
+process_callback(jcfg_info_t *j __cne_unused, void *_obj, void *arg, int idx __cne_unused)
+{
+    jcfg_obj_t obj;
+    struct fwd_info *f = arg;
+    uint32_t cache_sz;
+    char *umem_addr;
+
+    if (!_obj)
+        return -1;
+
+    obj.hdr = _obj;
+
+    switch (obj.hdr->cbtype) {
+    case JCFG_APPLICATION_TYPE:
+        break;
+
+    case JCFG_DEFAULT_TYPE:
+        break;
+
+    case JCFG_OPTION_TYPE:
+        if (!strcmp(obj.opt->name, NO_METRICS_TAG)) {
+            if (obj.opt->val.type == BOOLEAN_OPT_TYPE)
+                f->opts.no_metrics = obj.opt->val.boolean;
+        } else if (!strcmp(obj.opt->name, NO_RESTAPI_TAG)) {
+            if (obj.opt->val.type == BOOLEAN_OPT_TYPE)
+                f->opts.no_restapi = obj.opt->val.boolean;
+        } else if (!strcmp(obj.opt->name, ENABLE_CLI_TAG)) {
+            if (obj.opt->val.type == BOOLEAN_OPT_TYPE)
+                f->opts.cli = obj.opt->val.boolean;
+        } else if (!strcmp(obj.opt->name, MODE_TAG)) {
+            if (obj.opt->val.type == STRING_OPT_TYPE) {
+                f->opts.mode = obj.opt->val.str;
+            }
+        }
+        break;
+
+    case JCFG_UMEM_TYPE:
+        /* The UMEM object describes the total size of the UMEM space */
+        obj.umem->mm = mmap_alloc(obj.umem->bufcnt, obj.umem->bufsz, obj.umem->mtype);
+        if (obj.umem->mm == NULL)
+            CNE_ERR_RET("**** Failed to allocate mmap memory %ld\n",
+                        (uint64_t)obj.umem->bufcnt * (uint64_t)obj.umem->bufsz);
+
+        if (jcfg_default_get_u32(j, "cache", &cache_sz))
+            cache_sz = MEMPOOL_CACHE_MAX_SIZE;
+
+        umem_addr = mmap_addr(obj.umem->mm);
+
+        /* Create the pktmbuf pool for each region defined */
+        for (int i = 0; i < obj.umem->region_cnt; i++) {
+            pktmbuf_info_t *pi;
+            region_info_t *ri = &obj.umem->rinfo[i];
+
+            /* Find the starting memory address in UMEM for the pktmbuf_t buffers */
+            ri->addr = umem_addr;
+            umem_addr += (ri->bufcnt * obj.umem->bufsz);
+
+            /* Initialize a pktmbuf_info_t structure for each region in the UMEM space */
+            pi = pktmbuf_pool_create(ri->addr, ri->bufcnt, obj.umem->bufsz, cache_sz, NULL);
+            if (!pi)
+                CNE_ERR_RET("pktmbuf_pool_init() failed for region %d\n", i);
+
+            ri->pool = pi;
+        }
+        break;
+
+    case JCFG_LPORT_TYPE:
+        do {
+            jcfg_lport_t *lport = obj.lport;
+            struct fwd_port *pd;
+            mmap_t *mm;
+            jcfg_umem_t *umem;
+            struct lport_cfg pcfg = {0};
+
+            umem = lport->umem;
+            mm   = umem->mm;
+
+            pd = calloc(1, sizeof(struct fwd_port));
+            if (!pd)
+                CNE_ERR_RET("Unable to allocate fwd_port structure\n");
+            lport->private = pd;
+
+            pcfg.qid          = lport->qid;
+            pcfg.bufsz        = umem->bufsz;
+            pcfg.rx_nb_desc   = umem->rxdesc;
+            pcfg.tx_nb_desc   = umem->txdesc;
+            pcfg.pmd_opts     = lport->pmd_opts;
+            pcfg.umem_addr    = mmap_addr(mm);
+            pcfg.umem_size    = mmap_size(mm, NULL, NULL);
+            pcfg.busy_timeout = lport->busy_timeout;
+            pcfg.busy_budget  = lport->busy_budget;
+            pcfg.flags        = lport->flags;
+            pcfg.flags |= (umem->shared_umem == 1) ? LPORT_SHARED_UMEM : 0;
+            pcfg.addr = jcfg_lport_region(lport, &pcfg.bufcnt);
+            if (!pcfg.addr) {
+                free(pd);
+                return -1;
+            }
+            pcfg.pi = umem->rinfo[lport->region_idx].pool;
+
+            /* Setup the mempool configuration */
+            strlcpy(pcfg.pmd_name, lport->pmd_name, sizeof(pcfg.pmd_name));
+            strlcpy(pcfg.ifname, lport->netdev, sizeof(pcfg.ifname));
+            strlcpy(pcfg.name, lport->name, sizeof(pcfg.name));
+
+            pd->lport = pktdev_port_setup(&pcfg);
+            if (pd->lport < 0) {
+                free(pd);
+                return -1;
+            }
+        } while ((0));
+        break;
+
+    case JCFG_LGROUP_TYPE:
+        break;
+
+    case JCFG_THREAD_TYPE:
+        break;
+    default:
+        return -1;
+    }
+
+    return 0;
+}
+
+int
+parse_file(const char *json_file, struct fwd_info *fwd)
+{
+    int flags  = JCFG_PARSE_FILE;
+    fwd->jinfo = jcfg_parser(flags, (const char *)json_file);
+    if (fwd->jinfo == NULL)
+        CNE_ERR_RET("*** Did not find any configuration to use ***\n");
+
+    if (jcfg_process(fwd->jinfo, flags, process_callback, fwd))
+        CNE_ERR_RET("*** Invalid configuration ***\n");
+
+    if (!fwd->opts.no_metrics && enable_metrics(fwd))
+        CNE_ERR_RET("Failed to start metrics support\n");
+
+    return 0;
+}
+
+void
+free_lport(jcfg_lport_t *lport)
+{
+    if (lport->umem) {
+        mmap_free(lport->umem->mm);
+        lport->umem->mm = NULL; /* Make sure we do not free this again */
+        if (lport->umem->rinfo) {
+            pktmbuf_destroy(lport->umem->rinfo->pool);
+            lport->umem->rinfo->pool = NULL;
+        }
+    }
+}
diff --git a/src/platform/linux/cndp/jcfg_parse/rust_helper.c b/src/platform/linux/cndp/jcfg_parse/rust_helper.c
new file mode 100644
index 0000000..639c1bb
--- /dev/null
+++ b/src/platform/linux/cndp/jcfg_parse/rust_helper.c
@@ -0,0 +1,27 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+
+#include "rust_helper.h"
+
+// static linine functions are not currently supported by rust bindgen
+// See: https://github.com/rust-lang/rust-bindgen/issues/1344
+uint16_t
+pktdev_rx_burst_fn(uint16_t lport_id, pktmbuf_t **rx_pkts, const uint16_t nb_pkts) {
+    return pktdev_rx_burst(lport_id, rx_pkts, nb_pkts);
+}
+
+uint16_t
+pktdev_tx_burst_fn(uint16_t lport_id, pktmbuf_t **tx_pkts, uint16_t nb_pkts) {
+    return pktdev_tx_burst(lport_id, tx_pkts, nb_pkts);
+}
+
+void
+pktmbuf_free_bulk_fn(pktmbuf_t **mbufs, unsigned int count) {
+    return pktmbuf_free_bulk(mbufs, count);
+}
+
+void
+pktmbuf_free_fn(pktmbuf_t *mbuf) {
+    return pktmbuf_free(mbuf);
+}
diff --git a/src/platform/linux/cndp/jcfg_parse/rust_helper.h b/src/platform/linux/cndp/jcfg_parse/rust_helper.h
new file mode 100644
index 0000000..cf700eb
--- /dev/null
+++ b/src/platform/linux/cndp/jcfg_parse/rust_helper.h
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+
+#ifndef _RUSTHELPER_H_
+#define _RUSTHELPER_H_
+
+/**
+ * @file
+ *
+ * Wrapper functions for CNDP inline functions required for Rust Bindgen tool.
+ *
+ */
+
+#include <stdint.h>         // for uint64_t, uint32_t, uint8_t
+#include <strings.h>        // for strcasecmp
+#include <stdbool.h>        // for bool
+#include <pktdev.h>         // for pktdev_rx_burst, pktdev_tx_burst
+#include <pktmbuf.h>        // for pktmbuf_pool_create, pktmbuf_info_t
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+uint16_t pktdev_rx_burst_fn(uint16_t lport_id, pktmbuf_t **rx_pkts, const uint16_t nb_pkts);
+
+uint16_t pktdev_tx_burst_fn(uint16_t lport_id, pktmbuf_t **tx_pkts, uint16_t nb_pkts);
+
+void pktmbuf_free_bulk_fn(pktmbuf_t **mbufs, unsigned int count);
+
+void pktmbuf_free_fn(pktmbuf_t *mbuf);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _RUSTHELPER_H_ */
diff --git a/src/platform/linux/cndp/jcfg_parse/stats.c b/src/platform/linux/cndp/jcfg_parse/stats.c
new file mode 100644
index 0000000..a9e1c15
--- /dev/null
+++ b/src/platform/linux/cndp/jcfg_parse/stats.c
@@ -0,0 +1,307 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+
+#include <stdio.h>             // for snprintf, fflush, NULL, stdout
+#include <cne_common.h>        // for __cne_unused
+#include <cne_log.h>           // for CNE_ERR_RET, CNE_LOG_ERR
+#include <metrics.h>           // for metrics_append, metrics_register, metrics_cl...
+#include <stdint.h>            // for uint64_t
+#include <pktmbuf.h>           // IWYU pragma: keep
+#include <unistd.h>            // for gethostname
+
+#include "fwd.h"               // for fwd_info, fwd_port, FWD_DEBUG_STATS, enable_...
+#include "cne_lport.h"         // for lport_stats_t
+#include "jcfg.h"              // for jcfg_lport_t, jcfg_info_t, jcfg_lport_foreach
+#include "pktdev_api.h"        // for pktdev_stats_get
+
+static uint64_t tick, print_stats_inited;
+
+#define COLUMN_WIDTH 15
+
+enum { YELLOW_TYPE = 1, MAGENTA_TYPE, CYAN_TYPE, RED_TYPE, GREEN_TYPE, BLUE_TYPE };
+
+static void
+prt_cnt(int skip, int width, uint64_t cnt, int type)
+{
+    char buff[64];
+
+    vt_cnright(skip);
+    snprintf(buff, sizeof(buff), "%'lu", cnt);
+
+    // clang-format off
+    switch(type) {
+    case YELLOW_TYPE:   cne_printf("[yellow]%*s [yellow]|\n", width, buff); break;
+    case MAGENTA_TYPE:  cne_printf("[magenta]%*s [yellow]|\n", width, buff); break;
+    case CYAN_TYPE:     cne_printf("[cyan]%*s [yellow]|\n", width, buff); break;
+    case RED_TYPE:      cne_printf("[red]%*s [yellow]|\n", width, buff); break;
+    case GREEN_TYPE:    cne_printf("[green]%*s [yellow]|\n", width, buff); break;
+    case BLUE_TYPE:     cne_printf("[blue]%*s [yellow]|\n", width, buff); break;
+    default:            cne_printf("[orange]%*s [yellow]|\n", width, buff); break;
+    }
+    // clang-format on
+}
+
+static void
+print_port_stats(int lport_id, struct fwd_port *p, struct fwd_info *fwd)
+{
+    lport_stats_t stats = {0};
+    uint64_t rx_pps, tx_pps;
+    int skip, col;
+
+    vt_restore();
+    cne_printf("\n\n");
+
+    col  = COLUMN_WIDTH;
+    skip = (lport_id + 1) * (col + 2);
+    vt_cnright(skip);
+
+    cne_printf("[blue]%*d[] [yellow]|[]\n", col, lport_id);
+
+    pktdev_stats_get(p->lport, &stats);
+
+    rx_pps = (stats.ipackets - p->ipackets);
+    tx_pps = (stats.opackets - p->opackets);
+
+    vt_cnright(skip);
+    cne_printf("[yellow]%*s [yellow]+[]\n", col, " --------------");
+
+    prt_cnt(skip, col, rx_pps, YELLOW_TYPE);
+    prt_cnt(skip, col, stats.ipackets, MAGENTA_TYPE);
+    prt_cnt(skip, col, stats.ibytes / (1024 * 1024), CYAN_TYPE);
+    prt_cnt(skip, col, stats.ierrors, RED_TYPE);
+    prt_cnt(skip, col, stats.imissed, RED_TYPE);
+    prt_cnt(skip, col, stats.rx_invalid, RED_TYPE);
+
+    prt_cnt(skip, col, tx_pps, YELLOW_TYPE);
+    prt_cnt(skip, col, stats.opackets, MAGENTA_TYPE);
+    prt_cnt(skip, col, stats.obytes / (1024 * 1024), CYAN_TYPE);
+    prt_cnt(skip, col, stats.oerrors, RED_TYPE);
+    prt_cnt(skip, col, stats.odropped, CYAN_TYPE);
+    prt_cnt(skip, col, stats.tx_invalid, RED_TYPE);
+
+    if (fwd->flags & FWD_DEBUG_STATS) {
+        vt_cnright(skip);
+        cne_printf("[yellow]%-*s [yellow]+[]\n", col, " --------------");
+
+        prt_cnt(skip, col, stats.rx_peek_failed, RED_TYPE);
+        prt_cnt(skip, col, stats.rx_poll_req, GREEN_TYPE);
+        prt_cnt(skip, col, stats.rx_buf_alloc, MAGENTA_TYPE);
+        prt_cnt(skip, col, stats.rx_buf_freed, MAGENTA_TYPE);
+        prt_cnt(skip, col, stats.rx_ring_empty, CYAN_TYPE);
+
+        prt_cnt(skip, col, stats.fq_reserved, GREEN_TYPE);
+        prt_cnt(skip, col, stats.fq_alloc_failed, RED_TYPE);
+        prt_cnt(skip, col, stats.fq_buf_freed, GREEN_TYPE);
+
+        prt_cnt(skip, col, stats.tx_kicks, GREEN_TYPE);
+        prt_cnt(skip, col, stats.tx_kick_failed, RED_TYPE);
+        prt_cnt(skip, col, stats.cq_empty, RED_TYPE);
+        prt_cnt(skip, col, stats.tx_ring_full, CYAN_TYPE);
+        prt_cnt(skip, col, stats.cq_peek_failed, RED_TYPE);
+        prt_cnt(skip, col, stats.cq_buf_freed, MAGENTA_TYPE);
+    }
+
+    p->ipackets = stats.ipackets;
+    p->opackets = stats.opackets;
+}
+
+static int
+_print_stats(jcfg_info_t *j __cne_unused, void *obj, void *arg, int idx __cne_unused)
+{
+    jcfg_lport_t *lport  = obj;
+    struct fwd_port *pd  = lport->private;
+    struct fwd_info *fwd = (struct fwd_info *)arg;
+
+    print_port_stats(lport->lpid, pd, fwd);
+
+    return 0;
+}
+
+enum { DFLT_LINE, TICK_LINE, COL_LINE, HDR_LINE, DBG_LINE = 0x80, LINE_MASK = 0x7f };
+
+struct stats_line {
+    int type;
+    const char *fmt;
+    const char *msg;
+} stat_lines[] = {
+    {DFLT_LINE, "\n"},
+    {TICK_LINE, "[cyan:-:italic]Running:  [yellow:-:bold]%c[]\n", ""},
+
+    {COL_LINE, "[blue:-:bold]%-*s [yellow:-:-]|[]\n", "lport ID"},
+    {COL_LINE, "[yellow]%-*s [yellow]+[]\n", "---------------"},
+    {HDR_LINE, "[yellow:-:italic]RX [green:-:-]%-*s [yellow]|[]\n", "Pkts/s"},
+    {COL_LINE, "[green]%-*s [yellow]|[]\n", "   Total Pkts"},
+    {COL_LINE, "[green]%-*s [yellow]|[]\n", "   Total MBs"},
+    {COL_LINE, "[green]%-*s [yellow]|[]\n", "   Errors"},
+    {COL_LINE, "[green]%-*s [yellow]|[]\n", "   Missed"},
+    {COL_LINE, "[green]%-*s [yellow]|[]\n", "   Invalid"},
+    {HDR_LINE, "[yellow:-:italic]TX [green:-:-]%-*s [yellow]|[]\n", "Pkts/s"},
+    {COL_LINE, "[green]%-*s [yellow]|[]\n", "   Total Pkts"},
+    {COL_LINE, "[green]%-*s [yellow]|[]\n", "   Total MBs"},
+    {COL_LINE, "[green]%-*s [yellow]|[]\n", "   Errors"},
+    {COL_LINE, "[green]%-*s [yellow]|[]\n", "   Dropped"},
+    {COL_LINE, "[green]%-*s [yellow]|[]\n", "   Invalid"},
+
+    {COL_LINE | DBG_LINE, "[magenta:-:italic]%-*s [yellow:-:-]+ []\n", "Debug Stats"},
+    {HDR_LINE | DBG_LINE, "[yellow:-:italic]RX [green:-:-]%-*s [yellow]|[]\n", "Peek Fail"},
+    {COL_LINE | DBG_LINE, "[green]%-*s [yellow]|[]\n", "   Polls"},
+    {COL_LINE | DBG_LINE, "[green]%-*s [yellow]|[]\n", "   Buf Alloc"},
+    {COL_LINE | DBG_LINE, "[green]%-*s [yellow]|[]\n", "   Buf Freed"},
+    {COL_LINE | DBG_LINE, "[green]%-*s [yellow]|[]\n", "   Ring Empty"},
+
+    {HDR_LINE | DBG_LINE, "[yellow:-:italic]FQ [green:-:-]%-*s [yellow]|[]\n", "Reserved"},
+    {COL_LINE | DBG_LINE, "[green]%-*s [yellow]|[]\n", "   Alloc Failed"},
+    {COL_LINE | DBG_LINE, "[green]%-*s [yellow]|[]\n", "   Buf Freed"},
+
+    {HDR_LINE | DBG_LINE, "[yellow:-:italic]TX [green:-:-]%-*s [yellow]|[]\n", "Kicks"},
+    {COL_LINE | DBG_LINE, "[green]%-*s [yellow]|[]\n", "   Kicks Failed"},
+    {COL_LINE | DBG_LINE, "[green]%-*s [yellow]|[]\n", "   Ring Full"},
+    {HDR_LINE | DBG_LINE, "[yellow:-:italic]CQ [green:-:-]%-*s [yellow]|[]\n", "Empty"},
+    {COL_LINE | DBG_LINE, "[green]%-*s [yellow]|[]\n", "   Peek Fail"},
+    {COL_LINE | DBG_LINE, "[green]%-*s [yellow]|[]\n", "   Buf Freed"},
+    {DFLT_LINE, "[]\n"}};
+
+static void
+print_stats_init(struct fwd_info *fwd)
+{
+    int nlines = 0;
+
+    print_stats_inited = 1;
+
+    for (int i = 0; i < cne_countof(stat_lines); i++) {
+        struct stats_line *st = &stat_lines[i];
+
+        /* Skip the extra debug stats lines */
+        if (!(fwd->flags & FWD_DEBUG_STATS) && (st->type & DBG_LINE))
+            continue;
+
+        nlines++;
+    }
+
+    vt_make_space(nlines);
+}
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-nonliteral"
+
+void
+print_port_stats_all(struct fwd_info *fwd)
+{
+    int col = COLUMN_WIDTH;
+
+    if (!print_stats_inited)
+        print_stats_init(fwd);
+
+    vt_save();
+    for (int i = 0; i < cne_countof(stat_lines); i++) {
+        struct stats_line *st = &stat_lines[i];
+
+        /* Skip the extra debug stats lines */
+        if (!(fwd->flags & FWD_DEBUG_STATS) && (st->type & DBG_LINE))
+            continue;
+
+        switch (st->type & LINE_MASK) {
+        case DFLT_LINE:
+            cne_printf(st->fmt, st->msg);
+            break;
+        case TICK_LINE:
+            cne_printf(st->fmt, "|/-\\"[tick % 4]);
+            tick++;
+            break;
+        case COL_LINE:
+            cne_printf(st->fmt, col, st->msg);
+            break;
+        case HDR_LINE:
+            cne_printf(st->fmt, col - 3, st->msg);
+            break;
+        case DBG_LINE:
+            break;
+        default:
+            break;
+        }
+    }
+    jcfg_lport_foreach(fwd->jinfo, _print_stats, fwd);
+
+    vt_restore();
+}
+#pragma GCC diagnostic pop
+
+static int
+fwd_host(metrics_client_t *c, const char *cmd __cne_unused, const char *params __cne_unused)
+{
+    char hostname[256];
+
+    if (gethostname(hostname, sizeof(hostname)) < 0)
+        return -1;
+
+    metrics_append(c, "\"hostname\":\"%s\"", hostname);
+
+    return 0;
+}
+
+static int
+fwd_app(metrics_client_t *c, const char *cmd __cne_unused, const char *params __cne_unused)
+{
+    metrics_append(c, "\"name\":\"pktfwd\"");
+
+    return 0;
+}
+
+static int
+handle_stats(jcfg_info_t *j __cne_unused, void *obj, void *arg __cne_unused, int idx __cne_unused)
+{
+    jcfg_lport_t *lport = obj;
+    struct fwd_port *pd = lport->private;
+    lport_stats_t stats = {0};
+    metrics_client_t *c = arg;
+
+    pktdev_stats_get(pd->lport, &stats);
+
+    if (lport->lpid > 0)
+        metrics_append(c, ",");
+
+    metrics_append(c, "\"%s_n_rx_bytes\":%ld", lport->name, stats.ibytes);
+    metrics_append(c, ",\"%s_n_tx_bytes\":%ld", lport->name, stats.obytes);
+    metrics_append(c, ",\"%s_n_rx_packets\":%ld", lport->name, stats.ipackets);
+    metrics_append(c, ",\"%s_n_tx_packets\":%ld", lport->name, stats.opackets);
+    metrics_append(c, ",\"%s_n_rx_invalid_requests\":%ld", lport->name, stats.rx_invalid);
+    metrics_append(c, ",\"%s_n_tx_invalid_requests\":%ld", lport->name, stats.tx_invalid);
+    metrics_append(c, ",\"%s_n_fq_reserved_entries\":%ld", lport->name, stats.fq_reserved);
+    metrics_append(c, ",\"%s_n_tx_failed_kicks\":%ld", lport->name, stats.tx_kick_failed);
+    metrics_append(c, ",\"%s_tx_ring_full\":%ld", lport->name, stats.tx_ring_full);
+    metrics_append(c, ",\"%s_n_tx_kicks\":%ld", lport->name, stats.tx_kicks);
+    metrics_append(c, ",\"%s_n_alloc_buffers\":%ld", lport->name, stats.rx_buf_alloc);
+    metrics_append(c, ",\"%s_n_freed_buffers\":%ld", lport->name, stats.rx_buf_freed);
+    metrics_append(c, ",\"%s_n_poll_requests\":%ld", lport->name, stats.rx_poll_req);
+
+    return 0;
+}
+
+static int
+fwd_stats(metrics_client_t *c, const char *cmd __cne_unused, const char *params __cne_unused)
+{
+    struct fwd_info *fwd = (struct fwd_info *)(c->info->priv);
+    return jcfg_lport_foreach(fwd->jinfo, handle_stats, c);
+}
+
+int
+enable_metrics(struct fwd_info *finfo)
+{
+    struct fwd_info *fwd = finfo;
+    print_stats_inited   = 0;
+    tick                 = 0;
+    if (metrics_init((void *)fwd) < 0)
+        CNE_ERR_RET("metrics failed to initialize: %s\n", strerror(errno));
+
+    if (metrics_register("/host", fwd_host) < 0)
+        CNE_ERR_RET("Failed to register the metrics host\n");
+
+    if (metrics_register("/app", fwd_app) < 0)
+        CNE_ERR_RET("Failed to register the metrics app\n");
+
+    if (metrics_register("/stats", fwd_stats) < 0)
+        CNE_ERR_RET("Failed to register the metric stats\n");
+
+    return 0;
+}
diff --git a/src/platform/linux/cndp/mod.rs b/src/platform/linux/cndp/mod.rs
new file mode 100644
index 0000000..051d7e2
--- /dev/null
+++ b/src/platform/linux/cndp/mod.rs
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+
+pub mod cndp;
+pub mod endpoint;
+pub mod packet;
+pub mod udp;
+pub mod tun_channel;
+pub mod eth_packet_rw;
+mod util;
diff --git a/src/platform/linux/cndp/packet.rs b/src/platform/linux/cndp/packet.rs
new file mode 100644
index 0000000..6f3778f
--- /dev/null
+++ b/src/platform/linux/cndp/packet.rs
@@ -0,0 +1,660 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+use pnet::datalink::{channel, Channel, MacAddr, NetworkInterface};
+use pnet::packet::arp::{ArpHardwareTypes, ArpOperations};
+use pnet::packet::arp::{ArpPacket, MutableArpPacket};
+use pnet::packet::ethernet::{EtherTypes, MutableEthernetPacket};
+use pnet::packet::ip::{IpNextHeaderProtocol, IpNextHeaderProtocols};
+use pnet::packet::ipv4::{self, Ipv4Packet, MutableIpv4Packet};
+use pnet::packet::ipv6::{Ipv6Packet, MutableIpv6Packet};
+use pnet::packet::tcp::{MutableTcpPacket, TcpPacket};
+use pnet::packet::udp::{self, MutableUdpPacket, UdpPacket};
+use pnet::packet::{MutablePacket, Packet};
+use std::fmt::Display;
+use std::fmt::Formatter;
+use std::fmt::Result;
+use std::net::{IpAddr, Ipv4Addr};
+use std::slice;
+
+pub struct CndpPacket<'p> {
+    eth_packet: MutableEthernetPacket<'p>,
+    pub src_mac: Option<MacAddr>,
+    pub dst_mac: Option<MacAddr>,
+    pub src_ip: Option<IpAddr>,
+    pub dst_ip: Option<IpAddr>,
+    pub src_port: Option<u16>,
+    pub dst_port: Option<u16>,
+}
+
+impl CndpPacket<'_> {
+    const IPV4_HEADER_LEN: usize = 20;
+    const UDP_HEADER_LEN: usize = 8;
+}
+
+impl<'p> Display for CndpPacket<'p> {
+    fn fmt(&self, fmt: &mut Formatter) -> Result {
+        write!(
+            fmt,
+            "CndpPacket [
+                            src_mac: {:?}, dst_mac: {:?}, 
+                            src_ip: {:?}, dst_ip: {:?},
+                            src_port: {:?}, dst_port: {:?}
+                           ]",
+            self.src_mac, self.dst_mac, self.src_ip, self.dst_ip, self.src_port, self.dst_port
+        )
+    }
+}
+
+impl<'p> CndpPacket<'p> {
+    pub fn new<'a>(pkt_data_addr: *mut u8, data_len: usize) -> Option<CndpPacket<'a>> {
+        if pkt_data_addr.is_null() {
+            None
+        } else {
+            let p: &'a mut [u8] = unsafe { slice::from_raw_parts_mut(pkt_data_addr, data_len) };
+            let ethernet_packet = MutableEthernetPacket::new(&mut p[..]).unwrap();
+            Some(CndpPacket {
+                eth_packet: ethernet_packet,
+                src_mac: None,
+                dst_mac: None,
+                src_ip: None,
+                dst_ip: None,
+                src_port: None,
+                dst_port: None,
+            })
+        }
+    }
+
+    pub fn parse_eth_udp_tcp_packet(&mut self) -> i32 {
+        self.src_mac = Some(self.eth_packet.get_source());
+        self.dst_mac = Some(self.eth_packet.get_destination());
+        let ret = match self.eth_packet.get_ethertype() {
+            EtherTypes::Ipv4 => self.parse_ipv4_packet(),
+            EtherTypes::Ipv6 => self.parse_ipv6_packet(),
+            _ => {
+                log::debug!(
+                    "Unknown packet: {} > {}; ethertype: {:?} length: {}",
+                    self.eth_packet.get_source(),
+                    self.eth_packet.get_destination(),
+                    self.eth_packet.get_ethertype(),
+                    self.eth_packet.packet().len()
+                );
+                -1
+            }
+        };
+        ret
+    }
+
+    fn parse_ipv4_packet(&mut self) -> i32 {
+        let ip = Ipv4Packet::new(self.eth_packet.payload());
+        if let Some(ip) = ip {
+            self.src_ip = Some(IpAddr::V4(ip.get_source()));
+            self.dst_ip = Some(IpAddr::V4(ip.get_destination()));
+            let (src_port, dst_port, status) = self.parse_transport_packet(
+                self.src_ip.unwrap(),
+                self.dst_ip.unwrap(),
+                ip.get_next_level_protocol(),
+                ip.payload(),
+            );
+            self.src_port = src_port;
+            self.dst_port = dst_port;
+            status
+        } else {
+            log::debug!("Malformed IPv4 Packet");
+            -1
+        }
+    }
+
+    fn parse_ipv6_packet(&mut self) -> i32 {
+        let ip = Ipv6Packet::new(self.eth_packet.payload());
+        if let Some(ip) = ip {
+            self.src_ip = Some(IpAddr::V6(ip.get_source()));
+            self.dst_ip = Some(IpAddr::V6(ip.get_destination()));
+            let (src_port, dst_port, status) = self.parse_transport_packet(
+                self.src_ip.unwrap(),
+                self.dst_ip.unwrap(),
+                ip.get_next_header(),
+                ip.payload(),
+            );
+            self.src_port = src_port;
+            self.dst_port = dst_port;
+            status
+        } else {
+            log::debug!("Malformed IPv6 Packet");
+            -1
+        }
+    }
+
+    fn parse_transport_packet(
+        &self,
+        source: IpAddr,
+        destination: IpAddr,
+        protocol: IpNextHeaderProtocol,
+        packet: &[u8],
+    ) -> (Option<u16>, Option<u16>, i32) {
+        let ret = match protocol {
+            IpNextHeaderProtocols::Udp => self.parse_udp_packet(packet),
+            IpNextHeaderProtocols::Tcp => self.parse_tcp_packet(packet),
+            _ => {
+                log::debug!(
+                    "Unknown {} packet: {} > {}; protocol: {:?} length: {}",
+                    match source {
+                        IpAddr::V4(..) => "IPv4",
+                        _ => "IPv6",
+                    },
+                    source,
+                    destination,
+                    protocol,
+                    packet.len()
+                );
+                (None, None, -1)
+            }
+        };
+        ret
+    }
+
+    fn parse_udp_packet(&self, packet: &[u8]) -> (Option<u16>, Option<u16>, i32) {
+        let udp = UdpPacket::new(packet);
+        let ret = if let Some(udp) = udp {
+            (Some(udp.get_source()), Some(udp.get_destination()), 0)
+        } else {
+            log::debug!("Malformed UDP Packet");
+            (None, None, -1)
+        };
+        ret
+    }
+
+    fn parse_tcp_packet(&self, packet: &[u8]) -> (Option<u16>, Option<u16>, i32) {
+        let tcp = TcpPacket::new(packet);
+        let ret = if let Some(tcp) = tcp {
+            (Some(tcp.get_source()), Some(tcp.get_destination()), 0)
+        } else {
+            log::debug!("Malformed TCP Packet");
+            (None, None, -1)
+        };
+        ret
+    }
+
+    pub fn swap_mac_addresses_eth(&mut self, pnet_swap: bool) {
+        // Swap src and dst mac address.
+        if pnet_swap {
+            let src = self.eth_packet.get_source();
+            let dst = self.eth_packet.get_destination();
+            self.eth_packet.set_source(dst);
+            self.eth_packet.set_destination(src);
+        } else {
+            let mac_addr_len = 6;
+            let mut p = self.eth_packet.packet_mut();
+            // Get src and dst mac address.
+            p = &mut p[0..mac_addr_len * 2];
+            let (left, right) = p.split_at_mut(mac_addr_len);
+            // Swap src and dst mac address.
+            left.swap_with_slice(&mut right[0..left.len()]);
+        }
+    }
+
+    pub fn swap_ip_addresses(&mut self, pnet_swap: bool) {
+        // Swap source and dst UDP port.
+        match self.eth_packet.get_ethertype() {
+            EtherTypes::Ipv4 => {
+                self.swap_ipv4_addresses(pnet_swap);
+            }
+            EtherTypes::Ipv6 => {
+                self.swap_ipv6_addresses(pnet_swap);
+            }
+            _ => log::debug!("Malformed IP Packet"),
+        }
+    }
+    pub fn swap_ipv4_addresses(&mut self, pnet_swap: bool) {
+        // Swap source and dst IP address.
+        let ip = MutableIpv4Packet::new(self.eth_packet.payload_mut());
+        if let Some(mut ip) = ip {
+            if pnet_swap {
+                let src = ip.get_source();
+                let dst = ip.get_destination();
+                ip.set_source(dst);
+                ip.set_destination(src);
+            } else {
+                // src ipv4: ip_packet[12-15], dst ipv4: ip_packet[16-19]
+                let ipv4_addr_len = 4;
+                let ipv4_offset = 12;
+                // Get src and dst ipv4 address.
+                let p = &mut ip.packet_mut()[ipv4_offset..(ipv4_offset + ipv4_addr_len * 2)];
+                let (left, right) = p.split_at_mut(ipv4_addr_len);
+                // Swap src and dst ipv4 address.
+                left.swap_with_slice(&mut right[0..left.len()]);
+            }
+        }
+    }
+
+    pub fn swap_ipv6_addresses(&mut self, pnet_swap: bool) {
+        // Swap source and dst IP address.
+        let ip = MutableIpv6Packet::new(self.eth_packet.payload_mut());
+        if let Some(mut ip) = ip {
+            if pnet_swap {
+                let src = ip.get_source();
+                let dst = ip.get_destination();
+                ip.set_source(dst);
+                ip.set_destination(src);
+            } else {
+                // src ipv6: ip_packet[8-23], dst ipv6: ip_packet[24-39]
+                let ipv6_addr_len = 16;
+                let ipv6_offset = 8;
+                // Get src and dst ipv6 address.
+                let p = &mut ip.packet_mut()[ipv6_offset..(ipv6_offset + ipv6_addr_len * 2)];
+                let (left, right) = p.split_at_mut(ipv6_offset);
+                // Swap src and dst ipv6 address.
+                left.swap_with_slice(&mut right[0..left.len()]);
+            }
+        }
+    }
+
+    pub fn swap_ports(&mut self, pnet_swap: bool) {
+        // Swap source and dst UDP port.
+        match self.eth_packet.get_ethertype() {
+            EtherTypes::Ipv4 => {
+                let ip = MutableIpv4Packet::new(self.eth_packet.payload_mut());
+                if let Some(mut ip) = ip {
+                    let protocol = ip.get_next_level_protocol();
+                    swap_transport_ports(protocol, ip.payload_mut(), pnet_swap);
+                }
+            }
+            EtherTypes::Ipv6 => {
+                let ip = MutableIpv6Packet::new(self.eth_packet.payload_mut());
+                if let Some(mut ip) = ip {
+                    let protocol = ip.get_next_header();
+                    swap_transport_ports(protocol, ip.payload_mut(), pnet_swap);
+                }
+            }
+            _ => log::debug!("Malformed IP Packet"),
+        }
+
+        fn swap_transport_ports(
+            protocol: IpNextHeaderProtocol,
+            payload: &mut [u8],
+            pnet_swap: bool,
+        ) {
+            match protocol {
+                IpNextHeaderProtocols::Udp => {
+                    let udp = MutableUdpPacket::new(payload);
+                    swap_udp_ports(udp, pnet_swap);
+                }
+                IpNextHeaderProtocols::Tcp => {
+                    let tcp = MutableTcpPacket::new(payload);
+                    swap_tcp_ports(tcp, pnet_swap);
+                }
+                _ => {
+                    log::debug!("Unknown protocol: {}", protocol);
+                }
+            }
+        }
+
+        fn swap_udp_ports(udp: Option<MutableUdpPacket>, pnet_swap: bool) {
+            if let Some(mut udp) = udp {
+                if pnet_swap {
+                    let tmp = udp.get_source();
+                    let dst = udp.get_destination();
+                    udp.set_source(dst);
+                    udp.set_destination(tmp);
+                } else {
+                    // src port: packet[0-1], dst port: packet[2-3]
+                    let port_len = 2;
+                    // Get src and dst port.
+                    let p = &mut udp.packet_mut()[0..port_len * 2];
+                    let (left, right) = p.split_at_mut(port_len);
+                    // Swap src and dst port.
+                    left.swap_with_slice(&mut right[0..left.len()]);
+                }
+            }
+        }
+
+        fn swap_tcp_ports(tcp: Option<MutableTcpPacket>, pnet_swap: bool) {
+            if let Some(mut tcp) = tcp {
+                if pnet_swap {
+                    let tmp = tcp.get_source();
+                    let dst = tcp.get_destination();
+                    tcp.set_source(dst);
+                    tcp.set_destination(tmp);
+                } else {
+                    // src port: packet[0-1], dst port: packet[2-3]
+                    let port_len = 2;
+                    // Get src and dst port.
+                    let p = &mut tcp.packet_mut()[0..port_len * 2];
+                    let (left, right) = p.split_at_mut(port_len);
+                    // Swap src and dst port.
+                    left.swap_with_slice(&mut right[0..left.len()]);
+                }
+            }
+        }
+    }
+
+    pub fn set_udp_payload(&mut self, payload: &[u8]) {
+        let ip = MutableIpv4Packet::new(self.eth_packet.payload_mut());
+        if let Some(mut ip) = ip {
+            let udp = MutableUdpPacket::new(ip.payload_mut());
+            if let Some(mut udp) = udp {
+                udp.set_payload(payload);
+            }
+        }
+    }
+
+    pub fn get_udp_payload_ptr(&mut self) -> (Option<*mut u8>, usize) {
+        let ip = MutableIpv4Packet::new(self.eth_packet.payload_mut());
+        if let Some(mut ip) = ip {
+            let udp = MutableUdpPacket::new(ip.payload_mut());
+            if let Some(mut udp) = udp {
+                let payload = udp.payload_mut();
+                return (Some(payload.as_mut_ptr()), payload.len());
+            }
+        }
+        (None, 0)
+    }
+
+    pub fn get_eth_payload_ptr(&mut self) -> (Option<*mut u8>, usize) {
+        let payload = self.eth_packet.payload_mut();
+        return (Some(payload.as_mut_ptr()), payload.len());
+    }
+
+    pub fn get_eth_payload(&self, buf: &mut [u8]) -> usize {
+        let payload = self.eth_packet.payload();
+        let payload_len = payload.len();
+        buf[..payload_len as usize].copy_from_slice(&payload[..]);
+        payload_len
+    }
+
+    pub fn get_udp_payload(&self, buf: &mut [u8]) -> usize {
+        let ip = Ipv4Packet::new(self.eth_packet.payload());
+        let mut payload_len = 0;
+        if let Some(ip) = ip {
+            let udp = UdpPacket::new(ip.payload());
+            if let Some(udp) = udp {
+                let payload = udp.payload();
+                payload_len = payload.len();
+                buf[..payload_len as usize].copy_from_slice(&payload[..]);
+            }
+        }
+        payload_len
+    }
+
+    pub fn update_eth_udp_packet(
+        &mut self,
+        src_mac: MacAddr,
+        dst_mac: MacAddr,
+        src_ip: IpAddr,
+        dst_ip: IpAddr,
+        src_port: u16,
+        dst_port: u16,
+        transport_payload: &[u8],
+    ) {
+        self.eth_packet.set_source(src_mac);
+        self.eth_packet.set_destination(dst_mac);
+        match src_ip {
+            IpAddr::V4(_) => {
+                self.eth_packet.set_ethertype(EtherTypes::Ipv4);
+                Self::update_udp_packet(
+                    self.eth_packet.payload_mut(),
+                    src_ip,
+                    dst_ip,
+                    src_port,
+                    dst_port,
+                    transport_payload,
+                );
+            }
+            IpAddr::V6(_) => {
+                panic!("Ipv6 Unsupported")
+            }
+        }
+    }
+
+    pub fn update_eth_packet(
+        &mut self,
+        src_mac: MacAddr,
+        dst_mac: MacAddr,
+        payload: &[u8],
+        is_ipv4: bool,
+    ) {
+        self.eth_packet.set_source(src_mac);
+        self.eth_packet.set_destination(dst_mac);
+        match is_ipv4 {
+            true => {
+                self.eth_packet.set_ethertype(EtherTypes::Ipv4);
+            }
+            false => {
+                self.eth_packet.set_ethertype(EtherTypes::Ipv6);
+            }
+        }
+        self.eth_packet.set_payload(payload);
+    }
+
+    pub fn update_udp_packet(
+        packet: &mut [u8],
+        src_ip: IpAddr,
+        dst_ip: IpAddr,
+        src_port: u16,
+        dst_port: u16,
+        transport_payload: &[u8],
+    ) -> u16 {
+        let mut ip_header =
+            Self::update_ipv4_header(packet, src_ip, dst_ip, transport_payload.len());
+        let source = ip_header.get_source();
+        let destination = ip_header.get_destination();
+        let mut udp_header = Self::update_udp_header(
+            ip_header.payload_mut(),
+            src_port,
+            dst_port,
+            transport_payload.len(),
+        );
+        udp_header.set_payload(transport_payload);
+        let checksum = udp::ipv4_checksum(&udp_header.to_immutable(), &source, &destination);
+        udp_header.set_checksum(checksum);
+        ip_header.get_total_length()
+    }
+
+    pub fn get_eth_udp_packet_len(udp_payload_len: usize) -> usize {
+        let total_len = MutableEthernetPacket::minimum_packet_size()
+            + CndpPacket::IPV4_HEADER_LEN
+            + CndpPacket::UDP_HEADER_LEN
+            + udp_payload_len;
+        total_len
+    }
+
+    pub fn get_eth_packet_len(payload_len: usize) -> usize {
+        let total_len = MutableEthernetPacket::minimum_packet_size() + payload_len;
+        total_len
+    }
+
+    fn update_ipv4_header(
+        packet: &mut [u8],
+        src_ip: IpAddr,
+        dst_ip: IpAddr,
+        udp_payload_len: usize,
+    ) -> MutableIpv4Packet {
+        let mut ip_header = MutableIpv4Packet::new(packet).unwrap();
+        let total_len =
+            (CndpPacket::IPV4_HEADER_LEN + CndpPacket::UDP_HEADER_LEN + udp_payload_len) as u16;
+        ip_header.set_version(4);
+        ip_header.set_header_length((CndpPacket::IPV4_HEADER_LEN / 4) as u8);
+        ip_header.set_total_length(total_len);
+        ip_header.set_ttl(100);
+        ip_header.set_next_level_protocol(IpNextHeaderProtocols::Udp);
+        if let IpAddr::V4(src_ip) = src_ip {
+            ip_header.set_source(src_ip);
+        }
+        if let IpAddr::V4(dst_ip) = dst_ip {
+            ip_header.set_destination(dst_ip);
+        }
+        let checksum = ipv4::checksum(&ip_header.to_immutable());
+        ip_header.set_checksum(checksum);
+        ip_header
+    }
+
+    fn update_udp_header(
+        packet: &mut [u8],
+        src_port: u16,
+        dst_port: u16,
+        udp_payload_len: usize,
+    ) -> MutableUdpPacket {
+        let mut udp_header = MutableUdpPacket::new(packet).unwrap();
+        udp_header.set_source(src_port);
+        udp_header.set_destination(dst_port);
+        udp_header.set_length((CndpPacket::UDP_HEADER_LEN + udp_payload_len) as u16);
+        udp_header
+    }
+
+    pub fn get_network_interface(iface_name: &str) -> Option<NetworkInterface> {
+        let interfaces = pnet::datalink::interfaces();
+        let interface = interfaces
+            .into_iter()
+            .find(|iface| iface.name == iface_name);
+        interface
+    }
+
+    pub fn get_ipv4_interface_address(interface: &NetworkInterface) -> Option<Ipv4Addr> {
+        let source_ip = interface
+            .ips
+            .iter()
+            .find(|ip| ip.is_ipv4())
+            .map(|ip| match ip.ip() {
+                IpAddr::V4(ip) => ip,
+                _ => unreachable!(),
+            });
+        source_ip
+    }
+
+    pub fn get_ip_addr_from_ifname(iface_name: &str) -> Option<IpAddr> {
+        let addr = Self::get_network_interface(iface_name)
+            .map_or_else(
+                || None,
+                |interface| Self::get_ipv4_interface_address(&interface),
+            )
+            .map(|ipv4| IpAddr::V4(ipv4));
+        addr
+    }
+
+    pub fn get_mac_from_ifname(iface_name: &str) -> Option<MacAddr> {
+        let source_mac =
+            Self::get_network_interface(iface_name).map_or_else(|| None, |interface| interface.mac);
+        source_mac
+    }
+
+    pub fn get_mac_from_string(mac_addr_str: &str) -> Option<MacAddr> {
+        let mac = match mac_addr_str.parse::<MacAddr>() {
+            Ok(mac) => Some(mac),
+            Err(_) => None,
+        };
+        mac
+    }
+
+    pub fn get_mac_through_arp(
+        iface_name: &str,
+        target_ip: Ipv4Addr,
+    ) -> (Option<MacAddr>, Option<MacAddr>) {
+        let interface = Self::get_network_interface(iface_name).unwrap();
+        let source_mac = interface.mac.unwrap();
+        let source_ip = Self::get_ipv4_interface_address(&interface).unwrap();
+        let mut config = pnet::datalink::Config::default();
+        // Timeout if we don't get any response after 5 sec.
+        let timeout = std::time::Duration::from_secs(5);
+        config.read_timeout = Some(timeout);
+        config.write_timeout = Some(timeout);
+        let (mut sender, mut receiver) = match channel(&interface, config) {
+            Ok(Channel::Ethernet(tx, rx)) => (tx, rx),
+            Ok(_) => panic!("Unknown channel type"),
+            Err(e) => panic!("Error {}", e),
+        };
+        let mut ethernet_buffer = [0u8; 42];
+        let mut ethernet_packet = MutableEthernetPacket::new(&mut ethernet_buffer).unwrap();
+        ethernet_packet.set_destination(MacAddr::broadcast());
+        ethernet_packet.set_source(source_mac);
+        ethernet_packet.set_ethertype(EtherTypes::Arp);
+        let mut arp_buffer = [0u8; 28];
+        let mut arp_packet = MutableArpPacket::new(&mut arp_buffer).unwrap();
+        arp_packet.set_hardware_type(ArpHardwareTypes::Ethernet);
+        arp_packet.set_protocol_type(EtherTypes::Ipv4);
+        arp_packet.set_hw_addr_len(6);
+        arp_packet.set_proto_addr_len(4);
+        arp_packet.set_operation(ArpOperations::Request);
+        arp_packet.set_sender_hw_addr(source_mac);
+        arp_packet.set_sender_proto_addr(source_ip);
+        arp_packet.set_target_hw_addr(MacAddr::zero());
+        arp_packet.set_target_proto_addr(target_ip);
+        ethernet_packet.set_payload(arp_packet.packet_mut());
+        sender
+            .send_to(ethernet_packet.packet(), None)
+            .unwrap()
+            .unwrap();
+        log::debug!("Sent ARP request");
+        match receiver.next() {
+            Ok(buf) => {
+                let arp =
+                    ArpPacket::new(&buf[MutableEthernetPacket::minimum_packet_size()..]).unwrap();
+                log::debug!("Received ARP reply");
+                (Some(source_mac), Some(arp.get_sender_hw_addr()))
+            }
+            Err(_) => (Some(source_mac), None),
+        }
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    #[test]
+    fn test_cndp_eth_packet() {
+        // Create UDP payload.
+        let udp_payload_size = 50;
+        let udp_payload = vec![0xAA; udp_payload_size];
+        // Fill some data for mac address, Ip address and port.
+        let src_mac = MacAddr(0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff);
+        let dst_mac = MacAddr(0x11, 0x22, 0x33, 0x44, 0x55, 0x66);
+        let src_ip = IpAddr::V4(Ipv4Addr::new(48, 0, 0, 154));
+        let dst_ip = IpAddr::V4(Ipv4Addr::new(48, 0, 0, 155));
+        let src_port = 5400;
+        let dst_port = 5500;
+        // Get total length of ethernet packet based on udp payload.
+        let data_len = CndpPacket::get_eth_udp_packet_len(udp_payload_size as usize);
+        // Create Ethernet/IP/UDP Packet.
+        let mut buf: Vec<u8> = vec![0; data_len];
+        let mut cndp_eth_packet = CndpPacket::new(buf.as_mut_ptr(), buf.len()).unwrap();
+        // Update CNDP UDP packet.
+        cndp_eth_packet.update_eth_udp_packet(
+            src_mac,
+            dst_mac,
+            src_ip,
+            dst_ip,
+            src_port,
+            dst_port,
+            &udp_payload[..],
+        );
+        // Parse the ethernet packet and verify the data.
+        let ret = cndp_eth_packet.parse_eth_udp_packet();
+        // Check if parsing succeeds.
+        assert_eq!(ret, 0);
+        // Check src, dst mac.
+        assert_eq!(cndp_eth_packet.src_mac, Some(src_mac));
+        assert_eq!(cndp_eth_packet.dst_mac, Some(dst_mac));
+        // Check src, dst ip.
+        assert_eq!(cndp_eth_packet.src_ip, Some(src_ip));
+        assert_eq!(cndp_eth_packet.dst_ip, Some(dst_ip));
+        // Check src, dst port.
+        assert_eq!(cndp_eth_packet.src_port, Some(src_port));
+        assert_eq!(cndp_eth_packet.dst_port, Some(dst_port));
+        // Create UDP payload read buffer.
+        let max_payload_size = 1400;
+        let mut udp_payload_parsed: Vec<u8> = vec![0; max_payload_size];
+        // Get UDP payload.
+        let payload_len = cndp_eth_packet.get_udp_payload(&mut udp_payload_parsed[..]);
+        // Check parsed payload size is same as original payload size.
+        assert_eq!(payload_len as usize, udp_payload_size as usize);
+        // Compare contents of parsed payload with original payload.
+        udp_payload_parsed.truncate(payload_len as usize);
+        let match_buf_count = udp_payload
+            .iter()
+            .zip(udp_payload_parsed.iter())
+            .filter(|&(a, b)| a == b)
+            .count();
+        let res =
+            match_buf_count == udp_payload.len() && match_buf_count == udp_payload_parsed.len();
+        assert_eq!(res, true);
+    }
+}
diff --git a/src/platform/linux/cndp/pktgen_cfg/pktgen.cfg b/src/platform/linux/cndp/pktgen_cfg/pktgen.cfg
new file mode 100644
index 0000000..060e898
--- /dev/null
+++ b/src/platform/linux/cndp/pktgen_cfg/pktgen.cfg
@@ -0,0 +1,55 @@
+description = 'A Pktgen default simple configuration'
+
+# Setup configuration
+setup = {
+    'exec': (
+	'sudo', '-E'
+        ),
+
+    'devices': (
+	    '1c:00.0'
+	    ),
+    # UIO module type, igb_uio, vfio-pci or uio_pci_generic
+    'uio': 'vfio-pci'
+    }
+
+# Run command and options
+run = {
+    'exec': ('sudo', '-E'),
+
+    # Application name and use app_path to help locate the app
+    'app_name': 'pktgen',
+
+    # using (sdk) or (target) for specific variables
+    # add (app_name) of the application
+    # Each path is tested for the application
+    'app_path': (
+		'./usr/local/bin/%(app_name)s',
+		'/usr/local/bin/%(app_name)s'
+        ),
+
+	'cores': '2,3-4',
+	'nrank': '4',
+	'proc': 'auto',
+	'log': '7',
+	'prefix': 'pg',
+
+	'blocklist': (
+		),
+	'allowlist': (
+		'1c:00.0'
+		),
+
+	'opts': (
+		'-v',
+		'-T',
+		'-P',
+		'-j',
+		),
+	'map': (
+		'[3:4].0'
+		),
+
+	'theme': 'themes/black-yellow.theme',
+	#'shared': '/usr/local/lib/x86_64-linux-gnu/dpdk/pmds-21.1'
+	}
diff --git a/src/platform/linux/cndp/pktgen_cfg/xdp.cfg b/src/platform/linux/cndp/pktgen_cfg/xdp.cfg
new file mode 100644
index 0000000..7bafb37
--- /dev/null
+++ b/src/platform/linux/cndp/pktgen_cfg/xdp.cfg
@@ -0,0 +1,140 @@
+#
+# Pktgen 21.03.1 (DPDK 21.05.0-rc1)
+# Copyright(c) <2010-2021>, Intel Corporation. All rights reserved., Powered by DPDK
+
+# Command line arguments: (DPDK args are defaults)
+# ./usr/local/bin/pktgen -c 7c -n 3 -m 512 --proc-type primary -- -v -T -P -j -m [3:4].0 -m [5:6].1 -f themes/black-yellow.theme 
+
+#######################################################################
+# Pktgen Configuration script information:
+#   GUI socket is Not Enabled
+#   Flags 00000804
+#   Number of ports: 2
+#   Number ports per page: 4
+#   Number descriptors: RX 256 TX: 512
+#   Promiscuous mode is Enabled
+
+
+# Global configuration:
+geometry 158x49
+disable mac_from_arp
+
+######################### Port  0 ##################################
+#
+# Port:  0, Burst: 32, Rate:100%, Flags:00000000, TX Count:Forever
+#           Sequence count:0, Prime:1 VLAN ID:0001, Link: <UP-25000-FD>
+#
+# Set up the primary port information:
+set 0 count 0
+set 0 size 1384
+set 0 rate 100
+set 0 burst 32
+set 0 sport 3400
+set 0 dport 3500
+set 0 prime 1
+set 0 type ipv4
+set 0 proto udp
+set 0 dst ip 10.50.0.2
+set 0 src ip 10.50.0.1/24
+set 0 dst mac 3c:fd:fe:a8:5f:bd
+set 0 src mac 3c:fd:fe:a8:5f:bc
+set 0 vlan 1
+
+set 0 pattern abc
+
+set 0 jitter 50
+disable 0 mpls
+range 0 mpls entry 0x0
+disable 0 qinq
+set 0 qinqids 0 0
+disable 0 gre
+disable 0 gre_eth
+disable 0 vxlan
+set 0 vxlan 0x0 0 0
+#
+# Port flag values:
+disable 0 icmp
+disable 0 pcap
+disable 0 range
+disable 0 latency
+disable 0 process
+disable 0 capture
+disable 0 rx_tap
+disable 0 tx_tap
+disable 0 vlan
+disable 0 rate
+
+#
+# Range packet information:
+range 0 src mac start 3c:fd:fe:a8:5f:bc
+range 0 src mac min 00:00:00:00:00:00
+range 0 src mac max 00:00:00:00:00:00
+range 0 src mac inc 00:00:00:00:00:00
+
+range 0 dst mac start 3c:fd:fe:a8:5f:bd
+range 0 dst mac min 00:00:00:00:00:00
+range 0 dst mac max 00:00:00:00:00:00
+range 0 dst mac inc 00:00:00:00:00:00
+
+range 0 src ip start 10.50.0.1
+range 0 src ip min 10.50.0.1
+range 0 src ip max 10.50.0.254
+range 0 src ip inc 0.0.0.0
+
+range 0 dst ip start 10.50.0.2
+range 0 dst ip min 10.50.0.2
+range 0 dst ip max 10.50.0.254
+range 0 dst ip inc 0.0.0.1
+
+range 0 proto udp
+
+range 0 src port start 3400
+range 0 src port min 0
+range 0 src port max 65535
+range 0 src port inc 1
+
+range 0 dst port start 3500
+range 0 dst port min 0
+range 0 dst port max 65535
+range 0 dst port inc 1
+
+range 0 ttl start 64
+range 0 ttl min 0
+range 0 ttl max 255
+range 0 ttl inc 0
+
+range 0 vlan start 1
+range 0 vlan min 1
+range 0 vlan max 4095
+range 0 vlan inc 0
+
+range 0 cos start 0
+range 0 cos min 0
+range 0 cos max 7
+range 0 cos inc 0
+
+range 0 tos start 0
+range 0 tos min 0
+range 0 tos max 255
+range 0 tos inc 0
+range 0 gre key 0
+
+range 0 size start 64
+range 0 size min 64
+range 0 size max 9618
+range 0 size inc 0
+
+#
+# Set up the rate data for the port.
+rate 0 fps 60
+rate 0 lines 720
+rate 0 pixels 1280
+rate 0 color bits 20
+rate 0 payload size 800
+
+rate 0 overhead 62
+#
+# Set up the sequence data for the port.
+set 0 seq_cnt 0
+
+################################ Done #################################
diff --git a/src/platform/linux/cndp/tun_channel.rs b/src/platform/linux/cndp/tun_channel.rs
new file mode 100644
index 0000000..37bc404
--- /dev/null
+++ b/src/platform/linux/cndp/tun_channel.rs
@@ -0,0 +1,245 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+use super::super::super::tun::*; // platform tun
+use super::super::tun::*; // linux tun
+use std::cmp::min;
+use std::fmt;
+use std::os::raw::c_short;
+use std::os::unix::io::RawFd;
+use std::sync::mpsc::{sync_channel, Receiver, RecvTimeoutError, SyncSender, TrySendError};
+use std::time::Duration;
+
+use hex;
+use log::debug;
+use rand::rngs::OsRng;
+use rand::Rng;
+
+const TUNSETIFF: u64 = 0x4004_54ca;
+const CLONE_DEVICE_PATH: &[u8] = b"/dev/net/tun\0";
+
+#[repr(C)]
+struct Ifreq {
+    name: [u8; libc::IFNAMSIZ],
+    flags: c_short,
+    _pad: [u8; 64],
+}
+
+#[derive(Debug)]
+pub enum TunChannelAppError {
+    Disconnected,
+    BufferFull,
+    Timeout,
+}
+
+pub struct TunChannel {}
+
+// Used to send/receive packets to the mock WireGuard interface.
+pub struct TunChannelAppReader {
+    id: u32,
+    rx: Receiver<Vec<u8>>,
+}
+
+#[derive(Clone)]
+pub struct TunChannelAppWriter {
+    id: u32,
+    tx: SyncSender<Vec<u8>>,
+}
+
+pub struct TunChannelReader {
+    id: u32,
+    rx: Receiver<Vec<u8>>,
+}
+
+pub struct TunChannelWriter {
+    id: u32,
+    tx: SyncSender<Vec<u8>>,
+}
+
+impl fmt::Display for TunChannelAppReader {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        write!(f, "TunChannelAppReader({})", self.id)
+    }
+}
+
+impl fmt::Display for TunChannelAppWriter {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        write!(f, "TunChannelAppWriter({})", self.id)
+    }
+}
+
+impl fmt::Display for TunChannelReader {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        write!(f, "TunChannelReader({})", self.id)
+    }
+}
+
+impl fmt::Display for TunChannelWriter {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        write!(f, "TunChannelWriter({})", self.id)
+    }
+}
+
+impl TunChannelAppReader {
+    pub fn read(&self) -> Result<Vec<u8>, TunChannelAppError> {
+        let timeout = Duration::from_secs(1);
+        loop {
+            // This function will block till we get a message or channel/tun is disconnected.
+            match self.rx.recv_timeout(timeout) {
+                Ok(msg) => {
+                    return Ok(msg);
+                }
+                Err(RecvTimeoutError::Timeout) => {
+                    // Continue reading the channel for messages.
+                    continue;
+                }
+                Err(RecvTimeoutError::Disconnected) => {
+                    return Err(TunChannelAppError::Disconnected);
+                }
+            }
+        }
+    }
+
+    pub fn read_timeout(&self, timeout: Duration) -> Result<Vec<u8>, TunChannelAppError> {
+        loop {
+            // Wait till we get a message or timeout occurs or channel gets disconnected.
+            match self.rx.recv_timeout(timeout) {
+                Ok(msg) => {
+                    return Ok(msg);
+                }
+                Err(RecvTimeoutError::Timeout) => {
+                    return Err(TunChannelAppError::Timeout);
+                }
+                Err(RecvTimeoutError::Disconnected) => {
+                    return Err(TunChannelAppError::Disconnected);
+                }
+            }
+        }
+    }
+}
+
+impl TunChannelAppWriter {
+    pub fn write(&self, msg: Vec<u8>) -> Result<(), TunChannelAppError> {
+        match self.tx.try_send(msg) {
+            Ok(_) => Ok(()),
+            Err(TrySendError::Full(_)) => {
+                return Err(TunChannelAppError::BufferFull);
+            }
+            Err(TrySendError::Disconnected(_)) => {
+                return Err(TunChannelAppError::Disconnected);
+            }
+        }
+    }
+}
+
+impl Reader for TunChannelReader {
+    type Error = LinuxTunError;
+
+    fn read(&self, buf: &mut [u8], offset: usize) -> Result<usize, Self::Error> {
+        loop {
+            match self.rx.recv() {
+                Ok(msg) => {
+                    let n = min(buf.len() - offset, msg.len());
+                    buf[offset..offset + n].copy_from_slice(&msg[..n]);
+                    debug!(
+                        "TunChannelReader::TUN({}): read ({}, {})",
+                        self.id,
+                        n,
+                        hex::encode(&buf[offset..offset + n])
+                    );
+                    return Ok(n);
+                }
+                Err(_) => {
+                    return Err(LinuxTunError::Closed);
+                }
+            }
+        }
+    }
+}
+
+impl Writer for TunChannelWriter {
+    type Error = LinuxTunError;
+
+    fn write(&self, src: &[u8]) -> Result<(), Self::Error> {
+        debug!(
+            "TunChannelWriter::TUN({}) : write ({}, {})",
+            self.id,
+            src.len(),
+            hex::encode(src)
+        );
+        let m = src.to_owned();
+        match self.tx.send(m) {
+            Ok(_) => Ok(()),
+            Err(_) => Err(LinuxTunError::Closed),
+        }
+    }
+}
+
+impl Tun for TunChannel {
+    type Writer = TunChannelWriter;
+    type Reader = TunChannelReader;
+    type Error = LinuxTunError;
+}
+
+impl TunChannel {
+    pub fn create(
+        name: &str,
+    ) -> Result<
+        (
+            TunChannelAppReader,
+            TunChannelAppWriter,
+            Vec<TunChannelReader>,
+            TunChannelWriter,
+            LinuxTunStatus,
+        ),
+        LinuxTunError,
+    > {
+        // construct request struct
+        let mut req = Ifreq {
+            name: [0u8; libc::IFNAMSIZ],
+            flags: (libc::IFF_TUN | libc::IFF_NO_PI) as c_short,
+            _pad: [0u8; 64],
+        };
+
+        // sanity check length of device name
+        let bs = name.as_bytes();
+        if bs.len() > libc::IFNAMSIZ - 1 {
+            return Err(LinuxTunError::InvalidTunDeviceName);
+        }
+        req.name[..bs.len()].copy_from_slice(bs);
+
+        // open clone device
+        let fd: RawFd = match unsafe { libc::open(CLONE_DEVICE_PATH.as_ptr() as _, libc::O_RDWR) } {
+            -1 => return Err(LinuxTunError::FailedToOpenCloneDevice),
+            fd => fd,
+        };
+        assert!(fd >= 0);
+
+        // create TUN device
+        if unsafe { libc::ioctl(fd, TUNSETIFF as _, &req) } < 0 {
+            unsafe { libc::close(fd) };
+            return Err(LinuxTunError::SetIFFIoctlFailed);
+        }
+
+        let status = LinuxTunStatus::new(req.name)?;
+        // Create two TUN channel pairs - for sending/receiving
+        // App write (tx1) -> WireGuard read (rx1).
+        // WireGuard write (tx2) -> App read (rx2).
+        let (tx1, rx1) = sync_channel(1024);
+        let (tx2, rx2) = sync_channel(1024);
+        let id: u32 = OsRng.gen();
+        let tun_app_reader = TunChannelAppReader { id, rx: rx2 };
+        let tun_app_writer = TunChannelAppWriter { id, tx: tx1 };
+        let reader = TunChannelReader { id, rx: rx1 };
+        let writer = TunChannelWriter { id, tx: tx2 };
+        Ok((tun_app_reader, tun_app_writer, vec![reader], writer, status))
+    }
+}
+
+impl PlatformTun for TunChannel {
+    type Status = LinuxTunStatus;
+
+    fn create(_name: &str) -> Result<(Vec<Self::Reader>, Self::Writer, Self::Status), Self::Error> {
+        Err(LinuxTunError::Closed)
+    }
+}
diff --git a/src/platform/linux/cndp/udp.rs b/src/platform/linux/cndp/udp.rs
new file mode 100644
index 0000000..d373060
--- /dev/null
+++ b/src/platform/linux/cndp/udp.rs
@@ -0,0 +1,1365 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+
+use crossbeam_queue::SegQueue;
+use hjul::{Runner, Timer};
+use pnet::datalink::MacAddr;
+use std::collections::HashMap;
+use std::collections::HashSet;
+use std::net::IpAddr;
+use std::ops::Deref;
+use std::slice;
+use std::sync::mpsc::{sync_channel, Receiver, RecvTimeoutError, SyncSender};
+use std::sync::{Arc, RwLock};
+use std::thread;
+use std::time::Duration;
+use std::time::SystemTime;
+
+use super::super::super::udp::*;
+use super::endpoint::CndpEndpoint;
+
+use super::cndp::*;
+use super::packet::*;
+use super::util::*;
+
+// CNDP UDP Json Data
+pub struct CndpUdpJsonData<'a> {
+    pub iface_name: Option<String>,
+    pub endpoint: Option<CndpEndpoint>,
+    pub fwd_port_thd_reader: &'a mut jcfg_thd,
+    pub fwd_port_thd_writer: &'a mut jcfg_thd,
+    pub lport_reader: jcfg_lport,
+    pub lport_writer: jcfg_lport,
+    pub reader_core_id: Option<usize>,
+    pub writer_core_id: Option<usize>,
+}
+
+// CNDP UDP Bind
+pub struct CndpUdpReader<'a> {
+    pub iface_name: Option<String>,
+    endpoint: Option<CndpEndpoint>,
+    fwd_port_thd: Arc<RwLock<&'a mut jcfg_thd>>,
+    lport: jcfg_lport,
+    core_id: Option<usize>,
+    cne_uids: RwLock<HashSet<i32>>,
+    cur_pkt_index: i32,
+    last_num_pkts_read: u16,
+}
+
+pub struct CndpUdpWriter<'a> {
+    pub iface_name: Option<String>,
+    endpoint: Option<CndpEndpoint>,
+    dst_mac_map: RwLock<HashMap<IpAddr, MacAddr>>,
+    fwd_port_thd: Arc<RwLock<&'a mut jcfg_thd>>,
+    lport: jcfg_lport,
+    core_id: Option<usize>,
+    cne_uids: RwLock<HashSet<i32>>,
+}
+
+pub struct CndpUdpBufferedWriterInner<'a> {
+    pub iface_name: Option<String>,
+    endpoint: Option<CndpEndpoint>,
+    dst_mac_map: RwLock<HashMap<IpAddr, MacAddr>>,
+    fwd_port_thd: Arc<RwLock<&'a mut jcfg_thd>>,
+    lport: jcfg_lport,
+    core_id: Option<usize>,
+    cne_uids: RwLock<HashSet<i32>>,
+    pkts: RwLock<Vec<PacketSendData>>,
+    runner: Runner,
+    timer: RwLock<Option<Timer>>,
+}
+
+pub struct CndpUdpBufferedWriter<'a> {
+    inner: Arc<CndpUdpBufferedWriterInner<'a>>,
+}
+
+pub struct CndpUdpBufferQueueWriterInner<'a> {
+    pub iface_name: Option<String>,
+    endpoint: Option<CndpEndpoint>,
+    dst_mac_map: RwLock<HashMap<IpAddr, MacAddr>>,
+    fwd_port_thd: Arc<RwLock<&'a mut jcfg_thd>>,
+    lport: jcfg_lport,
+    core_id: Option<usize>,
+    cne_uids: RwLock<HashSet<i32>>,
+    pkts: SegQueue<PacketSendData>,
+    runner: Runner,
+    timer: RwLock<Option<Timer>>,
+}
+
+pub struct CndpUdpBufferQueueWriter<'a> {
+    inner: Arc<CndpUdpBufferQueueWriterInner<'a>>,
+}
+
+pub struct PacketSendData {
+    pub buf: Vec<u8>,
+    pub src_endpoint: CndpEndpoint,
+    pub dst_endpoint: CndpEndpoint,
+}
+
+pub struct CndpUdpWriterSenderChannel<'a> {
+    iface_name: Option<String>,
+    endpoint: Option<CndpEndpoint>,
+    dst_mac_map: RwLock<HashMap<IpAddr, MacAddr>>,
+    fwd_port_thd: Arc<RwLock<&'a mut jcfg_thd>>,
+    core_id: Option<usize>,
+    cne_uids: RwLock<HashSet<i32>>,
+    sender: SyncSender<PacketSendData>,
+}
+
+pub struct CndpUdpWriterReceiverChannel<'a> {
+    fwd_port_thd: Arc<RwLock<&'a mut jcfg_thd>>,
+    lport: jcfg_lport,
+    core_id: Option<usize>,
+    receiver: Receiver<PacketSendData>,
+}
+
+struct CndpUdpCommon {}
+
+#[derive(Clone)]
+pub struct CndpUdpSyncChannel {}
+
+#[derive(Clone)]
+pub struct CndpUdpBuffered {}
+
+#[derive(Clone)]
+pub struct CndpUdpBufferQueue {}
+
+impl UDP for CndpUdpSyncChannel {
+    type Error = CndpError;
+    type Endpoint = CndpEndpoint;
+    type Reader = CndpUdpReader<'static>;
+    type Writer = CndpUdpWriterSenderChannel<'static>;
+}
+
+impl UDP for CndpUdpBuffered {
+    type Error = CndpError;
+    type Endpoint = CndpEndpoint;
+    type Reader = CndpUdpReader<'static>;
+    type Writer = CndpUdpBufferedWriter<'static>;
+}
+
+impl UDP for CndpUdpBufferQueue {
+    type Error = CndpError;
+    type Endpoint = CndpEndpoint;
+    type Reader = CndpUdpReader<'static>;
+    type Writer = CndpUdpBufferQueueWriter<'static>;
+}
+
+impl CndpUdpCommon {
+    const READ_SLEEP_TIME_IN_MICROS: u64 = 20;
+    const READ_BURST_PKTS: u16 = 128;
+    const WRITE_THRESHOLD_NUM_PKTS: usize = 32;
+    const WRITE_WAIT_DURATION_IN_MICROS: u64 = 10;
+    const WRITE_CALLBACK_TIMER_DURATION_IN_MICROS: u64 = 100;
+}
+
+impl<'a> Reader<CndpEndpoint> for CndpUdpReader<'a> {
+    type Error = CndpError;
+    fn read(&mut self, buf: &mut [u8]) -> Result<(usize, CndpEndpoint), Self::Error> {
+        // If this function is called from a Wireguard Rust thread register it with CNDP.
+        let register = CneRegister::new("CndpUdpReader", self.core_id);
+        if register.cne_uid > 0 {
+            let mut cne_uids = self.cne_uids.write().unwrap();
+            (*cne_uids).insert(register.cne_uid);
+        }
+        // Loop till we get atleast 1 packet or thread quits.
+        loop {
+            if CndpUdpCommon::has_fwd_port_thd_quit(&self.fwd_port_thd)
+                || CndpInstance::has_cndp_quit()
+            {
+                log::debug!("Cndp Reader forward port thread quitted");
+                return Err(CndpError::Disconnected);
+            }
+            // Get lport for fwd thread.
+            let lport = self.lport;
+            let (udp_payload_len, endpoint) = self.read_lport(buf, &lport);
+            if udp_payload_len > 0 {
+                return Ok((udp_payload_len, endpoint));
+            } else {
+                // If there are no UDP packets then sleep for sometime.
+                // This will reduce CPU utilization instead of reading in tight loop
+                // and keeping CPU busy at 100%.
+                if self.last_num_pkts_read == 0 {
+                    thread::sleep(Duration::from_micros(
+                        CndpUdpCommon::READ_SLEEP_TIME_IN_MICROS,
+                    ));
+                }
+            }
+        }
+    }
+}
+
+impl<'a> CndpUdpReader<'a> {
+    fn read_lport(&mut self, buf: &mut [u8], lport: &jcfg_lport) -> (usize, CndpEndpoint) {
+        if let Some(fport) = get_fwd_port(lport) {
+            // Get RX pktmbuf buffers -> pktmbuf** pointer
+            let rx_pktmbufs_pptr = get_rx_mbufs(&fport).unwrap();
+            if self.last_num_pkts_read == 0 {
+                // Get burst of RX packets.
+                self.last_num_pkts_read = unsafe {
+                    pktdev_rx_burst_fn(
+                        fport.lport as u16,
+                        rx_pktmbufs_pptr,
+                        CndpUdpCommon::READ_BURST_PKTS,
+                    )
+                };
+                if self.last_num_pkts_read > 0 {
+                    self.cur_pkt_index = 0;
+                    log::debug!(
+                        "Read bulk {} UDP Packets at time {}",
+                        self.last_num_pkts_read,
+                        SystemTime::now()
+                            .duration_since(std::time::UNIX_EPOCH)
+                            .unwrap()
+                            .as_micros()
+                    );
+                }
+            }
+            // Process RX packet.
+            if self.last_num_pkts_read > 0 {
+                // Get a single RX pktmbuf.
+                let pkt_mbuf = get_item_at_index(self.cur_pkt_index as u16, rx_pktmbufs_pptr);
+                self.cur_pkt_index = self.cur_pkt_index + 1;
+                // Parse pktmbuf to get UDP payload, length and endpoint.
+                let (udp_payload_len, endpoint) = CndpUdpCommon::parse_pktmbuf(buf, &pkt_mbuf);
+                // If all packets are processed free them.
+                if self.cur_pkt_index == self.last_num_pkts_read as i32 {
+                    // Free RX buffers.
+                    unsafe {
+                        pktmbuf_free_bulk_fn(rx_pktmbufs_pptr, self.last_num_pkts_read as u32)
+                    };
+                    self.cur_pkt_index = -1;
+                    self.last_num_pkts_read = 0;
+                }
+                return (udp_payload_len as usize, endpoint);
+            }
+        }
+        return (0, CndpEndpoint::new(None, None, None));
+    }
+}
+
+impl<'a> Drop for CndpUdpReader<'a> {
+    fn drop(&mut self) {
+        log::debug!("CndpUdpReader drop");
+        let cne_uids = self.cne_uids.write().unwrap();
+        CndpUdpCommon::unregister_cne_uids(&(*cne_uids));
+    }
+}
+
+impl Writer<CndpEndpoint> for CndpUdpWriter<'static> {
+    type Error = CndpError;
+    fn write(&self, buf: Vec<u8>, dst: &mut CndpEndpoint) -> Result<(), Self::Error> {
+        // If this function is called from a Wireguard Rust thread register it with CNDP.
+        let register = CneRegister::new("CndpUdpWriter", None);
+        if register.cne_uid > 0 {
+            let mut cne_uids = self.cne_uids.write().unwrap();
+            (*cne_uids).insert(register.cne_uid);
+        }
+        if CndpUdpCommon::has_fwd_port_thd_quit(&self.fwd_port_thd) || CndpInstance::has_cndp_quit()
+        {
+            log::debug!("Cndp Writer forward port thread quitted");
+            return Err(CndpError::Disconnected);
+        }
+        // Get lport for fwd thread.
+        let lport = self.lport;
+        let ret = self.write_lport(buf, dst, &lport);
+        if ret < 0 {
+            log::error!("Cndp Writer failed");
+            return Err(CndpError::WriterError);
+        }
+        Ok(())
+    }
+}
+
+impl<'a> CndpUdpWriter<'a> {
+    fn write_lport(&self, buf: Vec<u8>, dst: &mut CndpEndpoint, lport: &jcfg_lport) -> i32 {
+        if dst.ip.is_none() {
+            log::debug!("CndpUdpWriter: Dst ip address is not set: dst = {:?}", dst);
+            return -1;
+        }
+        if dst.port.is_none() {
+            log::debug!("CndpUdpWriter: Dst port is not set");
+            return -1;
+        }
+        if dst.mac.is_none() {
+            let mut cur_dst_mac_map = self.dst_mac_map.write().unwrap();
+            let dst_ip = dst.ip.unwrap();
+            // If dst_mac for this dst_ip is not in map get it via ARP.
+            if !(*cur_dst_mac_map).contains_key(&dst_ip) {
+                let dst_ipv4 = match dst_ip {
+                    IpAddr::V4(ip) => ip,
+                    _ => unreachable!(),
+                };
+                let iface_name = self.iface_name.as_ref();
+                let (_, dst_mac) = CndpPacket::get_mac_through_arp(&iface_name.unwrap(), dst_ipv4);
+                if let Some(dst_mac) = dst_mac {
+                    log::debug!("dst mac from ARP = {}", dst_mac);
+                    // Store dst_mac in map.
+                    (*cur_dst_mac_map).insert(dst_ip, dst_mac);
+                } else {
+                    log::debug!("CndpUdpWriterSenderChannel: Dst mac couldn't be determined");
+                    return -1;
+                }
+            }
+            let dst_mac = (*cur_dst_mac_map).get(&dst_ip).expect("Dst mac not found");
+            dst.mac = Some(*dst_mac);
+        }
+        if let Some(fport) = get_fwd_port(lport) {
+            // Get TX pktmbuf buffers -> pktmbuf** pointer
+            let tx_pktmbufs_pptr = get_tx_mbufs(&fport).unwrap();
+            // Get burst of TX packets.
+            let mut n_pkts =
+                unsafe { pktdev_buf_alloc(fport.lport as i32, tx_pktmbufs_pptr, 1) as u16 };
+            // Send TX packets.
+            if n_pkts > 0 {
+                // Get a single TX pktmbuf.
+                let pkt_mbuf = get_item_at_index(0 as u16, tx_pktmbufs_pptr);
+                // Update pktmbuf with UDP data (payload + ip/udp/eth headers).
+                let ret =
+                    CndpUdpCommon::update_pktmbuf(&buf, &pkt_mbuf, &self.endpoint.unwrap(), dst);
+                if ret < 0 {
+                    log::debug!("CndpUdpWriter: update_pktmbuf failed");
+                    return ret;
+                }
+                let mut n = 0 as u16;
+                loop {
+                    // TX buffers (pktmbufs) starting at index n.
+                    let tx_mbufs = get_tx_mbufs(&fport).unwrap();
+                    let tx_mbufs = unsafe { tx_mbufs.offset(n as isize) };
+                    n = unsafe { pktdev_tx_burst_fn(fport.lport as u16, tx_mbufs, n_pkts) };
+                    if n_pkts <= n {
+                        break;
+                    }
+                    log::debug!("Couldn't send all packets. Retry");
+                    n_pkts -= n;
+                }
+            }
+            /*NOTE: the RX burst is needed to prevent lockups on CVL*/
+            let n_pkts = unsafe { pktdev_rx_burst_fn(fport.lport as u16, tx_pktmbufs_pptr, 1) };
+            if n_pkts > 0 {
+                unsafe { pktmbuf_free_bulk_fn(tx_pktmbufs_pptr, n_pkts as u32) };
+            }
+        }
+        return 0;
+    }
+}
+
+impl<'a> Drop for CndpUdpWriter<'a> {
+    fn drop(&mut self) {
+        log::debug!("CndpUdpWriter drop");
+        let cne_uids = self.cne_uids.write().unwrap();
+        CndpUdpCommon::unregister_cne_uids(&(*cne_uids));
+    }
+}
+
+impl CndpUdpCommon {
+    pub fn get_json_data<'a>(port: u16) -> CndpUdpJsonData<'a> {
+        // Reader uses fwd thread 0 (at index 1) and lport index 0 for fwd thread 0.
+        let fwd_port_thd_reader =
+            CndpInstance::get_thread_from_index(1).expect("No fwd thread present at index 1");
+        let lport_reader = *CndpInstance::get_thread_lport_from_index(fwd_port_thd_reader, 0)
+            .expect("No lport present at index 0");
+
+        // Get interface details
+        let (iface_name, src_mac, src_ip) =
+            CndpInstance::get_interface_details(get_str_from_raw_ptr(lport_reader.netdev));
+        let bind_endpoint = CndpEndpoint::new(src_ip, Some(port), src_mac);
+        let reader_thread_coreid = match CndpInstance::read_config("reader_thread_coreid") {
+            Some(v) => Some(v.as_integer().expect("core id should be integer") as usize),
+            None => None,
+        };
+
+        // Writer uses fwd thread 1 (at index 2) and lport index 0 for fwd thread 1.
+        let fwd_port_thd_writer =
+            CndpInstance::get_thread_from_index(2).expect("No fwd thread present at index 2");
+        let lport_writer = *CndpInstance::get_thread_lport_from_index(fwd_port_thd_writer, 0)
+            .expect("No lport present at index 0");
+        let writer_thread_coreid = match CndpInstance::read_config("writer_thread_coreid") {
+            Some(v) => Some(v.as_integer().expect("core id should be integer") as usize),
+            None => None,
+        };
+        // Create CndpJsonBind return value.
+        let json_data = CndpUdpJsonData {
+            iface_name: iface_name,
+            endpoint: Some(bind_endpoint),
+            fwd_port_thd_reader: fwd_port_thd_reader,
+            fwd_port_thd_writer: fwd_port_thd_writer,
+            lport_reader: lport_reader,
+            lport_writer: lport_writer,
+            reader_core_id: reader_thread_coreid,
+            writer_core_id: writer_thread_coreid,
+        };
+        return json_data;
+    }
+
+    pub fn parse_pktmbuf(
+        buf: &mut [u8],
+        pkt_mbuf: &Option<*mut pktmbuf_s>,
+    ) -> (usize, CndpEndpoint) {
+        // Validate pktmbuf.
+        if pkt_mbuf.is_none() {
+            log::debug!("Cndp Reader pktmbuf is null");
+            return (0, CndpEndpoint::new(None, None, None));
+        };
+        let pkt_mbuf = pkt_mbuf.unwrap();
+        // Get pktmbuf data length.
+        let data_len = get_pktmbuf_data_len(pkt_mbuf);
+        if data_len == 0 {
+            log::debug!("Cndp Reader pktmbuf data len = 0");
+            return (0, CndpEndpoint::new(None, None, None));
+        }
+        // Get pktmbuf data pointer.
+        let pkt_data_addr = get_pktmbuf_data(pkt_mbuf);
+        if pkt_data_addr.is_none() {
+            log::debug!("Cndp Reader pktmbuf data is null");
+            return (0, CndpEndpoint::new(None, None, None));
+        };
+        let pkt_data_addr = pkt_data_addr.unwrap();
+        // Create CNDP packet structure.
+        let mut cndp_eth_packet = CndpPacket::new(pkt_data_addr, data_len as usize).unwrap();
+        let ret = cndp_eth_packet.parse_eth_udp_tcp_packet();
+        if ret < 0 {
+            log::debug!("Malformed cndp_ethernet_packet");
+            return (0, CndpEndpoint::new(None, None, None));
+        }
+        log::debug!("Read cndp_ethernet_packet = {}", cndp_eth_packet);
+        if cndp_eth_packet.src_ip.is_none() || cndp_eth_packet.dst_ip.is_none() {
+            log::debug!("Src ip or Dst ip is not set");
+            return (0, CndpEndpoint::new(None, None, None));
+        }
+        if cndp_eth_packet.src_port.is_none() || cndp_eth_packet.dst_port.is_none() {
+            log::debug!("Src port or Dst port is not set");
+            return (0, CndpEndpoint::new(None, None, None));
+        }
+        //log::debug!("Read cndp_ethernet_packet = {}", cndp_eth_packet);
+        let (udp_payload, udp_payload_len) = cndp_eth_packet.get_udp_payload_ptr();
+        if udp_payload_len > 0 {
+            let udp_payload = udp_payload.unwrap();
+            if udp_payload.is_null() {
+                // UDP payload should not be null if udp_payload_len > 0
+                panic!("UDP payload is null when UDP payload length > 0");
+            }
+            if udp_payload_len < buf.len() {
+                let p = unsafe { slice::from_raw_parts_mut(udp_payload, udp_payload_len as usize) };
+                buf[..udp_payload_len as usize].copy_from_slice(&p[..]);
+            } else {
+                log::error!(
+                    "UDP Payload length {} is more than buffer length {}",
+                    udp_payload_len,
+                    buf.len()
+                );
+                return (0, CndpEndpoint::new(None, None, None));
+            }
+        } else {
+            log::debug!("Cndp Reader UDP payload len = 0");
+        }
+        let endpoint = CndpEndpoint::new(
+            cndp_eth_packet.src_ip,
+            cndp_eth_packet.src_port,
+            cndp_eth_packet.src_mac,
+        );
+        log::debug!(
+            "Read 1 UDP Payload(size = {}), Ethernet Packet(size = {}) at time {}",
+            udp_payload_len,
+            data_len,
+            SystemTime::now()
+                .duration_since(std::time::UNIX_EPOCH)
+                .unwrap()
+                .as_micros()
+        );
+        return (udp_payload_len as usize, endpoint);
+    }
+
+    pub fn update_pktmbuf(
+        buf: &[u8],
+        pkt_mbuf: &Option<*mut pktmbuf_s>,
+        src: &CndpEndpoint,
+        dst: &CndpEndpoint,
+    ) -> i32 {
+        // Validate pktmbuf.
+        if pkt_mbuf.is_none() {
+            log::debug!("update_pktmbuf: pktmbuf is null");
+            return -1;
+        };
+        let pkt_mbuf = pkt_mbuf.unwrap();
+        // Get total length of packet.
+        let data_len = CndpPacket::get_eth_udp_packet_len(buf.len()) as u16;
+        // Get pktmbuf data pointer.
+        let pkt_data_addr = get_pktmbuf_data(pkt_mbuf);
+        if pkt_data_addr.is_none() {
+            log::debug!("update_pktmbuf: pktmbuf data is null");
+            return -1;
+        };
+        let pkt_data_addr = pkt_data_addr.unwrap();
+        // Create CNDP packet structure.
+        let mut cndp_eth_packet = CndpPacket::new(pkt_data_addr, data_len as usize).unwrap();
+        // Update CNDP packet.
+        cndp_eth_packet.update_eth_udp_packet(
+            src.mac.unwrap(),
+            dst.mac.unwrap(),
+            src.ip.unwrap(),
+            dst.ip.unwrap(),
+            src.port.unwrap(),
+            dst.port.unwrap(),
+            buf,
+        );
+        // Keep below code commented.
+        /*cndp_eth_packet.parse_eth_udp_packet();
+        let (udp_payload, udp_payload_len) = cndp_eth_packet.get_udp_payload_ptr();
+        log::debug!("Write UDP payload len = {}", udp_payload_len);
+        log::debug!("write cndp_ethernet_packet = {}", cndp_eth_packet);
+        */
+        // Set packet length.
+        set_pktmbuf_data_len(pkt_mbuf, data_len);
+        return 0;
+    }
+
+    pub fn free_tx_buffers(lport_index: u16, tx_pktmbufs_pptr: *mut *mut pktmbuf_s, n_pkts: u16) {
+        unsafe {
+            if tx_pktmbufs_pptr.is_null() {
+                return;
+            }
+            /*NOTE: the RX burst is needed to prevent lockups on CVL*/
+            let n_pkts = pktdev_rx_burst_fn(lport_index, tx_pktmbufs_pptr, n_pkts);
+            if n_pkts > 0 {
+                pktmbuf_free_bulk_fn(tx_pktmbufs_pptr, n_pkts as u32);
+            }
+        }
+    }
+
+    fn send_pkts(pkts: &mut Vec<PacketSendData>, lport: &jcfg_lport) -> i32 {
+        if let Some(fport) = get_fwd_port(lport) {
+            // Get TX pktmbuf buffers -> pktmbuf** pointer
+            let tx_pktmbufs_pptr = get_tx_mbufs(&fport).unwrap();
+            let num_pkts_to_send = pkts.len();
+            let n_pkts = unsafe {
+                pktdev_buf_alloc(
+                    fport.lport as i32,
+                    tx_pktmbufs_pptr,
+                    num_pkts_to_send as u16,
+                ) as u16
+            };
+            if n_pkts < num_pkts_to_send as u16 {
+                log::debug!("Cannot allocate enough buffers to send all packets");
+                log::debug!("Requested = {}, Allocated = {}", num_pkts_to_send, n_pkts);
+            }
+            if n_pkts > 0 {
+                log::debug!(
+                    "Send {} UDP packets at time {}",
+                    n_pkts,
+                    SystemTime::now()
+                        .duration_since(std::time::UNIX_EPOCH)
+                        .unwrap()
+                        .as_micros()
+                );
+                for i in 0..n_pkts {
+                    // Get data buf.
+                    // Remove packet from front of the list and move the ownership out of the list.
+                    let pkt = pkts.remove(0 as usize);
+                    let buf = pkt.buf;
+                    let src_endpoint = pkt.src_endpoint;
+                    let dst_endpoint = pkt.dst_endpoint;
+                    // Get a single TX pktmbuf.
+                    let pkt_mbuf = get_item_at_index(i as u16, tx_pktmbufs_pptr);
+                    // Update pktmbuf with UDP data (payload + ip/udp/eth headers).
+                    let ret = CndpUdpCommon::update_pktmbuf(
+                        &buf,
+                        &pkt_mbuf,
+                        &src_endpoint,
+                        &dst_endpoint,
+                    );
+                    if ret < 0 {
+                        log::error!("update_pktmbuf failed");
+                        // Free buffers and return
+                        CndpUdpCommon::free_tx_buffers(
+                            fport.lport as u16,
+                            tx_pktmbufs_pptr,
+                            n_pkts,
+                        );
+                        return -1;
+                    }
+                }
+                let mut n = 0 as u16;
+                let mut n_pkts_to_send = n_pkts;
+                loop {
+                    // TX buffers (pktmbufs) starting at index n.
+                    let tx_mbufs = get_tx_mbufs(&fport).unwrap();
+                    let tx_mbufs = unsafe { tx_mbufs.offset(n as isize) };
+                    n = unsafe { pktdev_tx_burst_fn(fport.lport as u16, tx_mbufs, n_pkts_to_send) };
+                    log::debug!(
+                        "Sent {} UDP packets at time {}",
+                        n,
+                        SystemTime::now()
+                            .duration_since(std::time::UNIX_EPOCH)
+                            .unwrap()
+                            .as_micros()
+                    );
+                    if n_pkts_to_send <= n {
+                        break;
+                    }
+                    log::debug!("Couldn't send all packets. Retry");
+                    n_pkts_to_send -= n;
+                }
+            }
+            CndpUdpCommon::free_tx_buffers(fport.lport as u16, tx_pktmbufs_pptr, n_pkts as u16);
+        }
+        return 0;
+    }
+
+    pub fn unregister_cne_uids(cne_uids: &HashSet<i32>) {
+        for cne_uid in cne_uids {
+            unsafe {
+                if cne_unregister(*cne_uid) < 0 {
+                    log::error!("cne_unregister failed for cne_uid = {}", *cne_uid);
+                }
+            }
+        }
+    }
+
+    pub fn has_fwd_port_thd_quit<'a>(fwd_port_thd: &Arc<RwLock<&'a mut jcfg_thd>>) -> bool {
+        let fwd_port_thd = fwd_port_thd.read().unwrap();
+        let ret = match (*fwd_port_thd).quit {
+            0 => false,
+            _ => true,
+        };
+        ret
+    }
+
+    pub fn dump_pktmbuf(pkt_mbuf: &Option<*mut pktmbuf_s>) {
+        let pkt_mbuf = pkt_mbuf.unwrap();
+        unsafe {
+            let msg = "Dump pktmbuf\n";
+            // Passing null ptr will dump to stdout.
+            pktmbuf_dump(
+                std::ptr::null_mut() as *mut FILE,
+                get_cstring_from_str(msg).as_ptr(),
+                pkt_mbuf,
+                1500,
+            );
+        }
+    }
+}
+
+impl PlatformUDP for CndpUdpSyncChannel {
+    type Owner = CndpOwner<'static>;
+    fn bind(port: u16) -> Result<(Vec<Self::Reader>, Self::Writer, Self::Owner), Self::Error> {
+        log::info!("Wireguard called bind at port {}", port);
+        let register = CneRegister::new("CndpUdpSyncChannel", None);
+        // Get Cndp UDP Json Data.
+        let json_data = CndpUdpCommon::get_json_data(port);
+        // Create Arc RwLock.
+        let fwd_port_thd_reader_arc_mutex = Arc::new(RwLock::new(json_data.fwd_port_thd_reader));
+        // Create Cndp UDP Reader.
+        let reader = CndpUdpReader {
+            iface_name: json_data.iface_name.clone(),
+            endpoint: json_data.endpoint,
+            fwd_port_thd: Arc::clone(&fwd_port_thd_reader_arc_mutex),
+            lport: json_data.lport_reader,
+            core_id: json_data.reader_core_id,
+            cne_uids: RwLock::new(HashSet::new()),
+            cur_pkt_index: -1,
+            last_num_pkts_read: 0,
+        };
+        let readers: Vec<Self::Reader> = vec![reader];
+
+        // Create Cndp UDP Writer channel.
+        // UDP writer send channel thread, sends UDP packet to the channel.
+        // UDP writer receive channel thread, reads UDP packet from channel,
+        // creates ethernet packet, accumulates the packets till a given
+        // threshold or till timeout occurs and then sends the burst of packet to peer node.
+        let (sender_w, receiver_w) = sync_channel::<PacketSendData>(1024);
+        // Create Arc RwLock.
+        let fwd_port_thd_writer_arc_mutex = Arc::new(RwLock::new(json_data.fwd_port_thd_writer));
+        let writer_recv = CndpUdpWriterReceiverChannel {
+            fwd_port_thd: Arc::clone(&fwd_port_thd_writer_arc_mutex),
+            lport: json_data.lport_writer,
+            core_id: json_data.writer_core_id,
+            receiver: receiver_w,
+        };
+        let writer = CndpUdpWriterSenderChannel {
+            iface_name: json_data.iface_name.clone(),
+            endpoint: json_data.endpoint,
+            dst_mac_map: RwLock::new(HashMap::new()),
+            fwd_port_thd: Arc::clone(&fwd_port_thd_writer_arc_mutex),
+            core_id: json_data.writer_core_id,
+            cne_uids: RwLock::new(HashSet::new()),
+            sender: sender_w,
+        };
+        let owner = CndpOwner {
+            cne_uid: register.cne_uid,
+            fwd_port_thd_reader: Arc::clone(&fwd_port_thd_reader_arc_mutex),
+            fwd_port_thd_writer: Arc::clone(&fwd_port_thd_writer_arc_mutex),
+        };
+        // UDP writer receive channel thread.
+        thread::spawn(move || {
+            writer_recv.write();
+        });
+        // Show metrics if enabled. Run in a separate thread.
+        let metrics_thread_coreid = match CndpInstance::read_config("metrics_thread_coreid") {
+            Some(v) => v.as_integer().expect("core id should be integer"),
+            None => -1,
+        };
+        if metrics_thread_coreid > 0 {
+            thread::spawn(move || {
+                CndpInstance::show_metrics(Some(metrics_thread_coreid as usize));
+            });
+        }
+        return Ok((readers, writer, owner));
+    }
+}
+
+impl Writer<CndpEndpoint> for CndpUdpWriterSenderChannel<'static> {
+    type Error = CndpError;
+    fn write(&self, buf: Vec<u8>, dst: &mut CndpEndpoint) -> Result<(), Self::Error> {
+        // If this function is called from a Wireguard Rust thread register it with CNDP.
+        let register = CneRegister::new("CndpUdpWriterSenderChannel", None);
+        if register.cne_uid > 0 {
+            let mut cne_uids = self.cne_uids.write().unwrap();
+            (*cne_uids).insert(register.cne_uid);
+        }
+        if CndpUdpCommon::has_fwd_port_thd_quit(&self.fwd_port_thd) {
+            log::debug!("Cndp Writer forward port thread quitted");
+            return Err(CndpError::Disconnected);
+        }
+        if dst.ip.is_none() {
+            log::debug!("Dst ip address is not set: dst = {:?}", dst);
+            return Err(CndpError::WriterError);
+        }
+        if dst.port.is_none() {
+            log::debug!("Dst port is not set");
+            return Err(CndpError::WriterError);
+        }
+        if dst.mac.is_none() {
+            let mut cur_dst_mac_map = self.dst_mac_map.write().unwrap();
+            let dst_ip = dst.ip.unwrap();
+            // If dst_mac for this dst_ip is not in map get it via ARP.
+            if !(*cur_dst_mac_map).contains_key(&dst_ip) {
+                let dst_ipv4 = match dst_ip {
+                    IpAddr::V4(ip) => ip,
+                    _ => unreachable!(),
+                };
+                let iface_name = self.iface_name.as_ref();
+                let (_, dst_mac) = CndpPacket::get_mac_through_arp(&iface_name.unwrap(), dst_ipv4);
+                if let Some(dst_mac) = dst_mac {
+                    log::debug!("dst mac from ARP = {}", dst_mac);
+                    // Store dst_mac in map.
+                    (*cur_dst_mac_map).insert(dst_ip, dst_mac);
+                } else {
+                    log::debug!("Dst mac couldn't be determined");
+                    return Err(CndpError::WriterError);
+                }
+            }
+            let dst_mac = (*cur_dst_mac_map).get(&dst_ip).expect("Dst mac no found");
+            dst.mac = Some(*dst_mac);
+        }
+        // Get lport for fwd thread.
+        let pkt_send_data = PacketSendData {
+            buf: buf,
+            src_endpoint: self.endpoint.unwrap(),
+            dst_endpoint: *dst,
+        };
+        match self.sender.send(pkt_send_data) {
+            Err(_) => {
+                log::debug!("CndpUdpWriterSenderChannel: Send Error");
+                return Err(CndpError::WriterError);
+            }
+            Ok(_) => {
+                log::debug!("CndpUdpWriterSenderChannel: Send UDP data");
+                log::debug!(
+                    "CndpUdpWriterSenderChannel Send UDP 1 packet at time {}",
+                    SystemTime::now()
+                        .duration_since(std::time::UNIX_EPOCH)
+                        .unwrap()
+                        .as_micros()
+                );
+            }
+        }
+        Ok(())
+    }
+}
+
+impl<'a> Drop for CndpUdpWriterSenderChannel<'a> {
+    fn drop(&mut self) {
+        log::debug!("CndpUdpWriterSenderChannel drop");
+        let cne_uids = self.cne_uids.write().unwrap();
+        CndpUdpCommon::unregister_cne_uids(&(*cne_uids));
+        log::debug!(
+            "CndpUdpWriterSenderChannel unregister {} cne_uids",
+            (*cne_uids).len()
+        );
+    }
+}
+
+impl<'a> CndpUdpWriterReceiverChannel<'a> {
+    fn write(&self) {
+        let register = CneRegister::new("CndpUdpWriterReceiverChannel", self.core_id);
+        let mut num_pkts_received = 0;
+        let mut pkts = Vec::new();
+        let wait_time = Duration::from_micros(CndpUdpCommon::WRITE_WAIT_DURATION_IN_MICROS);
+        let mut send_packets = false;
+        loop {
+            if CndpUdpCommon::has_fwd_port_thd_quit(&self.fwd_port_thd)
+                || CndpInstance::has_cndp_quit()
+            {
+                log::debug!("Cndp Writer forward port thread quitted");
+                break;
+            }
+            // If number of packets received is greater than a threshold
+            // or timeout occurs send packets received (if any).
+            match self.receiver.recv_timeout(wait_time) {
+                Ok(data) => {
+                    log::debug!(
+                        "CndpUdpWriterReceiverChannel: Receive UDP data, num_pkts_received= {}",
+                        num_pkts_received
+                    );
+                    num_pkts_received += 1;
+                    pkts.push(data);
+                    send_packets = num_pkts_received >= CndpUdpCommon::WRITE_THRESHOLD_NUM_PKTS;
+                }
+                Err(RecvTimeoutError::Timeout) => {
+                    // Check if there are packets to be send.
+                    if !pkts.is_empty() {
+                        log::debug!("CndpUdpWriterReceiverChannel: Timeout. Send pending packets");
+                        send_packets = true;
+                    }
+                }
+                Err(RecvTimeoutError::Disconnected) => {
+                    log::debug!("CndpUdpWriterReceiverChannel : Disconnected");
+                    break;
+                }
+            }
+            if send_packets {
+                let lport = self.lport;
+                CndpUdpCommon::send_pkts(&mut pkts, &lport);
+                // Reset.
+                pkts.clear();
+                num_pkts_received = 0;
+                send_packets = false;
+            }
+        }
+        // Unregister this thread from CNDP.
+        unsafe { cne_unregister(register.cne_uid) };
+    }
+}
+
+impl PlatformUDP for CndpUdpBuffered {
+    type Owner = CndpOwner<'static>;
+    fn bind(port: u16) -> Result<(Vec<Self::Reader>, Self::Writer, Self::Owner), Self::Error> {
+        log::info!("Wireguard called bind at port {}", port);
+        let register = CneRegister::new("CndpUdpBuffered", None);
+        // Get Cndp UDP Json Data.
+        let json_data = CndpUdpCommon::get_json_data(port);
+        // Create Arc RwLock.
+        let fwd_port_thd_reader_arc_mutex = Arc::new(RwLock::new(json_data.fwd_port_thd_reader));
+        // Create Cndp UDP Reader.
+        let reader = CndpUdpReader {
+            iface_name: json_data.iface_name.clone(),
+            endpoint: json_data.endpoint,
+            fwd_port_thd: Arc::clone(&fwd_port_thd_reader_arc_mutex),
+            lport: json_data.lport_reader,
+            core_id: json_data.reader_core_id,
+            cne_uids: RwLock::new(HashSet::new()),
+            cur_pkt_index: -1,
+            last_num_pkts_read: 0,
+        };
+        let readers: Vec<Self::Reader> = vec![reader];
+        // Create Arc RwLock.
+        let fwd_port_thd_writer_arc_mutex = Arc::new(RwLock::new(json_data.fwd_port_thd_writer));
+        // Create Cndp UDP Buffered Writer.
+        let writer = CndpUdpBufferedWriter {
+            inner: Arc::new(CndpUdpBufferedWriterInner {
+                iface_name: json_data.iface_name.clone(),
+                endpoint: json_data.endpoint,
+                dst_mac_map: RwLock::new(HashMap::new()),
+                fwd_port_thd: Arc::clone(&fwd_port_thd_writer_arc_mutex),
+                lport: json_data.lport_writer,
+                core_id: json_data.writer_core_id,
+                cne_uids: RwLock::new(HashSet::new()),
+                pkts: RwLock::new(Vec::new()),
+                runner: Runner::new(Duration::from_micros(10), 1000, 1024),
+                timer: RwLock::new(None),
+            }),
+        };
+
+        let owner = CndpOwner {
+            cne_uid: register.cne_uid,
+            fwd_port_thd_reader: Arc::clone(&fwd_port_thd_reader_arc_mutex),
+            fwd_port_thd_writer: Arc::clone(&fwd_port_thd_writer_arc_mutex),
+        };
+        // Show metrics if enabled. Run in a separate thread.
+        let metrics_thread_coreid = match CndpInstance::read_config("metrics_thread_coreid") {
+            Some(v) => v.as_integer().expect("core id should be integer"),
+            None => -1,
+        };
+        if metrics_thread_coreid > 0 {
+            thread::spawn(move || {
+                CndpInstance::show_metrics(Some(metrics_thread_coreid as usize));
+            });
+        }
+        return Ok((readers, writer.clone(), owner));
+    }
+}
+
+impl<'a> Deref for CndpUdpBufferedWriter<'a> {
+    type Target = CndpUdpBufferedWriterInner<'a>;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+
+impl Clone for CndpUdpBufferedWriter<'static> {
+    fn clone(&self) -> Self {
+        CndpUdpBufferedWriter {
+            inner: self.inner.clone(),
+        }
+    }
+}
+
+impl Writer<CndpEndpoint> for CndpUdpBufferedWriter<'static> {
+    type Error = CndpError;
+    fn write(&self, buf: Vec<u8>, dst: &mut CndpEndpoint) -> Result<(), Self::Error> {
+        // If this function is called from a Wireguard Rust thread register it with CNDP.
+        let register = CneRegister::new("CndpUdpBufferedWriter", None);
+        if register.cne_uid > 0 {
+            let mut cne_uids = self.cne_uids.write().unwrap();
+            (*cne_uids).insert(register.cne_uid);
+        }
+        if CndpUdpCommon::has_fwd_port_thd_quit(&self.fwd_port_thd) || CndpInstance::has_cndp_quit()
+        {
+            log::debug!("Cndp Writer forward port thread quitted");
+            return Err(CndpError::Disconnected);
+        }
+        // Get lport for fwd thread.
+        let lport = self.lport;
+        let ret = self.write_lport(buf, dst, &lport);
+        if ret < 0 {
+            log::error!("Cndp Writer failed");
+            return Err(CndpError::WriterError);
+        }
+        Ok(())
+    }
+}
+
+impl CndpUdpBufferedWriter<'static> {
+    fn write_lport(&self, buf: Vec<u8>, dst: &mut CndpEndpoint, lport: &jcfg_lport) -> i32 {
+        if dst.ip.is_none() {
+            log::debug!("Dst ip address is not set: dst = {:?}", dst);
+            return -1;
+        }
+        if dst.port.is_none() {
+            log::debug!("Dst port is not set");
+            return -1;
+        }
+        if dst.mac.is_none() {
+            let mut cur_dst_mac_map = self.dst_mac_map.write().unwrap();
+            let dst_ip = dst.ip.unwrap();
+            // If dst_mac for this dst_ip is not in map get it via ARP.
+            if !(*cur_dst_mac_map).contains_key(&dst_ip) {
+                let dst_ipv4 = match dst_ip {
+                    IpAddr::V4(ip) => ip,
+                    _ => unreachable!(),
+                };
+                let iface_name = self.iface_name.as_ref();
+                let (_, dst_mac) = CndpPacket::get_mac_through_arp(&iface_name.unwrap(), dst_ipv4);
+                if let Some(dst_mac) = dst_mac {
+                    log::debug!("dst mac from ARP = {}", dst_mac);
+                    // Store dst_mac in map.
+                    (*cur_dst_mac_map).insert(dst_ip, dst_mac);
+                } else {
+                    log::debug!("Dst mac couldn't be determined");
+                    return -1;
+                }
+            }
+            let dst_mac = (*cur_dst_mac_map).get(&dst_ip).expect("Dst mac not found");
+            dst.mac = Some(*dst_mac);
+        }
+        let pkt_send_data = PacketSendData {
+            buf: buf,
+            src_endpoint: self.endpoint.unwrap(),
+            dst_endpoint: *dst,
+        };
+        // Buffer n/w packets in a vector.
+        let mut pkts = self.pkts.write().unwrap();
+        (*pkts).push(pkt_send_data);
+        if (*pkts).len() >= CndpUdpCommon::WRITE_THRESHOLD_NUM_PKTS {
+            // Stop timer if it's running and send n/w packets from this thread.
+            let timer = self.timer.read().unwrap();
+            if let Some(timer) = &*timer {
+                timer.stop();
+            }
+            //log::info!("Send pkts threshold reached");
+            CndpUdpCommon::send_pkts(&mut *pkts, lport);
+            (*pkts).clear();
+        } else {
+            let mut timer = self.timer.write().unwrap();
+            // Create timer if it doesn't exist. This timer is used to
+            // send n/w packets after a specified interval. All the packets buffered
+            // will be send when timer expires.
+            if timer.is_none() {
+                log::debug!("Create Timer and callback");
+                let writer = self.clone();
+                let runner = &self.runner;
+                let timer_new = runner.timer(move || {
+                    Self::timer_callback(&writer);
+                });
+                *timer = Some(timer_new);
+            }
+            // Start the timer, but only if the timer is not already pending.
+            let res = (*timer).as_ref().unwrap().start(Duration::from_micros(
+                CndpUdpCommon::WRITE_CALLBACK_TIMER_DURATION_IN_MICROS,
+            ));
+            if res {
+                log::debug!("Timer started");
+            } else {
+                log::debug!("Timer already running");
+            }
+        }
+        return 0;
+    }
+
+    fn timer_callback(writer: &CndpUdpBufferedWriter<'static>) {
+        let _register = CneRegister::new("CndpUdpTimerCallback", None);
+        if CndpUdpCommon::has_fwd_port_thd_quit(&writer.fwd_port_thd)
+            || CndpInstance::has_cndp_quit()
+        {
+            log::debug!("Cndp Writer forward port thread quitted");
+            return;
+        }
+        let mut pkts = writer.pkts.write().unwrap();
+        if (*pkts).len() > 0 {
+            let lport = writer.lport;
+            //log::info!("Send pkts from Timer callback");
+            CndpUdpCommon::send_pkts(&mut *pkts, &lport);
+            (*pkts).clear();
+        }
+    }
+}
+
+impl<'a> Drop for CndpUdpBufferedWriter<'a> {
+    fn drop(&mut self) {
+        log::debug!("CndpUdpBufferedWriter drop");
+        let cne_uids = self.cne_uids.write().unwrap();
+        CndpUdpCommon::unregister_cne_uids(&(*cne_uids));
+    }
+}
+
+impl<'a> Deref for CndpUdpBufferQueueWriter<'a> {
+    type Target = CndpUdpBufferQueueWriterInner<'a>;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+
+impl Clone for CndpUdpBufferQueueWriter<'static> {
+    fn clone(&self) -> Self {
+        CndpUdpBufferQueueWriter {
+            inner: self.inner.clone(),
+        }
+    }
+}
+
+impl PlatformUDP for CndpUdpBufferQueue {
+    type Owner = CndpOwner<'static>;
+    fn bind(port: u16) -> Result<(Vec<Self::Reader>, Self::Writer, Self::Owner), Self::Error> {
+        log::info!("Wireguard called bind at port {}", port);
+        let register = CneRegister::new("CndpUdpBuffered", None);
+        // Get Cndp UDP Json Data.
+        let json_data = CndpUdpCommon::get_json_data(port);
+        // Create Arc RwLock.
+        let fwd_port_thd_reader_arc_mutex = Arc::new(RwLock::new(json_data.fwd_port_thd_reader));
+        // Create Cndp UDP Reader.
+        let reader = CndpUdpReader {
+            iface_name: json_data.iface_name.clone(),
+            endpoint: json_data.endpoint,
+            fwd_port_thd: Arc::clone(&fwd_port_thd_reader_arc_mutex),
+            lport: json_data.lport_reader,
+            core_id: json_data.reader_core_id,
+            cne_uids: RwLock::new(HashSet::new()),
+            cur_pkt_index: -1,
+            last_num_pkts_read: 0,
+        };
+        let readers: Vec<Self::Reader> = vec![reader];
+        // Create Arc RwLock.
+        let fwd_port_thd_writer_arc_mutex = Arc::new(RwLock::new(json_data.fwd_port_thd_writer));
+        // Create Cndp UDP Buffered Writer.
+        let writer = CndpUdpBufferQueueWriter {
+            inner: Arc::new(CndpUdpBufferQueueWriterInner {
+                iface_name: json_data.iface_name.clone(),
+                endpoint: json_data.endpoint,
+                dst_mac_map: RwLock::new(HashMap::new()),
+                fwd_port_thd: Arc::clone(&fwd_port_thd_writer_arc_mutex),
+                lport: json_data.lport_writer,
+                core_id: json_data.writer_core_id,
+                cne_uids: RwLock::new(HashSet::new()),
+                pkts: SegQueue::new(),
+                runner: Runner::new(Duration::from_micros(10), 1000, 1024),
+                timer: RwLock::new(None),
+            }),
+        };
+
+        let owner = CndpOwner {
+            cne_uid: register.cne_uid,
+            fwd_port_thd_reader: Arc::clone(&fwd_port_thd_reader_arc_mutex),
+            fwd_port_thd_writer: Arc::clone(&fwd_port_thd_writer_arc_mutex),
+        };
+        // Show metrics if enabled. Run in a separate thread.
+        let metrics_thread_coreid = match CndpInstance::read_config("metrics_thread_coreid") {
+            Some(v) => v.as_integer().expect("core id should be integer"),
+            None => -1,
+        };
+        if metrics_thread_coreid > 0 {
+            thread::spawn(move || {
+                CndpInstance::show_metrics(Some(metrics_thread_coreid as usize));
+            });
+        }
+        return Ok((readers, writer.clone(), owner));
+    }
+}
+
+impl Writer<CndpEndpoint> for CndpUdpBufferQueueWriter<'static> {
+    type Error = CndpError;
+    fn write(&self, buf: Vec<u8>, dst: &mut CndpEndpoint) -> Result<(), Self::Error> {
+        // If this function is called from a Wireguard Rust thread register it with CNDP.
+        let register = CneRegister::new("CndpUdpBufferQueueWriter", None);
+        if register.cne_uid > 0 {
+            let mut cne_uids = self.cne_uids.write().unwrap();
+            (*cne_uids).insert(register.cne_uid);
+        }
+        if CndpUdpCommon::has_fwd_port_thd_quit(&self.fwd_port_thd) || CndpInstance::has_cndp_quit()
+        {
+            log::debug!("Cndp Writer forward port thread quitted");
+            return Err(CndpError::Disconnected);
+        }
+        // Get lport for fwd thread.
+        let lport = self.lport;
+        let ret = self.write_lport(buf, dst, &lport);
+        if ret < 0 {
+            log::error!("Cndp Writer failed");
+            return Err(CndpError::WriterError);
+        }
+        Ok(())
+    }
+}
+
+impl CndpUdpBufferQueueWriter<'static> {
+    fn write_lport(&self, buf: Vec<u8>, dst: &mut CndpEndpoint, lport: &jcfg_lport) -> i32 {
+        if dst.ip.is_none() {
+            log::debug!("Dst ip address is not set: dst = {:?}", dst);
+            return -1;
+        }
+        if dst.port.is_none() {
+            log::debug!("Dst port is not set");
+            return -1;
+        }
+        if dst.mac.is_none() {
+            let mut cur_dst_mac_map = self.dst_mac_map.write().unwrap();
+            let dst_ip = dst.ip.unwrap();
+            // If dst_mac for this dst_ip is not in map get it via ARP.
+            if !(*cur_dst_mac_map).contains_key(&dst_ip) {
+                let dst_ipv4 = match dst_ip {
+                    IpAddr::V4(ip) => ip,
+                    _ => unreachable!(),
+                };
+                let iface_name = self.iface_name.as_ref();
+                let (_, dst_mac) = CndpPacket::get_mac_through_arp(&iface_name.unwrap(), dst_ipv4);
+                if let Some(dst_mac) = dst_mac {
+                    log::debug!("dst mac from ARP = {}", dst_mac);
+                    // Store dst_mac in map.
+                    (*cur_dst_mac_map).insert(dst_ip, dst_mac);
+                } else {
+                    log::debug!("Dst mac couldn't be determined");
+                    return -1;
+                }
+            }
+            let dst_mac = (*cur_dst_mac_map).get(&dst_ip).expect("Dst mac not found");
+            dst.mac = Some(*dst_mac);
+        }
+        let pkt_send_data = PacketSendData {
+            buf: buf,
+            src_endpoint: self.endpoint.unwrap(),
+            dst_endpoint: *dst,
+        };
+        // Buffer n/w packets in a vector.
+        self.pkts.push(pkt_send_data);
+        let num_queued = self.pkts.len();
+        if num_queued >= CndpUdpCommon::WRITE_THRESHOLD_NUM_PKTS {
+            // Stop timer if it's running and send n/w packets from this thread.
+            let timer = self.timer.read().unwrap();
+            if let Some(timer) = &*timer {
+                timer.stop();
+            }
+            //log::info!("Send pkts threshold reached");
+            self.send_pkts(num_queued, lport);
+        } else {
+            let timer = self.timer.read().unwrap();
+            // Create timer if it doesn't exist. This timer is used to
+            // send n/w packets after a specified interval. All the packets buffered
+            // will be send when timer expires.
+            if timer.is_none() {
+                drop(timer);
+                let mut timer = self.timer.write().unwrap();
+                log::debug!("Create Timer and callback");
+                let writer = self.clone();
+                let runner = &self.runner;
+                let timer_new = runner.timer(move || {
+                    Self::timer_callback(&writer);
+                });
+                *timer = Some(timer_new);
+                (*timer).as_ref().unwrap().start(Duration::from_micros(
+                    CndpUdpCommon::WRITE_CALLBACK_TIMER_DURATION_IN_MICROS,
+                ));
+            } else {
+                // Start the timer, but only if the timer is not already pending.
+                let res = (*timer).as_ref().unwrap().start(Duration::from_micros(
+                    CndpUdpCommon::WRITE_CALLBACK_TIMER_DURATION_IN_MICROS,
+                ));
+                if res {
+                    log::debug!("Timer started");
+                } else {
+                    log::debug!("Timer already running");
+                }
+            }
+        }
+        return 0;
+    }
+
+    fn timer_callback(writer: &CndpUdpBufferQueueWriter<'static>) {
+        let _register = CneRegister::new("CndpUdpTimerCallback", None);
+        if CndpUdpCommon::has_fwd_port_thd_quit(&writer.fwd_port_thd)
+            || CndpInstance::has_cndp_quit()
+        {
+            log::debug!("Cndp Writer forward port thread quitted");
+            return;
+        }
+        let num_queued = writer.pkts.len();
+        if num_queued > 0 {
+            let lport = writer.lport;
+            //log::info!("Send pkts from Timer callback");
+            writer.send_pkts(num_queued, &lport);
+        }
+    }
+
+    fn send_pkts(&self, num_queued: usize, lport: &jcfg_lport) -> i32 {
+        if let Some(fport) = get_fwd_port(lport) {
+            // Get TX pktmbuf buffers -> pktmbuf** pointer
+            let tx_pktmbufs_pptr = get_tx_mbufs(&fport).unwrap();
+            let num_pkts_to_send = num_queued;
+            let n_pkts = unsafe {
+                pktdev_buf_alloc(
+                    fport.lport as i32,
+                    tx_pktmbufs_pptr,
+                    num_pkts_to_send as u16,
+                ) as u16
+            };
+            if n_pkts < num_pkts_to_send as u16 {
+                log::debug!("Cannot allocate enough buffers to send all packets");
+                log::debug!("Requested = {}, Allocated = {}", num_pkts_to_send, n_pkts);
+            }
+            if n_pkts > 0 {
+                log::debug!(
+                    "Send {} UDP packets at time {}",
+                    n_pkts,
+                    SystemTime::now()
+                        .duration_since(std::time::UNIX_EPOCH)
+                        .unwrap()
+                        .as_micros()
+                );
+                let mut n_pkts_to_send = n_pkts;
+                for i in 0..n_pkts {
+                    // Get pkt from front of the queue.
+                    let pkt = self.pkts.pop();
+                    if pkt.is_none() {
+                        n_pkts_to_send = i;
+                        break;
+                    }
+                    let pkt = pkt.unwrap();
+                    let buf = pkt.buf;
+                    let src_endpoint = pkt.src_endpoint;
+                    let dst_endpoint = pkt.dst_endpoint;
+                    // Get a single TX pktmbuf.
+                    let pkt_mbuf = get_item_at_index(i as u16, tx_pktmbufs_pptr);
+                    // Update pktmbuf with UDP data (payload + ip/udp/eth headers).
+                    let ret = CndpUdpCommon::update_pktmbuf(
+                        &buf,
+                        &pkt_mbuf,
+                        &src_endpoint,
+                        &dst_endpoint,
+                    );
+                    if ret < 0 {
+                        log::error!("update_pktmbuf failed");
+                        // Free buffers and return
+                        CndpUdpCommon::free_tx_buffers(
+                            fport.lport as u16,
+                            tx_pktmbufs_pptr,
+                            n_pkts,
+                        );
+                        return -1;
+                    }
+                }
+                let mut n = 0 as u16;
+                loop {
+                    // TX buffers (pktmbufs) starting at index n.
+                    let tx_mbufs = get_tx_mbufs(&fport).unwrap();
+                    let tx_mbufs = unsafe { tx_mbufs.offset(n as isize) };
+                    n = unsafe { pktdev_tx_burst_fn(fport.lport as u16, tx_mbufs, n_pkts_to_send) };
+                    log::debug!(
+                        "Sent {} UDP packets at time {}",
+                        n,
+                        SystemTime::now()
+                            .duration_since(std::time::UNIX_EPOCH)
+                            .unwrap()
+                            .as_micros()
+                    );
+                    if n_pkts_to_send <= n {
+                        break;
+                    }
+                    log::debug!("Couldn't send all packets. Retry");
+                    n_pkts_to_send -= n;
+                }
+            }
+            CndpUdpCommon::free_tx_buffers(fport.lport as u16, tx_pktmbufs_pptr, n_pkts as u16);
+        }
+        return 0;
+    }
+}
+
+impl<'a> Drop for CndpUdpBufferQueueWriter<'a> {
+    fn drop(&mut self) {
+        log::debug!("CndpUdpBufferQueueWriter drop");
+        let cne_uids = self.cne_uids.write().unwrap();
+        CndpUdpCommon::unregister_cne_uids(&(*cne_uids));
+    }
+}
+
+pub struct CndpOwner<'a> {
+    cne_uid: i32,
+    fwd_port_thd_reader: Arc<RwLock<&'a mut jcfg_thd>>,
+    fwd_port_thd_writer: Arc<RwLock<&'a mut jcfg_thd>>,
+}
+
+impl<'a> Owner for CndpOwner<'a> {
+    type Error = CndpError;
+
+    fn set_fwmark(&mut self, _value: Option<u32>) -> Result<(), Self::Error> {
+        Ok(())
+    }
+
+    fn get_port(&self) -> u16 {
+        0
+    }
+}
+
+impl<'a> Drop for CndpOwner<'a> {
+    fn drop(&mut self) {
+        log::debug!("CndpOwner drop");
+        // Quit writer thread.
+        let mut fwd_port_thd_writer = self.fwd_port_thd_writer.write().unwrap();
+        (*fwd_port_thd_writer).quit = 1;
+        // Quit reader thread.
+        let mut fwd_port_thd_reader = self.fwd_port_thd_reader.write().unwrap();
+        (*fwd_port_thd_reader).quit = 1;
+        // Unregister CndpOwner thread registered with CNDP.
+        unsafe { cne_unregister(self.cne_uid) };
+    }
+}
diff --git a/src/platform/linux/cndp/util.rs b/src/platform/linux/cndp/util.rs
new file mode 100644
index 0000000..7a1dbf2
--- /dev/null
+++ b/src/platform/linux/cndp/util.rs
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+
+use std::ffi::CStr;
+use std::ffi::CString;
+
+pub fn get_cstring_from_str(s: &str) -> CString {
+    let cstring = CString::new(s).unwrap();
+    return cstring;
+}
+
+pub fn get_str_from_raw_ptr<'a>(s_raw: *mut i8) -> &'a str {
+    let s_cstr: &CStr = unsafe { CStr::from_ptr(s_raw) };
+    let s_str = s_cstr.to_str().unwrap();
+    return s_str;
+}
+
+#[allow(dead_code)]
+pub fn get_rust_arg_from_cvoid_ptr<'a, T>(cvoid_arg: *mut libc::c_void) -> Option<&'a mut T> {
+    if cvoid_arg.is_null() {
+        return None;
+    }
+    let rust_arg = unsafe { &mut *(cvoid_arg as *mut T) };
+    return Some(rust_arg);
+}
+
+#[allow(dead_code)]
+pub fn get_rust_arg_from_cvoid_double_ptr<'a, T>(
+    cvoid_arg: *mut *mut libc::c_void,
+) -> Option<&'a mut *mut T> {
+    if cvoid_arg.is_null() {
+        return None;
+    }
+    let rust_arg = unsafe { &mut *(cvoid_arg as *mut *mut T) };
+    return Some(rust_arg);
+}
diff --git a/src/platform/linux/cndp/wg_cndp.toml b/src/platform/linux/cndp/wg_cndp.toml
new file mode 100644
index 0000000..a317ed0
--- /dev/null
+++ b/src/platform/linux/cndp/wg_cndp.toml
@@ -0,0 +1,35 @@
+# SPDX-License-Identifier: BSD-3-Clause
+# Copyright(c) 2019-2021 Intel Corporation.
+
+# jsonc absolute file path to configure CNDP.
+#jsonc = "/home/manoj/wireguard/cndp/wireguard-rs/src/platform/linux/cndp/fwd.jsonc"
+jsonc = "/home/manoj/wireguard/cndp/wireguard-rs/src/platform/linux/cndp/cndp_pkt_fwd.jsonc"
+
+# UDP reader thread core id affinity. If it's not present then core affinity won't be set.
+reader_thread_coreid = 25
+
+# UDP writer thread core id affinity. If it's not present then core affinity won't be set.
+writer_thread_coreid = 35
+
+# CNDP metrics thread core id affinity. -1 will disable metrics.
+metrics_thread_coreid = -1 #24
+
+# Wireguard TUN reader core id affinity. If it's not present then core affinity won't be set.
+tun_reader_thread_coreid = 22
+
+# Number of workers (To do encrypt/decrypt)
+wg_num_workers = 4
+
+# Wireguard worker threads core id affinity base. Each worker thread will be assigned a core affinity
+# starting from base and will be incremented by 1. For example, if there are 4 worker threads and base
+# core id is 26, then core affinity for worker threads will be set on core ids 26,27,28 and 29.
+# If it's not present then core affinity won't be set.
+wg_worker_thread_base_coreid = 26
+
+# Packet reader thread core id affinity. If it's not present then core affinity won't be set.
+# This setting is required only for custom wireguard+cndp app.
+packet_reader_thread_coreid = 36
+# Packet writer thread core id affinity. If it's not present then core affinity won't be set.
+# This setting is required only for custom wirguard+cndp app.
+packet_writer_thread_coreid = 37
+packet_writer_sender_channel_thread_coreid = 38
diff --git a/src/platform/linux/cndp/wrapper.h b/src/platform/linux/cndp/wrapper.h
new file mode 100644
index 0000000..1276b15
--- /dev/null
+++ b/src/platform/linux/cndp/wrapper.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019-2021 Intel Corporation.
+ */
+
+#include <signal.h>            // for SIGUSR1, SIGINT
+#include <cne.h>               // for cne_init, cne_on_exit, CNE_CALLED_EXIT
+#include <jcfg.h>              // for jcfg_obj_t, jcfg_umem_t, jcfg_opt_t
+#include <pktdev.h>            // for pktdev_rx_burst, pktdev_tx_burst
+#include <pktmbuf.h>           // for pktmbuf_pool_create, pktmbuf_info_t
+#include <txbuff.h>            // for txbuff_t, txbuff_add, txbuff_free, txbuff_...
+#include <locale.h>            // for setlocale, LC_ALL
+#include "jcfg_parse/fwd.h"
+#include "jcfg_parse/rust_helper.h"
diff --git a/src/platform/linux/mod.rs b/src/platform/linux/mod.rs
index d28391e..df10790 100644
--- a/src/platform/linux/mod.rs
+++ b/src/platform/linux/mod.rs
@@ -4,4 +4,14 @@ mod udp;
 
 pub use tun::LinuxTun as Tun;
 pub use uapi::LinuxUAPI as UAPI;
+#[cfg(all(target_os = "linux", not(feature = "cndp")))]
 pub use udp::LinuxUDP as UDP;
+
+#[cfg(all(target_os = "linux", feature = "cndp"))]
+pub mod cndp;
+#[cfg(all(target_os = "linux", feature = "cndp"))]
+pub use cndp::udp::CndpUdpSyncChannel as UDP;
+// Keep below commented for future reference.
+//pub use cndp::udp::CndpUdpBufferQueue as UDP;
+//pub use cndp::udp::CndpUdpBuffered as UDP;
+
diff --git a/src/platform/linux/tun.rs b/src/platform/linux/tun.rs
index 82fada1..062a4ae 100644
--- a/src/platform/linux/tun.rs
+++ b/src/platform/linux/tun.rs
@@ -114,7 +114,7 @@ impl Writer for LinuxTunWriter {
     }
 }
 
-fn get_ifindex(name: &[u8; libc::IFNAMSIZ]) -> i32 {
+pub fn get_ifindex(name: &[u8; libc::IFNAMSIZ]) -> i32 {
     debug_assert_eq!(
         name[libc::IFNAMSIZ - 1],
         0,
@@ -129,7 +129,7 @@ fn get_ifindex(name: &[u8; libc::IFNAMSIZ]) -> i32 {
     idx as i32
 }
 
-fn get_mtu(name: &[u8; libc::IFNAMSIZ]) -> Result<usize, LinuxTunError> {
+pub fn get_mtu(name: &[u8; libc::IFNAMSIZ]) -> Result<usize, LinuxTunError> {
     #[repr(C)]
     struct arg {
         name: [u8; libc::IFNAMSIZ],
@@ -267,7 +267,7 @@ impl LinuxTunStatus {
     const RTNLGRP_IPV4_IFADDR: libc::c_uint = 5;
     const RTNLGRP_IPV6_IFADDR: libc::c_uint = 9;
 
-    fn new(name: [u8; libc::IFNAMSIZ]) -> Result<LinuxTunStatus, LinuxTunError> {
+    pub fn new(name: [u8; libc::IFNAMSIZ]) -> Result<LinuxTunStatus, LinuxTunError> {
         // create netlink socket
         let fd = unsafe { libc::socket(libc::AF_NETLINK, libc::SOCK_RAW, libc::NETLINK_ROUTE) };
         if fd < 0 {
diff --git a/src/platform/linux/udp.rs b/src/platform/linux/udp.rs
index b62d5bf..f953e2f 100644
--- a/src/platform/linux/udp.rs
+++ b/src/platform/linux/udp.rs
@@ -308,7 +308,7 @@ impl LinuxUDPReader {
 impl Reader<LinuxEndpoint> for LinuxUDPReader {
     type Error = io::Error;
 
-    fn read(&self, buf: &mut [u8]) -> Result<(usize, LinuxEndpoint), Self::Error> {
+    fn read(&mut self, buf: &mut [u8]) -> Result<(usize, LinuxEndpoint), Self::Error> {
         match self {
             Self::V4(fd) => Self::read4(fd.0, buf),
             Self::V6(fd) => Self::read6(fd.0, buf),
@@ -451,10 +451,10 @@ impl LinuxUDPWriter {
 impl Writer<LinuxEndpoint> for LinuxUDPWriter {
     type Error = io::Error;
 
-    fn write(&self, buf: &[u8], dst: &mut LinuxEndpoint) -> Result<(), Self::Error> {
+    fn write(&self, buf: Vec<u8>, dst: &mut LinuxEndpoint) -> Result<(), Self::Error> {
         match dst {
-            LinuxEndpoint::V4(ref mut end) => Self::write4(self.sock4.0, buf, end),
-            LinuxEndpoint::V6(ref mut end) => Self::write6(self.sock6.0, buf, end),
+            LinuxEndpoint::V4(ref mut end) => Self::write4(self.sock4.0, &buf, end),
+            LinuxEndpoint::V6(ref mut end) => Self::write6(self.sock6.0, &buf, end),
         }
     }
 }
diff --git a/src/platform/udp.rs b/src/platform/udp.rs
index 0b9c823..d8e5c24 100644
--- a/src/platform/udp.rs
+++ b/src/platform/udp.rs
@@ -4,13 +4,13 @@ use std::error::Error;
 pub trait Reader<E: Endpoint>: Send + Sync {
     type Error: Error;
 
-    fn read(&self, buf: &mut [u8]) -> Result<(usize, E), Self::Error>;
+    fn read(&mut self, buf: &mut [u8]) -> Result<(usize, E), Self::Error>;
 }
 
 pub trait Writer<E: Endpoint>: Send + Sync + 'static {
     type Error: Error;
 
-    fn write(&self, buf: &[u8], dst: &mut E) -> Result<(), Self::Error>;
+    fn write(&self, buf: Vec<u8>, dst: &mut E) -> Result<(), Self::Error>;
 }
 
 pub trait UDP: Send + Sync + 'static {
diff --git a/src/wireguard/constants.rs b/src/wireguard/constants.rs
index 4d89d46..e261f88 100644
--- a/src/wireguard/constants.rs
+++ b/src/wireguard/constants.rs
@@ -55,3 +55,6 @@ pub const TIMERS_CAPACITY: usize = 16;
  * Note, this duration need not fit inside the timer wheel.
  */
 pub const TIME_HORIZON: Duration = Duration::from_secs(TIMER_MAX_DURATION.as_secs() * 2);
+
+// Num of worker threads.
+pub const NUM_WORKERS: usize = 4;
diff --git a/src/wireguard/handshake/macs.rs b/src/wireguard/handshake/macs.rs
index f4f5586..f2004dd 100644
--- a/src/wireguard/handshake/macs.rs
+++ b/src/wireguard/handshake/macs.rs
@@ -9,7 +9,7 @@ use x25519_dalek::PublicKey;
 
 // AEAD
 
-use aead::{Aead, NewAead, Payload};
+use chacha20poly1305::aead::{Aead, NewAead, Payload};
 use chacha20poly1305::XChaCha20Poly1305;
 
 // MAC
@@ -56,7 +56,7 @@ macro_rules! MAC {
 
 macro_rules! XSEAL {
     ($key:expr, $nonce:expr, $ad:expr, $pt:expr, $ct:expr) => {{
-        let ct = XChaCha20Poly1305::new(GenericArray::from_slice($key))
+        let ct = XChaCha20Poly1305::new(chacha20poly1305::Key::from_slice($key))
             .encrypt(
                 GenericArray::from_slice($nonce),
                 Payload { msg: $pt, aad: $ad },
@@ -70,7 +70,7 @@ macro_rules! XSEAL {
 macro_rules! XOPEN {
     ($key:expr, $nonce:expr, $ad:expr, $pt:expr, $ct:expr) => {{
         debug_assert_eq!($ct.len(), $pt.len() + SIZE_TAG);
-        XChaCha20Poly1305::new(GenericArray::from_slice($key))
+        XChaCha20Poly1305::new(chacha20poly1305::Key::from_slice($key))
             .decrypt(
                 GenericArray::from_slice($nonce),
                 Payload { msg: $ct, aad: $ad },
diff --git a/src/wireguard/handshake/noise.rs b/src/wireguard/handshake/noise.rs
index 92c8c5f..cb14ad1 100644
--- a/src/wireguard/handshake/noise.rs
+++ b/src/wireguard/handshake/noise.rs
@@ -8,7 +8,7 @@ use blake2::Blake2s;
 use hmac::Hmac;
 
 // AEAD
-use aead::{Aead, NewAead, Payload};
+use chacha20poly1305::aead::{Aead, NewAead, Payload};
 use chacha20poly1305::ChaCha20Poly1305;
 
 use rand_core::{CryptoRng, RngCore};
@@ -112,7 +112,7 @@ macro_rules! KDF3 {
 
 macro_rules! SEAL {
     ($key:expr, $ad:expr, $pt:expr, $ct:expr) => {
-        ChaCha20Poly1305::new(GenericArray::from_slice($key))
+        ChaCha20Poly1305::new(chacha20poly1305::Key::from_slice($key))
             .encrypt(&ZERO_NONCE.into(), Payload { msg: $pt, aad: $ad })
             .map(|ct| $ct.copy_from_slice(&ct))
             .unwrap()
@@ -121,7 +121,7 @@ macro_rules! SEAL {
 
 macro_rules! OPEN {
     ($key:expr, $ad:expr, $pt:expr, $ct:expr) => {
-        ChaCha20Poly1305::new(GenericArray::from_slice($key))
+        ChaCha20Poly1305::new(chacha20poly1305::Key::from_slice($key))
             .decrypt(&ZERO_NONCE.into(), Payload { msg: $ct, aad: $ad })
             .map_err(|_| HandshakeError::DecryptionFailure)
             .map(|pt| $pt.copy_from_slice(&pt))
diff --git a/src/wireguard/router/device.rs b/src/wireguard/router/device.rs
index eeae621..f3f0396 100644
--- a/src/wireguard/router/device.rs
+++ b/src/wireguard/router/device.rs
@@ -103,7 +103,11 @@ impl<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> Drop
 }
 
 impl<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> DeviceHandle<E, C, T, B> {
-    pub fn new(num_workers: usize, tun: T) -> DeviceHandle<E, C, T, B> {
+    pub fn new(
+        num_workers: usize,
+        tun: T,
+        worker_thread_base_coreid: Option<usize>,
+    ) -> DeviceHandle<E, C, T, B> {
         let (work, mut consumers) = ParallelQueue::new(num_workers, PARALLEL_QUEUE_SIZE);
         let device = Device {
             inner: Arc::new(DeviceInner {
@@ -117,8 +121,18 @@ impl<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> DeviceHandle<
 
         // start worker threads
         let mut threads = Vec::with_capacity(num_workers);
+        let mut core_id: usize = 0;
         while let Some(rx) = consumers.pop() {
-            threads.push(thread::spawn(move || worker(rx)));
+            threads.push(thread::spawn(move || {
+                // Set core affinity for worker threads starting with worker_thread_base_coreid.
+                if let Some(worker_thread_base_coreid) = worker_thread_base_coreid {
+                    core_affinity::set_for_current(core_affinity::CoreId {
+                        id: core_id + worker_thread_base_coreid,
+                    });
+                }
+                worker(rx);
+            }));
+            core_id += 1;
         }
         debug_assert!(num_workers > 0, "zero worker threads");
         debug_assert_eq!(
@@ -134,7 +148,7 @@ impl<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> DeviceHandle<
         }
     }
 
-    pub fn send_raw(&self, msg: &[u8], dst: &mut E) -> Result<(), B::Error> {
+    pub fn send_raw(&self, msg: Vec<u8>, dst: &mut E) -> Result<(), B::Error> {
         let bind = self.state.outbound.read();
         if bind.0 {
             if let Some(bind) = bind.1.as_ref() {
@@ -188,7 +202,6 @@ impl<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> DeviceHandle<
         // ignore header prefix (for in-place transport message construction)
         let packet = &msg[SIZE_MESSAGE_PREFIX..];
 
-        // lookup peer based on IP packet destination address
         let peer = self
             .state
             .table
diff --git a/src/wireguard/router/peer.rs b/src/wireguard/router/peer.rs
index 0803b13..cff06a9 100644
--- a/src/wireguard/router/peer.rs
+++ b/src/wireguard/router/peer.rs
@@ -222,7 +222,7 @@ impl<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> PeerInner<E,
     /// # Returns
     ///
     /// Unit if packet was sent, or an error indicating why sending failed
-    pub fn send_raw(&self, msg: &[u8]) -> Result<(), RouterError> {
+    pub fn send_raw(&self, msg: Vec<u8>) -> Result<(), RouterError> {
         // send to endpoint (if known)
         match self.endpoint.lock().as_mut() {
             Some(endpoint) => {
diff --git a/src/wireguard/router/queue.rs b/src/wireguard/router/queue.rs
index b266a57..6120575 100644
--- a/src/wireguard/router/queue.rs
+++ b/src/wireguard/router/queue.rs
@@ -41,6 +41,7 @@ impl<J: SequentialJob> Queue<J> {
         self.queue.lock().push_back(job).is_ok()
     }
 
+    #[cfg(all(target_os = "linux", not(feature = "cndp")))]
     pub fn consume(&self) {
         // check if we are the first contender
         let pos = self.contenders.fetch_add(1, Ordering::SeqCst);
@@ -89,6 +90,32 @@ impl<J: SequentialJob> Queue<J> {
             contenders = self.contenders.fetch_sub(contenders, Ordering::SeqCst) - contenders;
         }
     }
+
+    #[cfg(all(target_os = "linux", feature = "cndp"))]
+    pub fn consume(&self) {
+        // handle every ready element
+        loop {
+            let mut queue = self.queue.lock();
+
+            // check if front job is ready
+            match queue.front() {
+                None => break,
+                Some(job) => {
+                    if !job.is_ready() {
+                        break;
+                    }
+                }
+            };
+
+            // take the job out of the queue
+            let job = queue.pop_front().unwrap();
+            debug_assert!(job.is_ready());
+            mem::drop(queue);
+
+            // process element
+            job.sequential_work();
+        }
+    }
 }
 
 #[cfg(test)]
diff --git a/src/wireguard/router/receive.rs b/src/wireguard/router/receive.rs
index 15eb8fb..2ce1adb 100644
--- a/src/wireguard/router/receive.rs
+++ b/src/wireguard/router/receive.rs
@@ -13,6 +13,9 @@ use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, CHACHA20_POLY1305};
 use spin::Mutex;
 use zerocopy::{AsBytes, LayoutVerified};
 
+#[cfg(all(target_os = "linux", feature = "openssl"))]
+use openssl::symm::{decrypt_aead, Cipher};
+
 struct Inner<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> {
     ready: AtomicBool,                       // job status
     buffer: Mutex<(Option<E>, Vec<u8>)>,     // endpoint & ciphertext buffer
@@ -91,16 +94,45 @@ impl<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> ParallelJob
                 let mut nonce = [0u8; 12];
                 debug_assert_eq!(nonce.len(), CHACHA20_POLY1305.nonce_len());
                 nonce[4..].copy_from_slice(header.f_counter.as_bytes());
-                let nonce = Nonce::assume_unique_for_key(nonce);
-                // do the weird ring AEAD dance
-                let key = LessSafeKey::new(
-                    UnboundKey::new(&CHACHA20_POLY1305, &job.state.keypair.recv.key[..]).unwrap(),
-                );
-
-                // attempt to open (and authenticate) the body
-                match key.open_in_place(nonce, Aad::empty(), packet) {
-                    Ok(_) => (),
-                    Err(_) => return false,
+                cfg_if::cfg_if! {
+                    // Use openssl library based decryption which has better peformance.
+                    if #[cfg(all(target_os = "linux", feature = "openssl"))] {
+                        let cipher = Cipher::chacha20_poly1305();
+                        const AAD: [u8; 0] = [];
+                        let tag_offset = packet.len() - SIZE_TAG;
+                        let res = decrypt_aead(
+                            cipher,
+                            &job.state.keypair.recv.key[..],
+                            Some(&nonce),
+                            &AAD,
+                            &packet[..tag_offset],
+                            &packet[tag_offset..],
+                        );
+                        match res {
+                            Ok(plaintext) => {
+                                // Copy plain text back to packet.
+                                // This copy can be avoided after API supports in-place decryption.
+                                packet[..tag_offset].copy_from_slice(&plaintext);
+                            }
+                            Err(_) => {
+                                log::error!("Decryption failed");
+                                return false;
+                            }
+                        }
+                    } else {
+                        let nonce = Nonce::assume_unique_for_key(nonce);
+                        // do the weird ring AEAD dance
+                        let key = LessSafeKey::new(
+                            UnboundKey::new(&CHACHA20_POLY1305, &job.state.keypair.recv.key[..])
+                                .unwrap(),
+                        );
+
+                        // attempt to open (and authenticate) the body
+                        match key.open_in_place(nonce, Aad::empty(), packet) {
+                            Ok(_) => (),
+                            Err(_) => return false,
+                        }
+                    }
                 }
 
                 // check that counter not after reject
diff --git a/src/wireguard/router/send.rs b/src/wireguard/router/send.rs
index 7e14209..6cedf3e 100644
--- a/src/wireguard/router/send.rs
+++ b/src/wireguard/router/send.rs
@@ -14,9 +14,12 @@ use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, CHACHA20_POLY1305};
 use spin::Mutex;
 use zerocopy::{AsBytes, LayoutVerified};
 
+#[cfg(all(target_os = "linux", feature = "openssl"))]
+use openssl::symm::{encrypt_aead, Cipher};
+
 struct Inner<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> {
     ready: AtomicBool,
-    buffer: Mutex<Vec<u8>>,
+    buffer: Arc<Mutex<Option<Vec<u8>>>>,
     counter: u64,
     keypair: Arc<KeyPair>,
     peer: Peer<E, C, T, B>,
@@ -40,7 +43,7 @@ impl<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> SendJob<E, C,
         peer: Peer<E, C, T, B>,
     ) -> SendJob<E, C, T, B> {
         SendJob(Arc::new(Inner {
-            buffer: Mutex::new(buffer),
+            buffer: Arc::new(Mutex::new(Some(buffer))),
             counter,
             keypair,
             peer,
@@ -68,7 +71,8 @@ impl<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> ParallelJob
         {
             // make space for the tag
             let job = &*self.0;
-            let mut msg = job.buffer.lock();
+            // Move the vector out of job buffer (take ownership) to encrypt it.
+            let mut msg = job.buffer.lock().take().unwrap();
             msg.extend([0u8; SIZE_TAG].iter());
 
             // cast to header (should never fail)
@@ -89,19 +93,53 @@ impl<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> ParallelJob
             let mut nonce = [0u8; 12];
             debug_assert_eq!(nonce.len(), CHACHA20_POLY1305.nonce_len());
             nonce[4..].copy_from_slice(header.f_counter.as_bytes());
-            let nonce = Nonce::assume_unique_for_key(nonce);
-
-            // encrypt contents of transport message in-place
-            let tag_offset = packet.len() - SIZE_TAG;
-            let key = LessSafeKey::new(
-                UnboundKey::new(&CHACHA20_POLY1305, &job.keypair.send.key[..]).unwrap(),
-            );
-            let tag = key
-                .seal_in_place_separate_tag(nonce, Aad::empty(), &mut packet[..tag_offset])
-                .unwrap();
-
-            // append tag
-            packet[tag_offset..].copy_from_slice(tag.as_ref());
+            cfg_if::cfg_if! {
+                // Use openssl library based encryption which has better peformance.
+                if #[cfg(all(target_os = "linux", feature = "openssl"))] {
+                    let cipher = Cipher::chacha20_poly1305();
+                    const AAD: [u8; 0] = [];
+                    let mut tag = vec![0u8; SIZE_TAG];
+                    let tag_offset = packet.len() - SIZE_TAG;
+                    let res = encrypt_aead(
+                        cipher,
+                        &job.keypair.send.key[..],
+                        Some(&nonce),
+                        &AAD,
+                        &packet[..tag_offset],
+                        &mut tag,
+                    );
+                    match res {
+                        Ok(ciphertext) => {
+                            // Copy cipher text back to packet.
+                            // This copy can be avoided after API supports in-place encryption.
+                            packet[..tag_offset].copy_from_slice(&ciphertext);
+                            // append tag.
+                            packet[tag_offset..].copy_from_slice(&tag);
+                        }
+                        Err(_) => {
+                            log::error!("Encryption failed");
+                            return;
+                        }
+                    }
+                } else {
+                    let nonce = Nonce::assume_unique_for_key(nonce);
+
+                    // encrypt contents of transport message in-place
+                    let tag_offset = packet.len() - SIZE_TAG;
+                    let key = LessSafeKey::new(
+                        UnboundKey::new(&CHACHA20_POLY1305, &job.keypair.send.key[..]).unwrap(),
+                    );
+                    let tag = key
+                        .seal_in_place_separate_tag(nonce, Aad::empty(), &mut packet[..tag_offset])
+                        .unwrap();
+
+                    // append tag
+                    packet[tag_offset..].copy_from_slice(tag.as_ref());
+                }
+            }
+            // Put job buffer back (move ownership) after encryption.
+            let mut data = job.buffer.lock();
+            *data = Some(msg);
         }
 
         // mark ready
@@ -120,17 +158,18 @@ impl<E: Endpoint, C: Callbacks, T: tun::Writer, B: udp::Writer<E>> SequentialJob
         debug_assert_eq!(
             self.is_ready(),
             true,
-            "doing sequential work 
+            "doing sequential work
             on an incomplete job"
         );
         log::trace!("processing sequential send job");
 
         // send to peer
         let job = &self.0;
-        let msg = job.buffer.lock();
-        let xmit = job.peer.send_raw(&msg[..]).is_ok();
+        let msg = job.buffer.lock().take().unwrap();
+        let msg_len = msg.len();
+        let xmit = job.peer.send_raw(msg).is_ok();
 
         // trigger callback (for timers)
-        C::send(&job.peer.opaque, msg.len(), xmit, &job.keypair, job.counter);
+        C::send(&job.peer.opaque, msg_len, xmit, &job.keypair, job.counter);
     }
 }
diff --git a/src/wireguard/router/tests/tests.rs b/src/wireguard/router/tests/tests.rs
index f6205d5..960e592 100644
--- a/src/wireguard/router/tests/tests.rs
+++ b/src/wireguard/router/tests/tests.rs
@@ -296,7 +296,7 @@ fn test_bidirectional() {
                 p1, p2, confirm_with_staged_packet
             );
 
-            let ((bind_reader1, bind_writer1), (bind_reader2, bind_writer2)) =
+            let ((mut bind_reader1, bind_writer1), (mut bind_reader2, bind_writer2)) =
                 dummy::PairBind::pair();
 
             let mut confirm_packet_size = SIZE_KEEPALIVE;
diff --git a/src/wireguard/wireguard.rs b/src/wireguard/wireguard.rs
index 44d698f..670201b 100644
--- a/src/wireguard/wireguard.rs
+++ b/src/wireguard/wireguard.rs
@@ -29,6 +29,9 @@ use hjul::Runner;
 use spin::{Mutex, RwLock};
 use x25519_dalek::{PublicKey, StaticSecret};
 
+#[cfg(all(target_os = "linux", feature = "cndp"))]
+use toml::{map::Map, Value};
+
 pub struct WireguardInner<T: Tun, B: UDP> {
     // identifier (for logging)
     pub id: u32,
@@ -58,6 +61,9 @@ pub struct WireguardInner<T: Tun, B: UDP> {
     pub last_under_load: Mutex<Instant>,
     pub pending: AtomicUsize, // number of pending handshake packets in queue
     pub queue: ParallelQueue<HandshakeJob<B::Endpoint>>,
+
+    #[cfg(all(target_os = "linux", feature = "cndp"))]
+    toml_map: Option<Map<String, Value>>,
 }
 
 pub struct WireGuard<T: Tun, B: UDP> {
@@ -254,8 +260,23 @@ impl<T: Tun, B: UDP> WireGuard<T, B> {
         // increment reader count
         wg.tun_readers.increase();
 
+        #[cfg(all(target_os = "linux", feature = "cndp"))]
+        let toml_map = self.toml_map.clone();
+
         // start worker
         thread::spawn(move || {
+            // For CNDP, set core affinity for TUN reader thread.
+            cfg_if::cfg_if! {
+                if #[cfg(all(target_os = "linux", feature = "cndp"))] {
+                    let tun_reader_core_id = match Self::read_config(&toml_map,"tun_reader_thread_coreid") {
+                        Some(v) => v.as_integer().expect("core id should be integer"),
+                        None => -1,
+                    };
+                    if tun_reader_core_id > 0 {
+                        core_affinity::set_for_current(core_affinity::CoreId { id: tun_reader_core_id as usize });
+                    }
+                }
+            }
             tun_worker(&wg, reader);
             wg.tun_readers.decrease();
         });
@@ -266,15 +287,36 @@ impl<T: Tun, B: UDP> WireGuard<T, B> {
     }
 
     pub fn new(writer: T::Writer) -> WireGuard<T, B> {
+        let mut worker_thread_base_coreid = None;
+        let mut num_workers = NUM_WORKERS;
+        cfg_if::cfg_if! {
+            if #[cfg(all(target_os = "linux", feature = "cndp"))] {
+                let toml_map = Self::load_config();
+                worker_thread_base_coreid = match Self::read_config(&toml_map,
+                            "wg_worker_thread_base_coreid") {
+                    Some(v) => Some(v.as_integer().expect("core id should be integer") as usize) ,
+                    None => None,
+                };
+                num_workers = match Self::read_config(&toml_map,
+                    "wg_num_workers") {
+                    Some(v) => v.as_integer().expect("wg_num_workers should be +ve integer") as usize ,
+                    None => NUM_WORKERS,
+                };
+            }
+        }
         // workers equal to number of physical cores
-        let cpus = num_cpus::get();
+        // Commented legacy code for reference.
+        // More worker threads can degrade performance in CPUs with may cores due to threading overhead.
+        // let cpus = num_cpus::get();
 
         // create handshake queue
-        let (tx, mut rxs) = ParallelQueue::new(cpus, 128);
+        // let (tx, mut rxs) = ParallelQueue::new(cpus, 128); // Commented legacy code for reference.
+        let (tx, mut rxs) = ParallelQueue::new(num_workers, 128);
 
         // create router
         let router: router::Device<B::Endpoint, PeerInner<T, B>, T::Writer, B::Writer> =
-            router::Device::new(num_cpus::get(), writer);
+            // router::Device::new(num_cpus::get(), writer); // Commented legacy code for reference.
+            router::Device::new(num_workers, writer, worker_thread_base_coreid);
 
         // create arc to state
         let wg = WireGuard {
@@ -289,6 +331,8 @@ impl<T: Tun, B: UDP> WireGuard<T, B> {
                 peers: RwLock::new(handshake::Device::new()),
                 runner: Mutex::new(Runner::new(TIMERS_TICK, TIMERS_SLOTS, TIMERS_CAPACITY)),
                 queue: tx,
+                #[cfg(all(target_os = "linux", feature = "cndp"))]
+                toml_map: toml_map,
             }),
         };
 
@@ -300,4 +344,40 @@ impl<T: Tun, B: UDP> WireGuard<T, B> {
 
         wg
     }
+
+    #[cfg(all(target_os = "linux", feature = "cndp"))]
+    fn load_config() -> Option<Map<String, Value>> {
+        // Parse toml.
+        // Get wg_cndp.toml file path.
+        // Assumption is that toml file is copied in same directory as executable. This has to be
+        // either done manually or via some script.
+        let mut cndp_toml_dir = std::env::current_exe().expect("Can't find path to executable");
+        cndp_toml_dir.pop();
+        cndp_toml_dir.push("wg_cndp.toml");
+        let toml_contents = std::fs::read_to_string(cndp_toml_dir.to_str().unwrap())
+            .expect("Unable to read toml file");
+        // Convert toml as Map<String, Value>
+        let toml_map = toml_contents
+            .parse::<Value>()
+            .ok()
+            .and_then(|r| match r {
+                Value::Table(table) => Some(table),
+                _ => None,
+            })
+            .unwrap_or(Map::new());
+
+        Some(toml_map)
+    }
+
+    #[cfg(all(target_os = "linux", feature = "cndp"))]
+    pub fn read_config(toml_map: &Option<Map<String, Value>>, key: &str) -> Option<Value> {
+        if let Some(toml_map) = toml_map {
+            let val = match toml_map.get(key) {
+                Some(v) => Some(v.clone()),
+                None => None,
+            };
+            return val;
+        }
+        return None;
+    }
 }
diff --git a/src/wireguard/workers.rs b/src/wireguard/workers.rs
index 27acf2f..8d81dfb 100644
--- a/src/wireguard/workers.rs
+++ b/src/wireguard/workers.rs
@@ -100,7 +100,7 @@ pub fn tun_worker<T: Tun, B: UDP>(wg: &WireGuard<T, B>, reader: T::Reader) {
     }
 }
 
-pub fn udp_worker<T: Tun, B: UDP>(wg: &WireGuard<T, B>, reader: B::Reader) {
+pub fn udp_worker<T: Tun, B: UDP>(wg: &WireGuard<T, B>, mut reader: B::Reader) {
     loop {
         // create vector big enough for any message given current MTU
         let mtu = wg.mtu.load(Ordering::Relaxed);
@@ -195,7 +195,7 @@ pub fn handshake_worker<T: Tun, B: UDP>(
                         if let Some(msg) = resp {
                             resp_len = msg.len() as u64;
                             // TODO: consider a more elegant solution for accessing the bind
-                            let _ = wg.router.send_raw(&msg[..], &mut src).map_err(|e| {
+                            let _ = wg.router.send_raw(msg, &mut src).map_err(|e| {
                                 debug!(
                                     "{} : handshake worker, failed to send response, error = {}",
                                     wg, e
@@ -255,7 +255,7 @@ pub fn handshake_worker<T: Tun, B: UDP>(
                     );
                     let device = wg.peers.read();
                     let _ = device.begin(&mut OsRng, &pk).map(|msg| {
-                        let _ = peer.send_raw(&msg[..]).map_err(|e| {
+                        let _ = peer.send_raw(msg).map_err(|e| {
                             debug!("{} : handshake worker, failed to send handshake initiation, error = {}", wg, e)
                         });
                         peer.opaque().sent_handshake_initiation();
-- 
2.30.2

